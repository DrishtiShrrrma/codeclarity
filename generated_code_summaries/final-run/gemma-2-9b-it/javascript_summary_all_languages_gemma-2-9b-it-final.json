[
  {
    "id": "sample_49723",
    "language": "javascript",
    "length_bucket": "short",
    "code": "function getPathVarMatches(pathPiece) {\n    var matches = pathPiece.match(/\\{([a-z]+)\\}/gi);\n    if (!matches)\n        return [];\n    return matches.map(function (key) { return trimAccolades(key); });\n}",
    "docstring": "Get the matches of path variables: eg. return ['groupId'] if pathPiece is '{groupId}'\n\n@export\n@param {string} pathPiece eg. 'groups' or '{groupId}'\n@returns {string[]} returns ['groupId'] in case of '{groupId}'",
    "model_name": "gemma-2-9b-it",
    "summary_english": "getPathVarMatches is a function that extracts variable names from a path string. It takes a single argument, pathPiece, which is a string. The function uses a regular expression to find occurrences of curly braces containing lowercase letters, representing variable names. If no matches are found, it returns an empty array. Otherwise, it maps each match to a new string with any leading or trailing curly braces removed.",
    "summary_chinese": "getPathVarMatches 函数用于从路径片段中提取变量匹配项。 \n\n参数：pathPiece (字符串)\n\n逻辑：\n\n1. 使用正则表达式 /\\{([a-z]+)\\}/gi 从路径片段中匹配所有以 { 开头，以 } 结尾，中间包含字母的字符串。\n2. 如果没有匹配项，返回空数组。\n3. 否则，对匹配项进行映射，使用 trimAccolades 函数去除匹配项中的花括号，并返回一个包含变量名称的数组。",
    "summary_french": "La fonction getPathVarMatches prend un fragment de chemin en entrée. Elle recherche les occurrences de variables entre accolades ({}) dans le fragment de chemin. Si des variables sont trouvées, elles sont extraites et retournées sous forme d'un tableau. Si aucune variable n'est trouvée, un tableau vide est retourné. \n\n\nLe type d'argument pathPiece est une chaîne de caractères. La fonction retourne un tableau de chaînes de caractères.",
    "summary_spanish": "La función getPathVarMatches toma un fragmento de ruta como argumento. Busca patrones en el fragmento que coincidan con llaves y letras minúsculas entre ellas. Si encuentra coincidencias, las extrae y devuelve un array con las letras minúsculas entre llaves, eliminando las llaves. Si no encuentra coincidencias, devuelve un array vacío. \n\n\npathPiece (string) \narray de strings",
    "summary_portuguese": "A função getPathVarMatches recebe um pedaço de caminho como argumento. Ela procura por padrões de variáveis dentro do caminho, que são delimitadas por chaves '{ }'.  Se encontrar padrões, a função os extrai e retorna uma lista com os nomes das variáveis, removendo as chaves. Caso não encontre padrões, retorna uma lista vazia.",
    "summary_arabic": "function getPathVarMatches takes a string pathPiece as input. It searches for variable placeholders enclosed in curly braces within the pathPiece using a regular expression. If placeholders are found, it extracts them, removes any surrounding characters, and returns an array of these extracted variable names. If no placeholders are found, it returns an empty array.",
    "summary_hindi": "getPathVarMatches नामक फ़ंक्शन एक पथ के टुकड़े से परिवर्तनीय चर मिलान करता है। यह पथ के टुकड़े में \"{variable_name}\" प्रारूप में परिवर्तनीय चर खोजता है और उन्हें एक सरणी में वापस करता है।  \n\nयह फ़ंक्शन \"pathPiece\" नामक एक स्ट्रिंग मान लेता है। \n\nयह फ़ंक्शन एक रेगुलेर एक्सप्रेशन का उपयोग करके पथ के टुकड़े में \"{variable_name}\" प्रारूप में परिवर्तनीय चर खोजता है। यदि कोई मिलान नहीं होता है, तो यह एक खाली सरणी वापस करता है। अन्यथा, यह मिलानों को एक नई सरणी में परिवर्तित करता है जिसमें प्रत्येक तत्व \"{variable_name}\" प्रारूप से \"variable_name\" भाग है।"
  },
  {
    "id": "sample_52604",
    "language": "javascript",
    "length_bucket": "short",
    "code": "function toParameter(val, key) {\n    var str = '--' + key.replace(/([A-Z])/g, function(a) {\n      return '-' +  a.toLowerCase();\n    });\n\n    return (val === true) ? [str] : [str, val];\n  }",
    "docstring": "Convert a pair of key/value to an array if the value is `true` only the key is kept  Example:  toParameter('lineBreak', 2) // => ['--line-break', 2]  toParameter('preserveComments', true) // => ['--preserve-comments']",
    "model_name": "gemma-2-9b-it",
    "summary_english": "toParameter converts a value and a key into a parameter string suitable for use in a URL query. It takes a boolean value and a string key as arguments. If the value is true, it returns a list containing only the formatted key. If the value is not true, it returns a list containing the formatted key and the value. The key is formatted by replacing uppercase letters with hyphens and lowercase letters.",
    "summary_chinese": "toParameter 函数用于将值和键转换为参数字符串。 \n\n参数：\n\nval: 值，可以是布尔值或其他类型\n\nkey: 键，字符串类型\n\n逻辑：\n\n1. 将键转换为符合 URL 参数格式的字符串，将大写字母转换为小写并添加“-”分隔符。\n2. 如果值是 true，则返回一个包含转换后的键的数组。\n3. 否则，返回一个包含转换后的键和值的数组。",
    "summary_french": "La fonction `toParameter` transforme une valeur et une clé en une ou deux paramètres utilisables dans une requête. Elle prend en argument `val` de type boolean ou autre et `key` de type string. Elle remplace les majuscules de la clé par des tirets et des minuscules, puis retourne une liste contenant la clé transformée et, si `val` est vrai, la valeur elle-même.",
    "summary_spanish": "La función toParameter convierte un valor y una clave en una representación adecuada para un parámetro de URL. Recibe un valor (val) de cualquier tipo y una clave (key) de tipo cadena.  Si el valor es verdadero, devuelve una lista con la clave formateada. Si el valor es diferente de verdadero, devuelve una lista con la clave formateada y el valor. La clave se formatea reemplazando cada letra mayúscula por un guión y una letra minúscula.",
    "summary_portuguese": "A função toParameter transforma um valor e uma chave em uma string apropriada para um parâmetro de URL. Ela recebe um valor (qualquer tipo) e uma chave (string) como argumentos. A chave é convertida para um formato de URL, substituindo letras maiúsculas por hífens e letras minúsculas. Se o valor for verdadeiro, retorna uma lista com apenas a chave formatada. Caso contrário, retorna uma lista com a chave formatada e o valor.",
    "summary_arabic": "function toParameter  تحول قيمة إلى معلمة. \n\narguments: \nval  قيمة من أي نوع.\nkey  اسم المعلمة نص.\n\nlogic: \n1. تحويل اسم المعلمة إلى تنسيق  '--key-name'  \n2. إذا كانت القيمة  true  ، يتم إرجاع اسم المعلمة فقط.\n3. وإلا يتم إرجاع اسم المعلمة والقيمة.",
    "summary_hindi": "toParameter नामक यह फ़ंक्शन किसी मान और कुंजी को एक विशेष प्रारूप में परिवर्तित करता है। यह दो मान लेता है: val जो किसी मान का प्रतिनिधित्व करता है और key जो एक स्ट्रिंग है। यह कुंजी को '-' से अलग किए गए छोटे अक्षरों में बदलता है और मान के आधार पर एक या दो तत्वों वाले एक एरे लौटाता है। यदि मान true है तो केवल कुंजी का परिवर्तित रूप लौटाया जाता है, अन्यथा कुंजी और मान दोनों लौटाए जाते हैं।"
  },
  {
    "id": "sample_54032",
    "language": "javascript",
    "length_bucket": "short",
    "code": "function strip_argv (a) {\n\tlet o = {};\n\treturn Object.keys(a).filter(k => k !== '_').map(k => {\n\t\to[k] = a[k];\n\t});\n}",
    "docstring": "Strip argv\n\n@param a\n@returns {any[]}",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function strip_argv takes an object as input. It creates a new empty object and filters the keys of the input object, excluding any keys that are equal to '_'. It then maps each remaining key to its corresponding value in the new object and returns the new object.",
    "summary_chinese": "strip_argv 函数用于从一个对象中移除名为 '_ ' 的属性，并返回一个新的对象，包含剩余的属性和值。 \n\n参数：\n\na: 一个对象\n\n逻辑：\n\n1. 创建一个空对象 o。\n2. 使用 Object.keys(a) 获取对象 a 中的所有属性名。\n3. 使用 filter 方法过滤掉名为 '_ ' 的属性。\n4. 使用 map 方法遍历剩余的属性名，并将它们和对应的值添加到新对象 o 中。\n5. 返回新对象 o。",
    "summary_french": "La fonction strip_argv prend un objet a en argument. Elle crée un nouvel objet o et filtre les clés de l'objet a en excluant la clé '_'. Ensuite, elle map les clés restantes sur l'objet o en conservant les valeurs correspondantes. La fonction retourne l'objet o contenant les clés et valeurs de l'objet a sans la clé '_'. \n\nArgument:\na: objet \n\nRetourne:\nobjet",
    "summary_spanish": "La función strip_argv toma un objeto como argumento 'a'.  Crea un nuevo objeto vacío 'o'. Filtra las claves del objeto 'a' excluyendo la clave '_'.  Para cada clave filtrada, asigna el valor correspondiente del objeto 'a' al nuevo objeto 'o'. Finalmente, devuelve el nuevo objeto 'o'.",
    "summary_portuguese": "A função strip_argv recebe um objeto a como argumento. Ela cria um novo objeto vazio o e filtra as chaves do objeto a, excluindo a chave '_'.  Em seguida, a função mapeia cada chave filtrada e atribui o valor correspondente do objeto a ao novo objeto o. Finalmente, a função retorna o novo objeto o.",
    "summary_arabic": "function strip_argv  تُزيل أي عنصر بعلامة _ من أرشيف المتغيرات.",
    "summary_hindi": "strip_argv नामक यह फ़ंक्शन एक ऑब्जेक्ट में दिए गए आर्गुमेंट्स को साफ़ करता है। यह फ़ंक्शन एक ऑब्जेक्ट `a` को लेता है और उसमें '_ ' की कुंजी वाले सभी एंट्री को हटाकर एक नया ऑब्जेक्ट बनाता है।"
  },
  {
    "id": "sample_50286",
    "language": "javascript",
    "length_bucket": "short",
    "code": "function iteratorToArray(iterator) {\n  const values = [];\n  let item = iterator.next();\n  while (!item.done) {\n    values.push(item.value);\n    item = iterator.next();\n  }\n  return values;\n}",
    "docstring": "Convert the iterator values into an array\n@param iterator\n@returns {Array}",
    "model_name": "gemma-2-9b-it",
    "summary_english": "iteratorToArray converts an iterator into an array. It takes an iterator as input. It initializes an empty array called values. It then repeatedly calls the iterator's next method, pushing the returned value into the values array until the iterator is exhausted (done is true). Finally, it returns the values array.",
    "summary_chinese": "iteratorToArray 函数将迭代器转换为数组。 \n\n参数：iterator (迭代器)\n\n逻辑：创建一个空数组 values。使用循环迭代器，直到迭代器结束。在每次迭代中，将当前项的值添加到 values 数组中，并获取下一个项。最后返回 values 数组。",
    "summary_french": "La fonction `iteratorToArray` convertit un itérateur en un tableau. Elle prend un itérateur en argument et retourne un tableau contenant toutes les valeurs de l'itérateur. La fonction utilise une boucle `while` pour parcourir l'itérateur jusqu'à ce que la méthode `next` renvoie `done` à `true`. Dans chaque itération, la valeur actuelle est ajoutée au tableau `values`.",
    "summary_spanish": "La función iteratorToArray convierte un iterador en un array. Recibe un iterador como argumento.  En un bucle, obtiene el siguiente elemento del iterador hasta que se alcanza el final.  Añade cada valor obtenido al array values. Finalmente, devuelve el array values que contiene todos los elementos del iterador.",
    "summary_portuguese": "A função iteratorToArray converte um objeto iterator em um array. Ela recebe um argumento iterator de qualquer tipo e retorna um array contendo os valores iterados pelo iterator. A função itera sobre o iterator até que o método next() retorne done como true, adicionando cada valor encontrado ao array values.  Finalmente, a função retorna o array values.",
    "summary_arabic": "function iteratorToArray يحول محول إلى جملة. يتقبل محول واحد من نوع iterator.  \n\nيُنشئ دالة iteratorToArray  جملة فارغة تسمى values. ثم، يقوم بتحريك المحول إلى العنصر التالي باستخدام iterator.next() وتخزين النتيجة في المتغير item. \n\nفي حلقة while التي تستمر طالما أن item.done غير صحيح، يتم إضافة قيمة العنصر (item.value) إلى الجملة values، ثم يتم تحريك المحول إلى العنصر التالي. \n\nفي النهاية، يتم إرجاع الجملة values.",
    "summary_hindi": "iteratorToArray नामक यह फ़ंक्शन एक इटरेटर से एक एरे में सभी मानों को परिवर्तित करता है। यह एक इटरेटर argument लेता है जो एक iterable object का प्रतिनिधित्व करता है। यह इटरेटर के माध्यम से चक्रित होता है, प्रत्येक मान को values एरे में जोड़ता है जब तक कि इटरेटर पूरा न हो जाए। अंत में, यह values एरे को वापस करता है।"
  },
  {
    "id": "sample_52851",
    "language": "javascript",
    "length_bucket": "short",
    "code": "function activateSender(callback, senderEmail, code){\n    if ((senderEmail===undefined)||(!senderEmail.length)||(code===undefined)||(!code.length)){\n        return callback(returnError('Empty email or activation code'));\n    }\n    var data = {\n        code: code\n    }\n    sendRequest( 'senders/' + senderEmail + '/code', 'POST', data, true, callback );\n}",
    "docstring": "Activate sender using code\n\n@param callback\n@param senderEmail\n@param code",
    "model_name": "gemma-2-9b-it",
    "summary_english": "activateSender is a function that activates a sender email address using a provided activation code. It takes three arguments: callback, senderEmail, and code. The callback is a function that handles the response. senderEmail is a string representing the email address to activate. code is a string representing the activation code. The function first checks if senderEmail and code are provided and not empty. If either is missing or empty, it returns an error to the callback. Otherwise, it constructs a data object with the activation code and sends a POST request to the server to activate the sender email address. The callback function is called with the server's response.",
    "summary_chinese": "activateSender 函数用于激活发送者。它接受三个参数：callback（回调函数）、senderEmail（发送者邮箱地址）和 code（激活码）。 首先，它检查 senderEmail 和 code 是否为空。如果为空，则返回一个错误信息。否则，它将 code 存储在 data 对象中，并使用 sendRequest 函数向服务器发送 POST 请求，请求激活发送者。",
    "summary_french": "La fonction activateSender active un expéditeur. Elle prend en arguments callback, senderEmail (string) et code (string). Elle vérifie si senderEmail et code sont définis et non vides. Si ce n'est pas le cas, elle retourne une erreur. Sinon, elle construit un objet data avec le code et appelle la fonction sendRequest pour envoyer une requête POST à l'URL correspondante avec les données et un callback.",
    "summary_spanish": "La función activateSender activa un remitente. Recibe como argumentos callback, senderEmail (string) y code (string). Si senderEmail o code están vacíos, devuelve un error. De lo contrario, crea un objeto data con el código y llama a sendRequest para enviar una petición POST a la URL correspondiente con los datos y un flag de autenticación.",
    "summary_portuguese": "A função activateSender ativa um remetente. Ela recebe como argumentos callback, senderEmail (string) e code (string). Se senderEmail ou code estiverem vazios, a função retorna um erro. Caso contrário, cria um objeto data com o código de ativação e chama a função sendRequest para enviar uma requisição POST para o endpoint correspondente ao remetente, com o objeto data. A função callback é chamada com o resultado da requisição.",
    "summary_arabic": "function activateSender  تفعيل مرسل.  \nيُستخدم هذا الدالة لتفعيل مرسل بريد إلكتروني باستخدام كود التفعيل. \narguments: callback function, senderEmail string, code string. \nlogic: \n1. التحقق من وجود عنوان البريد الإلكتروني وكود التفعيل.\n2. إنشاء بيانات مع كود التفعيل.\n3. إرسال طلب POST إلى API مع بيانات التفعيل. \n4. استدعاء callback مع نتيجة العملية.",
    "summary_hindi": "activateSender नामक फ़ंक्शन एक ईमेल संदेश भेजने वाले को सक्रिय करने के लिए डिज़ाइन किया गया है। यह callback, senderEmail और code नामक तीन मानों को लेता है। callback एक फ़ंक्शन है जो संदेश भेजने के परिणाम के बारे में जानकारी वापस करेगा। senderEmail एक स्ट्रिंग है जो संदेश भेजने वाले के ईमेल पते को दर्शाता है। code एक स्ट्रिंग है जो एक सक्रियण कोड है। \n\nयदि senderEmail या code खाली हैं, तो फ़ंक्शन एक त्रुटि संदेश वापस करेगा। अन्यथा, यह एक POST अनुरोध भेजता है जो senderEmail और code का उपयोग करके एक सर्वर एंडपॉइंट को संबोधित करता है।"
  },
  {
    "id": "sample_51203",
    "language": "javascript",
    "length_bucket": "short",
    "code": "function(enumObj, val) {\n        for (var key of Object.keys(enumObj)) {\n            if (enumObj[key] === val) {\n                return key.split('_')\n                    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n                    .join(' ');\n            }\n        }\n        return null;\n    }",
    "docstring": "Utility method that finds the name of the key for a given enum value and makes it\nlook a little nicer.\n@param {object} enumObj\n@param {number} val\n@returns {string}\n@static",
    "model_name": "gemma-2-9b-it",
    "summary_english": "This function takes an enumeration object and a value as input. It iterates through the keys of the enumeration object. If a key's value matches the input value, it converts the key into a human-readable string by capitalizing the first letter of each word and joining them with spaces. If no match is found, it returns null. \n\n\nThe arguments are:\n\nenumObj: an object representing an enumeration\nval: the value to search for in the enumeration",
    "summary_chinese": "这个函数名为 `function`，它接受一个枚举对象 `enumObj` 和一个值 `val` 作为参数。它的目的是根据给定的值在枚举对象中查找对应的键，并将键转换为驼峰命名法字符串。函数首先遍历枚举对象的键，然后检查每个键对应的值是否等于输入的值。如果找到匹配的值，则将键拆分成单词，每个单词的首字母大写，其余字母小写，最后将单词连接成一个空格分隔的字符串并返回。如果没有找到匹配的值，则返回 `null`。",
    "summary_french": "Cette fonction nommée `enumObj` prend en entrée un objet `enumObj` et une valeur `val`. Elle parcourt les clés de l'objet `enumObj`. Si la valeur associée à une clé est égale à `val`, la fonction retourne la clé transformée en une chaîne de caractères avec les premières lettres de chaque mot en majuscule et les autres en minuscule. Sinon, elle retourne `null`.",
    "summary_spanish": "La función recibe un objeto enumerado (enumObj) y un valor (val). Recorre las claves del objeto enumerado. Si encuentra una clave cuyo valor coincida con el valor proporcionado, devuelve la clave formateada con las primeras letras de cada palabra en mayúscula y el resto en minúscula. Si no encuentra una coincidencia, devuelve null.",
    "summary_portuguese": "A função recebe um objeto enumerado e um valor. Ela itera sobre as chaves do objeto enumerado e verifica se o valor correspondente é igual ao valor fornecido. Se encontrar uma correspondência, a função retorna a chave formatada com as primeiras letras de cada palavra em maiúscula e as demais em minúscula. Caso contrário, retorna null.",
    "summary_arabic": "هذه الدالة تسمى  \"enumObj\" و \"val\"  وتقوم بتحويل قيمة من  enum  إلى نص.  \n\nتستقبل الدالة  \"enumObj\"  وهو  object  يحتوي على  enum  و \"val\"  وهي القيمة التي تريد تحويلها. \n\nتدور دورة على كل مفتاح في  enumObj  و تقوم بمقارنته مع  val. إذا وجدت تطابق، تقوم بتحويل المفتاح إلى نص باستخدام  split  و  map  و  join  . وإلا، تقوم بإرجاع null.",
    "summary_hindi": "यह फ़ंक्शन एक एन्यूमरेटेड ऑब्जेक्ट और एक मान लेता है। यह ऑब्जेक्ट में दिए गए मान के लिए संबंधित की-वैल्यू जोड़ी खोजता है। यदि मिलता है, तो यह की को स्प्लिट करता है, प्रत्येक शब्द का पहला अक्षर बड़ा करता है और बाकी छोटा करता है, और सभी शब्दों को एक स्पेस से जोड़कर मान वापस करता है। यदि मान नहीं मिलता है, तो यह null वापस करता है।"
  },
  {
    "id": "sample_52637",
    "language": "javascript",
    "length_bucket": "short",
    "code": "function handleError (err, cb) {\n  if (err) {\n    if (cb) {\n      return process.nextTick(function(){\n        cb(err);\n      });\n    }\n    console.error(err);\n  }\n}",
    "docstring": "Error reporting helper",
    "model_name": "gemma-2-9b-it",
    "summary_english": "handleError is a function that handles errors. It takes two arguments: err, which is an error object, and cb, which is a callback function. If an error is provided, it checks if a callback function is provided. If so, it schedules the callback function to be executed in the next tick of the event loop, passing the error object as an argument. If no callback function is provided, it logs the error to the console.",
    "summary_chinese": "handleError 函数用于处理错误。它接受两个参数：err（错误对象）和 cb（回调函数）。如果 err 不为空，则调用 cb 回调函数并传递错误对象，如果 cb 为空，则将错误信息输出到控制台。",
    "summary_french": "La fonction handleError gère les erreurs. Elle prend deux arguments : err, qui représente l'erreur, et cb, une fonction de rappel optionnelle. Si une erreur est détectée, la fonction vérifie si une fonction de rappel est fournie. Si oui, elle utilise process.nextTick pour exécuter la fonction de rappel avec l'erreur en argument. Sinon, elle affiche l'erreur dans la console.",
    "summary_spanish": "La función handleError maneja errores. Recibe dos argumentos: err, que es el objeto de error, y cb, que es una función de devolución de llamada opcional. Si hay un error (err es verdadero), si se proporciona una función de devolución de llamada (cb), se programa la ejecución de la función de devolución de llamada con el error usando process.nextTick. Si no se proporciona una función de devolución de llamada, se imprime el error en la consola.",
    "summary_portuguese": "A função handleError trata de erros. Ela recebe um argumento err do tipo objeto de erro e um argumento cb do tipo função. Se err for verdadeiro, e cb existir, a função chama cb com o erro como argumento no próximo ciclo de eventos. Caso contrário, a função imprime o erro no console.",
    "summary_arabic": "function handleError  تُستخدم لمعالجة الأخطاء. \narguments: err (خطأ) , cb (دالة callback اختيارية)\nlogic: إذا وجد خطأ، فإذا كانت دالة callback مُحددة، يتم تنفيذها في وقت لاحق مع الخطأ. وإلا، يتم طباعة الخطأ في سجل الخطأ.",
    "summary_hindi": "handleError नामक फ़ंक्शन एक त्रुटि को संभालने के लिए डिज़ाइन किया गया है। यह दो मानों को लेता है: err जो त्रुटि ऑब्जेक्ट है और cb जो एक कॉलबैक फ़ंक्शन है। यदि त्रुटि मौजूद है, तो यह cb कॉलबैक फ़ंक्शन को त्रुटि के साथ कॉल करता है। यदि cb कॉलबैक फ़ंक्शन उपलब्ध नहीं है, तो त्रुटि को कंसोल में प्रदर्शित करता है।"
  },
  {
    "id": "sample_54575",
    "language": "javascript",
    "length_bucket": "short",
    "code": "function unique(array) {\n\t\tvar ret = [];\n\t\t\n\t\teach(array, function (_a) {\n\t\t\tif (!find(ret, _a)) { ret.push(_a); }\n\t\t});\n\t\t\n\t\treturn ret;\n\t}",
    "docstring": "unique",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function unique takes an array as input and returns a new array containing only the unique elements from the input array. It iterates through each element in the input array and checks if the element already exists in the output array. If the element is not found in the output array, it is added to the output array. \n\n\narguments: array (array)",
    "summary_chinese": "该函数名为 unique，用于从一个数组中去除重复元素，返回一个包含唯一元素的新数组。 \n\n参数：\n\narray: 一个数组\n\n逻辑：\n\n1. 创建一个空数组 ret。\n2. 遍历输入数组 array，对于每个元素 _a，如果 _a 不在 ret 数组中，则将其添加到 ret 数组中。\n3. 返回包含唯一元素的数组 ret。",
    "summary_french": "La fonction unique prend un tableau en entrée. Elle parcourt chaque élément du tableau et vérifie s'il est déjà présent dans un tableau de retour. Si l'élément n'est pas déjà présent, il est ajouté au tableau de retour. La fonction retourne le tableau de retour contenant uniquement les éléments uniques du tableau d'entrée.",
    "summary_spanish": "La función unique toma un array como argumento. Recorre cada elemento del array y si el elemento no se encuentra en un array auxiliar llamado ret, lo agrega a ret. Finalmente, devuelve el array ret que contiene solo los elementos únicos del array original. \n\n\nEl argumento de la función es array de cualquier tipo.",
    "summary_portuguese": "A função unique recebe um array como argumento e retorna um novo array contendo apenas os elementos únicos do array original. Ela itera sobre cada elemento do array original e verifica se o elemento já existe no novo array. Se o elemento não existir, ele é adicionado ao novo array. \n\n\narray (array)",
    "summary_arabic": "function unique يأخذ مصفوفة كمدخل ويقوم بإرجاع مصفوفة جديدة تحتوي على عناصر المصفوفة الأصلية الفريدة فقط.  \n\nيحتوي على مدخل واحد:\n\narray من نوع مصفوفة\n\nالوظيفة تقوم بفحص كل عنصر في المصفوفة الأصلية. إذا لم يتم العثور على العنصر بالفعل في المصفوفة الناتجة، يتم إضافته إلى المصفوفة الناتجة.",
    "summary_hindi": "यह फ़ंक्शन 'unique' नाम का है और इसका उद्देश्य एक दिए गए एरे से दोहराए गए तत्वों को हटाकर अद्वितीय तत्वों का एक नया एरे वापस करना है। यह एक एरे 'array' लेता है। यह एरे के प्रत्येक तत्व को चेक करता है और यदि यह पहले से ही नए एरे में मौजूद नहीं है, तो इसे नए एरे में जोड़ता है। अंत में, यह नए एरे को वापस करता है।"
  },
  {
    "id": "sample_51274",
    "language": "javascript",
    "length_bucket": "short",
    "code": "function(key, value) {\n    var keys = this.keys,\n        values = this.values,\n        guid = guidFor(key);\n\n    keys.add(key);\n    values[guid] = value;\n    set(this, 'length', keys.list.length);\n  }",
    "docstring": "Adds a value to the map. If a value for the given key has already been\nprovided, the new value will replace the old value.\n\n@method set\n@param {*} key\n@param {*} value",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function adds a key-value pair to an object. It takes two arguments: key, a string representing the key, and value, the value associated with the key. It first retrieves the existing keys and values arrays from the object. Then, it generates a unique identifier (guid) for the key using the guidFor function. It adds the key to the keys array and stores the value in the values array using the guid as the index. Finally, it updates the object's length property to reflect the new number of key-value pairs.",
    "summary_chinese": "该函数名为 `function(key, value)`，用于将键值对添加到一个对象中。它接受两个参数：`key` (字符串) 和 `value` (任意类型)。函数首先获取对象中的 `keys` 和 `values` 属性，然后使用 `guidFor(key)` 生成一个唯一的标识符 `guid`。接着，将 `key` 添加到 `keys` 集合中，并将 `value` 存储到 `values` 对象中，键为 `guid`。最后，更新对象 `length` 属性为 `keys` 集合的长度。",
    "summary_french": "La fonction ajoute une clé-valeur à un objet. Elle prend deux arguments : `key` de type chaîne représentant la clé et `value` de type quelconque représentant la valeur.  Elle ajoute la clé à un ensemble de clés internes et associe la valeur à la clé en utilisant un identifiant unique (guid). La longueur de l'objet est ensuite mise à jour.",
    "summary_spanish": "La función agrega una nueva clave-valor a un objeto. Recibe dos argumentos: 'key' de tipo cadena y 'value' de cualquier tipo.  Primero, obtiene las colecciones de claves y valores del objeto actual. Luego, genera un identificador único (guid) para la clave. Agrega la clave a la colección de claves y asigna el valor al guid en la colección de valores. Finalmente, actualiza la longitud del objeto.",
    "summary_portuguese": "A função adiciona um novo par chave-valor a um objeto. Ela recebe como argumentos `key` (string) e `value` (qualquer tipo). A função primeiro obtém as coleções de chaves e valores do objeto, e gera um identificador único (guid) para a chave. Em seguida, adiciona a chave à coleção de chaves e associa o valor ao guid na coleção de valores. Por fim, atualiza o comprimento do objeto com o número de chaves adicionadas.",
    "summary_arabic": "تسمى هذه الدالة  وتهدف إلى إضافة عنصر جديد إلى خزانة البيانات.  تقبل الدالة  \"key\" من نوع string و \"value\" من نوع أي نوع.  تُضاف المفتاح إلى مجموعة \"keys\"  و يتم تخزين القيمة في \"values\" باستخدام GUID للمفتاح. يتم تحديث طول الخزانة.",
    "summary_hindi": "यह फ़ंक्शन एक ऑब्जेक्ट में एक नया कुंजी-मूल्य जोड़ता है। यह दो मान लेता है: 'key' जो स्ट्रिंग प्रकार का होता है और 'value' जो किसी भी प्रकार का हो सकता है। यह फ़ंक्शन पहले 'keys' और 'values'  संग्रहों को प्राप्त करता है और फिर 'key' के लिए एक अद्वितीय पहचानकर्ता (guid) उत्पन्न करता है।  इसके बाद, यह 'key' को 'keys' संग्रह में जोड़ता है, 'guid' का उपयोग करके 'values' संग्रह में 'value' को संग्रहीत करता है और अंत में ऑब्जेक्ट की लंबाई को अपडेट करता है।"
  },
  {
    "id": "sample_54120",
    "language": "javascript",
    "length_bucket": "short",
    "code": "function scopeUrl(options, inst) {\n    options = _.extend({}, inst, options)\n    if (!options.season_id)\n      throw new Error('season_id required to make division instance api calls')\n\n    return ngin.Season.urlRoot() + '/' + options.season_id + Division.urlRoot()\n  }",
    "docstring": "Scopes the url to the season\n\n@param {Object} options\n@returns {String}\n@api public",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `scopeUrl` constructs a URL for accessing division instance API calls. It takes two arguments: `options` (an object containing options for the API call) and `inst` (an object representing an instance). The function first merges the `options` object with the `inst` object using _.extend. It then checks if the `season_id` property is present in the `options` object. If not, it throws an error. Finally, it constructs the URL by concatenating the season root URL, the `season_id`, and the division root URL.",
    "summary_chinese": "scopeUrl 函数用于生成根据给定选项构建的赛季和分区实例 API 的 URL。 \n\n它接受两个参数：options 和 inst。options 是一个对象，包含用于构建 URL 的选项，inst 是一个对象，包含默认的实例信息。\n\n函数首先使用 _.extend 方法将 inst 合并到 options 中，然后检查 options 是否包含 season_id 属性，如果没有则抛出错误。最后，函数返回 ngin.Season.urlRoot() 加上 season_id 和 Division.urlRoot() 构成的 URL。",
    "summary_french": "La fonction `scopeUrl` combine les informations de saison et de division pour construire une URL. Elle prend deux arguments : `options` un objet contenant des options et `inst` une instance. Elle étend l'objet `options` avec les propriétés de `inst`. Si l'option `season_id` est manquante, elle lance une erreur. La fonction retourne l'URL racine de la saison concaténée avec l'ID de la saison et l'URL racine de la division.",
    "summary_spanish": "La función scopeUrl toma dos argumentos: options y inst.  Combina los valores de inst y options usando _.extend.  Verifica si el argumento options contiene season_id. Si no lo hace, lanza un error.  Finalmente, construye una URL utilizando ngin.Season.urlRoot(), el valor de season_id y Division.urlRoot().",
    "summary_portuguese": "A função `scopeUrl` combina informações de opções e uma instância para construir uma URL para chamadas de API de instâncias de divisão. Ela recebe dois argumentos: `options`, um objeto com opções, e `inst`, uma instância. A função primeiro combina as opções com a instância usando `_.extend`. Em seguida, verifica se o argumento `season_id` está presente nas opções. Se não estiver, lança um erro. Por fim, retorna a URL completa, construída concatenando a raiz da URL da temporada (`ngin.Season.urlRoot()`), o `season_id` e a raiz da URL da divisão (`Division.urlRoot()`).",
    "summary_arabic": "function scopeUrl  تحديد عنوان URL لمجموعة  Division  باستخدام خيارات و  instance.  يتلقى  function  خيارين:  options  و  inst.  يُدمج  options  مع  inst  ثم  يُتحقق  من وجود  season_id  في  options.  إذا لم يكن موجودًا، يتم إلقاء خطأ.  في النهاية، يتم إرجاع عنوان URL  المكون من  urlRoot  لـ  Season  و  season_id  و  urlRoot  لـ  Division.",
    "summary_hindi": "यह फ़ंक्शन `scopeUrl` नामक है और इसका उद्देश्य एक URL बनाना है जो एक विशेष सीज़न और डिवीजन के लिए उपयोग किया जाता है। यह दो मान लेता है: `options` जो एक ऑब्जेक्ट है जिसमें सीज़न आईडी और अन्य विकल्प शामिल हो सकते हैं, और `inst` जो एक इंस्टेंस है। यह फ़ंक्शन `options` ऑब्जेक्ट को `inst` ऑब्जेक्ट के साथ मिलाता है और यदि `season_id` नहीं दिया गया है तो एक त्रुटि उत्पन्न करता है। अंत में, यह `ngin.Season.urlRoot()` और `Division.urlRoot()` का उपयोग करके एक पूर्ण URL बनाता है।"
  },
  {
    "id": "sample_50136",
    "language": "javascript",
    "length_bucket": "short",
    "code": "function fixTokenKind(tokenInfo, container) {\n                if (ts.isToken(container) && tokenInfo.token.kind !== container.kind) {\n                    tokenInfo.token.kind = container.kind;\n                }\n                return tokenInfo;\n            }",
    "docstring": "when containing node in the tree is token but its kind differs from the kind that was returned by the scanner, then kind needs to be fixed. This might happen in cases when parser interprets token differently, i.e keyword treated as identifier",
    "model_name": "gemma-2-9b-it",
    "summary_english": "fixTokenKind is a function that adjusts the token kind of a token within a container. It takes two arguments: tokenInfo, which is an object containing a token, and container, which is a token or a container for tokens. The function checks if the container is a token and if the token's kind differs from the container's kind. If both conditions are true, it updates the token's kind to match the container's kind. Finally, it returns the modified tokenInfo object.",
    "summary_chinese": "fixTokenKind 函数用于修复 token 的类型。它接受两个参数：tokenInfo 和 container。tokenInfo 是一个包含 token 信息的对象，container 是一个 token 或 token 的容器。如果 container 是一个 token 并且 tokenInfo 中的 token 的类型与 container 的类型不一致，则将 tokenInfo 中的 token 的类型设置为 container 的类型。最后，函数返回修改后的 tokenInfo 对象。",
    "summary_french": "La fonction `fixTokenKind` ajuste le type de token d'un objet `tokenInfo` en fonction du type de token d'un objet `container`. Elle prend en argument `tokenInfo`, un objet contenant des informations sur un token, et `container`, un objet qui représente un conteneur de token. Si `container` est un token et que le type de token de `tokenInfo` est différent du type de token de `container`, alors le type de token de `tokenInfo` est mis à jour pour correspondre au type de token de `container`. La fonction retourne l'objet `tokenInfo` modifié.",
    "summary_spanish": "La función fixTokenKind ajusta el tipo de token de un objeto tokenInfo a coincidir con el tipo de un contenedor dado. Recibe dos argumentos: tokenInfo, que es un objeto con información sobre un token, y container, que es un objeto que representa un contenedor de tokens. Si el contenedor es un token y el tipo de token en tokenInfo no coincide con el tipo del contenedor, se actualiza el tipo de token en tokenInfo. Finalmente, la función devuelve el objeto tokenInfo modificado.",
    "summary_portuguese": "A função fixTokenKind recebe dois argumentos: tokenInfo e container. O propósito da função é corrigir o tipo de token em tokenInfo se ele for diferente do tipo de token em container. Se container for um token e o tipo de token em tokenInfo for diferente do tipo de token em container, o tipo de token em tokenInfo é atualizado para o tipo de token em container. A função então retorna tokenInfo.",
    "summary_arabic": "دالة fixTokenKind تقوم بتعديل نوع token في tokenInfo لتتطابق مع نوع container. \n\nتستقبل الدالة due arguments:\n\ntokenInfo: يحتوي على معلومات عن token.\ncontainer: يحتوي على معلومات عن container.\n\nإذا كان container هو token و نوع tokenInfo.token مختلف عن نوع container، يتم تعديل نوع tokenInfo.token ليصبح مساويًا لـ container. \n\n\nثم يتم إرجاع tokenInfo المعدل.",
    "summary_hindi": "fixTokenKind नामक फ़ंक्शन टोकन जानकारी और कंटेनर को इनपुट लेता है। यह जाँच करता है कि कंटेनर एक टोकन है और टोकन जानकारी का टोकन प्रकार कंटेनर के प्रकार से मेल खाता है या नहीं। यदि नहीं, तो टोकन जानकारी के टोकन का प्रकार कंटेनर के प्रकार में बदल दिया जाता है। अंत में, फ़ंक्शन टोकन जानकारी वापस करता है।"
  },
  {
    "id": "sample_51759",
    "language": "javascript",
    "length_bucket": "short",
    "code": "function d3_behavior_zoomTouchup() {\n  var touches = d3.svg.touches(d3_behavior_zoomTarget),\n      i = -1,\n      n = touches.length,\n      touch;\n  while (++i < n) d3_behavior_zoomLocations[(touch = touches[i]).identifier] = d3_behavior_zoomLocation(touch);\n  return touches;\n}",
    "docstring": "Note: Since we don't rotate, it's possible for the touches to become slightly detached from their original positions. Thus, we recompute the touch points on touchend as well as touchstart!",
    "model_name": "gemma-2-9b-it",
    "summary_english": "d3_behavior_zoomTouchup is a function that handles touch events for zooming behavior in a D3 visualization. It takes no arguments. The function retrieves the active touches from the zoom target, iterates through each touch, and stores its location in a map using the touch identifier as the key. Finally, it returns the array of active touches.",
    "summary_chinese": "d3_behavior_zoomTouchup 函数用于处理触摸事件的结束状态。它接受一个参数：d3_behavior_zoomTarget，代表目标 SVG 元素。函数首先获取目标元素上的所有触摸点，然后将每个触摸点的标识符和位置信息存储到 d3_behavior_zoomLocations 对象中。最后，函数返回所有触摸点。",
    "summary_french": "La fonction d3_behavior_zoomTouchup récupère les touches en cours sur un élément SVG cible. Elle parcourt chaque touche, stocke son identifiant et sa position dans un objet d'emplacement. La fonction retourne ensuite les touches détectées.",
    "summary_spanish": "La función d3_behavior_zoomTouchup procesa las coordenadas de los toques en un elemento SVG. Recibe como argumento el elemento SVG al que se aplican los toques.  Asigna las coordenadas de cada toque a un objeto d3_behavior_zoomLocations, utilizando el identificador del toque como clave. Finalmente, devuelve un array con los objetos de toque.",
    "summary_portuguese": "A função d3_behavior_zoomTouchup identifica e armazena as coordenadas de toque em um elemento SVG. Ela recebe como argumento o elemento SVG alvo e retorna um array de objetos de toque. A função itera sobre os objetos de toque, obtendo o identificador e a localização de cada toque, e armazena essas informações em um objeto.",
    "summary_arabic": "دالة d3_behavior_zoomTouchup تقوم بتحديث مواقع لمسات المستخدم على عنصر SVG.  تقوم الدالة بتحليل لمسات المستخدم المتاحة على عنصر d3_behavior_zoomTarget وتخزن مواقعها في محفظة d3_behavior_zoomLocations.  \n\nالدالة تتقبل  دالة واحدة:\n\n* touches:  مجموعة من لمسات المستخدم على عنصر SVG.\n\nالدالة تقوم بتكرار كل لمسة في مجموعة touches وتخزن موقعها في محفظة d3_behavior_zoomLocations باستخدام مفتاح هو معرف لمسة المستخدم.",
    "summary_hindi": "d3_behavior_zoomTouchup नामक फ़ंक्शन टच इवेंट के दौरान ज़ूम व्यवहार के लिए ज़ूम लोकेशन को अपडेट करता है। यह फ़ंक्शन d3_behavior_zoomTarget पर टच को प्राप्त करता है और प्रत्येक टच के लिए एक ज़ूम लोकेशन बनाता है।  यह फ़ंक्शन d3_behavior_zoomLocations में प्रत्येक टच के लिए ज़ूम लोकेशन स्टोर करता है।"
  },
  {
    "id": "sample_54834",
    "language": "javascript",
    "length_bucket": "short",
    "code": "function getDefinedNames() {\n  return Object.keys(primitives).concat(Object.keys(registry).map(function (type) {\n    return registry[type].type;\n  }));\n}",
    "docstring": "Return all defined type names",
    "model_name": "gemma-2-9b-it",
    "summary_english": "getDefinedNames returns a list of all defined names in the code. It does this by first getting the keys from the 'primitives' object. Then, it iterates through the 'registry' object, extracting the 'type' property from each entry and adding it to the list. Finally, it combines the two lists using the concat method.",
    "summary_chinese": "getDefinedNames 函数用于获取所有已定义的名称。 \n\n参数：无\n\n逻辑：该函数首先获取 primitives 对象的所有键，然后获取 registry 对象中每个类型的键，并将其与对应类型的类型值拼接起来，最后返回所有键的合并结果。",
    "summary_french": "La fonction getDefinedNames retourne une liste de tous les noms de types définis. Elle récupère d'abord les clés de l'objet primitives, puis les clés de l'objet registry et, pour chaque clé, elle extrait la valeur associée qui représente le type. Enfin, elle concatène ces deux listes pour obtenir la liste complète des noms de types définis.",
    "summary_spanish": "La función getDefinedNames devuelve una lista de nombres de tipos definidos. Recibe ningún argumento.  Su lógica consiste en obtener las claves del objeto primitives y concatenarlas con las claves del objeto registry, después de mapear cada clave del objeto registry a su valor correspondiente (el tipo).",
    "summary_portuguese": "getDefinedNames retorna uma lista de nomes de tipos definidos. \n\nArgumentos: nenhum\n\nLógica: \n- Retorna a união dos nomes das chaves do objeto `primitives` com os nomes dos tipos definidos no objeto `registry`. \n- Para cada tipo no `registry`, extrai o nome do tipo associado a ele.",
    "summary_arabic": "function getDefinedNames يعود بقائمة أسماء المتغيرات المحددة.  \narguments: none\nlogic:  \n1. يحصل على قائمة أسماء المفاتيح من object primitives.\n2. يحصل على قائمة أسماء المفاتيح من object registry.\n3. يقوم بتطبيق دالة على كل مفتاح في registry ليعود اسم type المرتبط به.\n4. يقوم بدمج القائمتين السابقتين ليعود قائمة شاملة بأسماء المتغيرات المحددة.",
    "summary_hindi": "getDefinedNames नामक यह फ़ंक्शन सभी परिभाषित नामों की एक सूची वापस करता है। यह primitives और registry नामक दो ऑब्जेक्ट्स से नामों को एकत्र करता है। primitives ऑब्जेक्ट के सभी की-वैल्यू जोड़े को शामिल करता है, जबकि registry ऑब्जेक्ट के प्रत्येक प्रकार के लिए registry[type].type नाम वापस करता है। अंत में, यह दोनों सूचियों को मिलाकर एक नई सूची बनाता है और उसे वापस करता है।"
  },
  {
    "id": "sample_51521",
    "language": "javascript",
    "length_bucket": "short",
    "code": "function(type, record) {\n    var existingFixture = this.findExistingFixture(type, record);\n\n    if(existingFixture) {\n      var index = indexOf(type.FIXTURES, existingFixture);\n      type.FIXTURES.splice(index, 1);\n      return true;\n    }\n  }",
    "docstring": "/*\n@method deleteLoadedFixture\n@private\n@param type\n@param record",
    "model_name": "gemma-2-9b-it",
    "summary_english": "This function removes a fixture from a list. It takes two arguments: 'type' which is an object, and 'record' which is a string. The function first checks if a fixture with the given 'type' and 'record' already exists in the 'FIXTURES' array of the 'type' object. If it exists, the function removes the fixture from the array and returns true. Otherwise, it returns nothing.",
    "summary_chinese": "该函数名为 `findExistingFixture`，用于从一个名为 `FIXTURES` 的数组中删除一个匹配特定类型和记录的条目。它接受两个参数：`type` 类型为对象，`record` 类型为任意值。函数首先使用 `this.findExistingFixture` 方法查找匹配的条目。如果找到匹配的条目，则获取其索引，并使用 `splice` 方法从 `FIXTURES` 数组中删除该条目，并返回 `true`。否则，返回 `false`。",
    "summary_french": "La fonction supprime un fixture existant. Elle prend en argument le type de fixture et le record du fixture à supprimer. Elle recherche d'abord le fixture existant en utilisant la méthode findExistingFixture. Si le fixture est trouvé, son index dans le tableau FIXTURES du type est récupéré et le fixture est supprimé du tableau. La fonction retourne true si le fixture a été supprimé, false sinon.",
    "summary_spanish": "La función elimina un fixture existente. Recibe dos argumentos: 'type' de tipo objeto y 'record' de tipo objeto. Busca un fixture existente con el tipo y el registro proporcionados. Si se encuentra, lo elimina del arreglo 'FIXTURES' del objeto 'type' y devuelve true. Si no se encuentra, no hace nada.",
    "summary_portuguese": "A função remove um fixture existente. Ela recebe dois argumentos: 'type' que é um objeto e 'record' que é um objeto. A função procura por um fixture existente com base no tipo e no registro fornecidos. Se um fixture existente for encontrado, ele é removido da lista de fixtures do tipo e a função retorna true. Caso contrário, a função retorna false.",
    "summary_arabic": "function deleteFixture  \n\nتُستخدم هذه الدالة لإزالة سجل من قائمة fixtures. \n\narguments:\ntype: object\nrecord: object\n\nlogic:\n1.  تبحث الدالة عن سجل موجود من نفس النوع و السجل المراد إزالته.\n2.  إذا وجد السجل، يتم إزالته من قائمة fixtures.\n3.  يعود true إذا تم إزالة السجل، وإلا يعود false.",
    "summary_hindi": "यह फ़ंक्शन किसी दिए गए प्रकार और रिकॉर्ड के लिए मौजूदा फ़िक्स्चर को हटाता है। यह दो मान लेता है: 'type' जो एक ऑब्जेक्ट है और 'record' जो एक ऑब्जेक्ट है। यह पहले 'findExistingFixture' फ़ंक्शन का उपयोग करके दिए गए प्रकार और रिकॉर्ड के लिए मौजूदा फ़िक्स्चर को ढूंढता है। यदि मौजूदा फ़िक्स्चर पाया जाता है, तो यह फ़िक्स्चर को 'FIXTURES' एरे से हटा देता है और 'true' वापस देता है।"
  },
  {
    "id": "sample_54273",
    "language": "javascript",
    "length_bucket": "short",
    "code": "function(base, wrapped) {\n            return function() {\n                var args = [].slice.call(arguments, 0);\n                return wrapped.apply(this, [_.bind(base, this)].concat(args));\n            };\n        }",
    "docstring": "#### around\ncalls the wrapped function with base function as first argument\non the target object.\n@param base {function} Base Function\n@param wrapped {function} Wrapped function\n@returns {function}",
    "model_name": "gemma-2-9b-it",
    "summary_english": "This function creates a new function that acts as a wrapper for another function. It takes two arguments: 'base' which is a function, and 'wrapped' which is the function to be wrapped. The new function accepts any number of arguments. It then binds the 'base' function to the context of the caller and calls the 'wrapped' function with the bound 'base' function and the provided arguments.  The result of the 'wrapped' function is returned.",
    "summary_chinese": "这个函数名为函数柯里化，它用于将一个函数包装成另一个函数，以便能够延迟执行部分参数。它接受两个参数：base 和 wrapped。base 是要被包装的函数，wrapped 是一个需要在包装函数执行时调用的函数。函数内部，它使用 slice.call 获取所有传递给包装函数的参数，并使用 bind 将 base 函数的 this 上下文绑定到当前的 this 上下文。最后，它使用 apply 调用 wrapped 函数，并将 base 函数的 this 上下文和所有传递的参数作为参数传递。",
    "summary_french": "Cette fonction crée une nouvelle fonction qui permet d'appeler une fonction `base` avec un contexte modifié. Elle prend deux arguments : `base`, qui est la fonction à appeler, et `wrapped`, qui est la fonction à envelopper. La nouvelle fonction créée prend tous les arguments passés à la fonction enveloppée et les concatène avec le contexte `this` de la fonction enveloppée. Elle appelle ensuite la fonction `wrapped` avec ces arguments modifiés.",
    "summary_spanish": "La función crea un nuevo función que actúa como un wrapper para otra función.  El nuevo función toma el contexto `this` actual y lo pasa a la función `wrapped` junto con los argumentos proporcionados.  \n\nArgumentos:\n\n* base: función a envolver\n* wrapped: función a ejecutar\n\nLogica:\n\n1. Crea un nuevo array con los argumentos recibidos.\n2. Llama a la función `wrapped` con el contexto `this` actual, la función `base` enlazada al contexto actual y los argumentos del nuevo array. \n3. Devuelve el resultado de la ejecución de `wrapped`.",
    "summary_portuguese": "A função cria um novo wrapper para uma função fornecida. O wrapper permite que a função original seja chamada com o contexto 'this' modificado. Ela recebe dois argumentos: 'base', que é a função original, e 'wrapped', que é a função a ser executada com o contexto modificado. O wrapper utiliza o método slice para obter os argumentos passados para a função e aplica a função 'wrapped' com o contexto 'this' modificado para a função 'base' e os argumentos originais.",
    "summary_arabic": "هذه الدالة تسمى \"bind\" وتستخدم لربط دالة مع محيط معين. \n\nتستقبل الدالة \"base\" وهي الدالة التي تريد ربطها، و \"wrapped\" وهي الدالة التي ستنفذ بعد الربط. \n\nعند استدعاء الدالة الناتجة، يتم جمع جميع المتغيرات المدخلة مع \"base\" المربطة بالمحيط الحالي. ثم يتم تنفيذ \"wrapped\" مع هذه المتغيرات.",
    "summary_hindi": "यह फ़ंक्शन एक क्लीनर फ़ंक्शन बनाता है जो एक आधार फ़ंक्शन और एक लपेटने वाले फ़ंक्शन को लेता है। यह एक नया फ़ंक्शन देता है जो आधार फ़ंक्शन को कॉल करता है और लपेटने वाले फ़ंक्शन के साथ संयोजन में इसे लागू करता है। नए फ़ंक्शन में दिए गए सभी तर्क लपेटने वाले फ़ंक्शन को पारित किए जाते हैं, साथ ही आधार फ़ंक्शन को भी इसी संदर्भ में बांधकर पारित किया जाता है।"
  },
  {
    "id": "sample_52720",
    "language": "javascript",
    "length_bucket": "short",
    "code": "function(options) {\n  this.body = options.body;\n  this.data = options.data;\n  this.type = options.type;\n}",
    "docstring": "The `Content` constructor takes an options object, which *must* have either a `body` or `data` property and *may* have a `type` property indicating the media type. If there is no `type` attribute, a default will be inferred.",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function is a constructor. It initializes a new object with properties 'body', 'data', and 'type' taken from the 'options' object.",
    "summary_chinese": "这个函数名为构造函数，用于创建一个新的对象。它接受一个名为 options 的参数，该参数是一个对象，包含 body、data 和 type 三个属性。函数将这些属性的值分别赋值给当前对象的 body、data 和 type 属性。",
    "summary_french": "La fonction est un constructeur qui initialise un objet. Elle prend un argument options qui est un objet contenant les propriétés body, data et type. L'objet créé aura ces propriétés définies avec les valeurs correspondantes provenant de l'argument options.",
    "summary_spanish": "La función recibe un objeto `options` como argumento. Inicializa las propiedades `body`, `data` y `type` del objeto actual con los valores correspondientes del objeto `options`.",
    "summary_portuguese": "A função constrói um objeto com propriedades 'body', 'data' e 'type', recebendo um objeto 'options' como argumento. O objeto 'options' possui as propriedades 'body', 'data' e 'type', que são atribuídas às propriedades correspondentes do objeto criado pela função.",
    "summary_arabic": "function constructMessage  \n\nيُنشئ رسالة باستخدام الخيارات المُقدمة.\n\narguments:\noptions (object) \n  body (string) محتوى الرسالة\n  data (object) بيانات إضافية\n  type (string) نوع الرسالة \n\nيُستخرج محتوى الرسالة، البيانات الإضافية ونوع الرسالة من خيارات المدخلات ويُخزنها في خصائص الرسالة.",
    "summary_hindi": "यह फ़ंक्शन एक नया ऑब्जेक्ट बनाता है। यह ऑब्जेक्ट तीन गुणों से बना होता है: body, data और type। ये गुण  options ऑब्जेक्ट से लिए जाते हैं।"
  },
  {
    "id": "sample_51550",
    "language": "javascript",
    "length_bucket": "short",
    "code": "function(type) {\n    var decamelized = Ember.String.decamelize(type);\n    return Ember.String.pluralize(decamelized);\n  }",
    "docstring": "The ActiveModelAdapter overrides the `pathForType` method to build\nunderscored URLs by decamelizing and pluralizing the object type name.\n\n```js\nthis.pathForType(\"famousPerson\");\n=> \"famous_people\"\n```\n\n@method pathForType\n@param {String} type\n@returns String",
    "model_name": "gemma-2-9b-it",
    "summary_english": "This function takes a string representing a type and returns its pluralized form. It first decamelizes the input string using Ember.String.decamelize. Then, it pluralizes the decamelized string using Ember.String.pluralize and returns the result. \n\nThe function argument is:\n\ntype (string)",
    "summary_chinese": "该函数名为 `function(type)`, 其目的是将输入的类型字符串转换为复数形式。该函数接受一个名为 `type` 的字符串参数。其核心逻辑是首先使用 Ember.String.decamelize 将输入的类型字符串转换为小写形式，然后使用 Ember.String.pluralize 将小写字符串转换为复数形式，最后返回结果。",
    "summary_french": "Cette fonction s'appelle `type` et a pour but de convertir un type de données en sa forme pluriel. Elle prend un seul argument, `type`, qui est une chaîne de caractères. La fonction décamelise d'abord le type en utilisant la méthode `decamelize` d'Ember.String, puis elle pluralise le résultat en utilisant la méthode `pluralize` d'Ember.String. La fonction retourne la forme pluriel du type.",
    "summary_spanish": "La función se llama `function(type)` y tiene como propósito convertir un tipo de dato en su plural en español. Recibe un argumento llamado `type` de tipo cadena. La lógica principal es primero convertir el tipo de dato a minúsculas y luego pluralizar la cadena resultante.",
    "summary_portuguese": "A função recebe um tipo como argumento e retorna a forma pluralizada do tipo decamelizado. O argumento 'type' é uma string. A função primeiro decameliza o tipo usando Ember.String.decamelize e depois pluraliza o resultado usando Ember.String.pluralize.",
    "summary_arabic": "function اسم_الوظيفة  \n\nتُحول اسم نوع إلى صيغة جمع.\n\nالمدخلات:\n\ntype (string)\n\nالمنطق الرئيسي:\n\n1. تُستخدم دالة decamelize من Ember.String لتحويل اسم النوع من صيغة Decamelized إلى صيغة غير مُقسمة.\n2. تُستخدم دالة pluralize من Ember.String لتحويل الاسم غير المُقسم إلى صيغة جمع.\n3. تُرجع الدالة الاسم المُجمع.",
    "summary_hindi": "यह फ़ंक्शन एक दिए गए प्रकार के नाम से उसके बहुवचन रूप को उत्पन्न करता है। यह एक प्रकार का मान लेता है जो स्ट्रिंग है। यह प्रकार के नाम को कम-वचन रूप में बदलता है और फिर उसका बहुवचन रूप बनाता है।"
  },
  {
    "id": "sample_52784",
    "language": "javascript",
    "length_bucket": "medium",
    "code": "function WIFToPrivKey(wifPk) {\n  var og = bs58check.decode(wifPk, 'hex').toString('hex');\n  og = og.substr(2, og.length); // remove WIF format ('80')\n\n  // remove the '01' at the end to 'compress it' during WIF conversion\n  if (og.length > 64) {\n    og = og.substr(0, 64);\n  }\n\n  return og;\n}",
    "docstring": "/*\nGiven a WIF format pk, convert it back to the original pk\n@param {String} privKey (private key)\n@return {Sting} Public Key (uncompressed)",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function WIFToPrivKey converts a Wallet Import Format (WIF) public key to a compressed private key. It takes a single argument, wifPk, which is a string representing the WIF public key. The function first decodes the WIF string using the bs58check library and converts it to a hexadecimal string. Then, it removes the prefix ('80') and any trailing '01' to compress the private key. Finally, it returns the compressed private key as a hexadecimal string.",
    "summary_chinese": "WIFToPrivKey 函数用于将以 WIF 格式表示的私钥转换为十六进制字符串表示的私钥。 \n\n该函数接受一个参数：wifPk，类型为字符串，表示以 WIF 格式的私钥。\n\n该函数首先使用 bs58check.decode 函数将 WIF 格式的私钥解码为十六进制字符串，然后去除 WIF 格式的前缀 ('80')。如果解码后的十六进制字符串长度大于 64，则截取前 64 位，去除私钥压缩时添加的 '01'。最后返回十六进制字符串表示的私钥。",
    "summary_french": "La fonction WIFToPrivKey prend en entrée une clé WIF (Wallet Import Format) et retourne la clé privée correspondante en hexadécimal. Elle supprime d'abord le préfixe WIF ('80') et, si la clé est non compressée, elle tronque la clé à 64 octets.",
    "summary_spanish": "La función WIFToPrivKey toma una clave privada en formato WIF (Wallet Import Format) como argumento y devuelve la clave privada en formato hexadecimal sin formato. Primero, decodifica la cadena WIF en hexadecimal usando la biblioteca bs58check. Luego, elimina los dos primeros caracteres ('80') que indican el formato WIF. Si la longitud de la cadena resultante es mayor que 64, se elimina el último carácter ('01') para comprimir la clave privada. Finalmente, la función devuelve la clave privada en formato hexadecimal.",
    "summary_portuguese": "A função WIFToPrivKey converte uma chave privada no formato WIF para uma chave privada em formato hexadecimal. Ela recebe uma string wifPk como argumento, que representa a chave privada no formato WIF. A função primeiro decodifica a string wifPk usando o algoritmo bs58check e converte o resultado para hexadecimal. Em seguida, remove os dois primeiros caracteres da string hexadecimal, que representam o prefixo WIF. Se a string hexadecimal tiver mais de 64 caracteres, ela é truncada para 64 caracteres. Por fim, a função retorna a string hexadecimal resultante, que representa a chave privada.",
    "summary_arabic": "function WIFToPrivKey  تحويل مفتاح خاص من WIF إلى مفتاح خاص. \n\nيستقبل  WIFToPrivKey  حاصل WIF (wifPk) من نوع string. \n\nيُ Decode  حاصل WIF إلى  hex  ثم يتم إزالة  '80'  من البداية.  إذا كان طول  hex  أكبر من 64 يتم إزالة  '01'  من النهاية.  ثم يتم إرجاع  hex  .",
    "summary_hindi": "WIFToPrivKey नामक यह फ़ंक्शन एक WIF (Wallet Import Format) प्राइवेट की को उसके मूल रूप में परिवर्तित करता है। यह फ़ंक्शन एक WIF प्राइवेट की स्ट्रिंग (wifPk) को लेता है और उसे एक बाइनरी प्राइवेट की स्ट्रिंग वापस करता है। यह फ़ंक्शन पहले WIF प्रारूप को हटाता है और फिर यदि आवश्यक हो तो अतिरिक्त अक्षरों को हटाकर प्राइवेट की को संक्षिप्त करता है।"
  },
  {
    "id": "sample_53517",
    "language": "javascript",
    "length_bucket": "medium",
    "code": "function createIfCondition(condition, strict) {\n  var compiled;\n  if(strict) {\n    compiled = 'if(' + condition + ')';\n  } else {\n    compiled = 'try {' +\n                 '__tmp = ' + condition +\n               '} catch(__err) {' +\n                 'if(__err instanceof ReferenceError) {' +\n                   '__tmp = false;' +\n                 '} else {' +\n                   'throw __err;' +\n                 '}' +\n               '}' +\n               'if(__tmp)';\n  }\n  return compiled;\n}",
    "docstring": "Global functions\n \nOutputs `if` clause based on `condition`. If not `strict`,\nactual test will be wrapped in a `try…catch` statement to catch\nReferenceErrors silently\n\n@param {String} condition\n@param {Boolean} strict\n@return {String}\n@api private",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function createIfCondition takes a condition and a strict flag as input. It generates an if statement based on the condition and strictness. If strict is true, it creates a simple if statement. If strict is false, it uses a try-catch block to handle potential ReferenceErrors that might occur when evaluating the condition. If a ReferenceError occurs, it sets a temporary variable to false; otherwise, it re-throws the error. Finally, it returns the compiled if statement. \n\n\nThe arguments are:\n\ncondition: string\nstrict: boolean",
    "summary_chinese": "createIfCondition 函数用于根据条件和严格模式生成 if 语句的代码。它接受两个参数：condition（条件表达式，类型为字符串）和 strict（布尔值，表示是否严格模式）。如果 strict 为 true，则生成简单的 if 语句；否则，使用 try-catch 块来处理条件表达式可能引发的 ReferenceError 异常，并将结果存储在 __tmp 变量中，最后生成带有 __tmp 条件的 if 语句。",
    "summary_french": "La fonction createIfCondition prend en argument une condition et un paramètre strict. Si strict est vrai, elle retourne une chaîne de caractères représentant une condition if simple. Sinon, elle retourne une chaîne de caractères représentant une condition if avec une gestion des erreurs de référence. La gestion des erreurs vérifie si l'erreur est une ReferenceError, dans ce cas, la variable __tmp est définie sur false. Sinon, l'erreur est relancée.",
    "summary_spanish": "La función createIfCondition crea una expresión de condición \"if\" en código. Toma dos argumentos: condition, que es una expresión que se evaluará, y strict, un booleano que determina si se debe manejar el caso de referencias no definidas. Si strict es verdadero, la función devuelve una expresión \"if\" simple. Si strict es falso, la función crea una expresión \"if\" que intenta evaluar la condición dentro de un bloque \"try-catch\". Si la evaluación de la condición genera un error de referencia no definida, se establece una variable __tmp en falso. De lo contrario, se relanza el error. Finalmente, la función devuelve la expresión \"if\" completa.",
    "summary_portuguese": "A função createIfCondition gera código JavaScript para uma condição if. Ela aceita dois argumentos: condition, que é uma expressão JavaScript, e strict, um booleano que indica se a condição deve ser verificada de forma estrita. Se strict for verdadeiro, a função retorna uma string com a condição if simples. Caso contrário, a função retorna uma string com uma estrutura try-catch para lidar com possíveis erros de referência.  A lógica principal é construir uma string de código JavaScript que representa a condição if, com ou sem tratamento de erros, dependendo do valor de strict.",
    "summary_arabic": "function createIfCondition  تُنشئ عبارة شرطية if.  \nيُستدعى هذا الدالة مع شرط منطقي و خيار strict. \nيُستخدم strict لمعالجة حالات ReferenceError. \nإذا كان strict صحيحًا، يتم إنشاء عبارة if بسيطة. \nإذا كان strict غير صحيح، يتم استخدام محاولة-إلا لمعالجة حالات ReferenceError.",
    "summary_hindi": "यह फ़ंक्शन 'createIfCondition' नाम का है और यह एक शर्त के आधार पर एक if-condition कोड स्ट्रिंग बनाता है। यह दो मान लेता है: 'condition' जो एक स्ट्रिंग है और 'strict' जो एक boolean है। अगर 'strict' true है तो यह 'if(condition)' स्ट्रिंग बनाता है। अगर 'strict' false है तो यह एक try-catch ब्लॉक का उपयोग करके एक अधिक जटिल if-condition बनाता है जो ReferenceError को संभालता है। अंत में यह बनाई गई if-condition स्ट्रिंग वापस करता है।"
  },
  {
    "id": "sample_53447",
    "language": "javascript",
    "length_bucket": "medium",
    "code": "function(app, parentAddon) {\n    this._super.included(app);\n\n    var target = (parentAddon || app);\n\n    target.import(target.bowerDirectory + '/emojify/dist/js/emojify.js');\n\n    if (_emojiConfig.mode === 'sprites') {\n      var destSpriteDir = 'images/sprites';\n      var spritePath    = '/emojify/dist/images/sprites/';\n\n      target.import(target.bowerDirectory + spritePath + 'emojify.png', {\n        destDir: destSpriteDir\n      });\n      target.import(target.bowerDirectory + spritePath + 'emojify@2x.png', {\n        destDir: destSpriteDir\n      });\n    }\n\n  }",
    "docstring": "Import javascript depending on the *mode*. We currently support\n`sprite` and `data-uri` modes (NO basic image mode).",
    "model_name": "gemma-2-9b-it",
    "summary_english": "This function initializes an emoji library. It takes two arguments: 'app' and 'parentAddon', both of which are objects. The function first calls a superclass method 'included' with the 'app' object. It then determines the target object to import the emoji library into, which is either the 'parentAddon' or the 'app' object. The function imports the main emoji library script from the bower directory. If the emoji configuration mode is 'sprites', it imports two sprite images for emoji display at different resolutions.",
    "summary_chinese": "这个函数名为 `included`，用于在应用程序中加载 Emoji 表情库。它接受两个参数：`app` 和 `parentAddon`，类型分别为应用程序对象和父插件对象。函数首先调用父类的 `included` 方法，然后根据 `parentAddon` 是否存在，确定目标对象为应用程序或父插件。接着，它导入 `emojify.js` 文件，并根据 `_emojiConfig.mode` 的值，导入相应的 Emoji 表情图片文件。如果 `mode` 为 `sprites`，则导入 `emojify.png` 和 `emojify@2x.png` 文件，并将其保存到 `images/sprites` 目录下。",
    "summary_french": "La fonction s'appelle `included` et est utilisée pour inclure le module Emojify dans une application. Elle prend deux arguments : `app` qui représente l'application et `parentAddon` qui représente un add-on parent. La fonction détermine la cible à partir de `parentAddon` ou `app`. Elle importe ensuite le fichier JavaScript Emojify depuis le répertoire bower. Si le mode Emojify est défini sur 'sprites', elle importe également les fichiers PNG pour les sprites Emojify.",
    "summary_spanish": "La función se llama `included` y se utiliza para integrar el componente Emojify en una aplicación. Recibe dos argumentos: `app` (la aplicación) y `parentAddon` (un complemento padre, opcional).  Primero, llama a la función `included` del padre. Luego, determina el objetivo de la importación, que es la aplicación o el complemento padre. Importa el archivo JavaScript de Emojify desde el directorio bower. Si el modo de configuración de Emojify es 'sprites', importa también los archivos de sprites para Emojify.",
    "summary_portuguese": "A função `included` configura a importação de emojis para um aplicativo. Ela recebe dois argumentos: `app` e `parentAddon`, ambos objetos.  A função primeiro importa o arquivo `emojify.js` do diretório `bower` do aplicativo ou do addon pai. Se o modo de configuração de emojis for 'sprites', a função importa também os arquivos de sprites `emojify.png` e `emojify@2x.png` para o diretório `images/sprites`.",
    "summary_arabic": "هذه الدالة تُسمى `function` وتُستخدم لدمج مكتبة emojify في تطبيق. \n\nتستقبل الدالة `app` و `parentAddon` كمدخلات. \n\nتُحدد `target` على أساس `parentAddon` أو `app`. \n\nثم تقوم بتحميل ملف `emojify.js` من مُدير bower. \n\nإذا كان وضع `_emojiConfig` هو `sprites`, تقوم بتحميل ملفات `emojify.png` و `emojify@2x.png`  إلى مجلد `images/sprites`.",
    "summary_hindi": "यह फ़ंक्शन एक एडॉन के लिए सेटअप करता है जो इमोजी को बदलने के लिए emojify.js लाइब्रेरी का उपयोग करता है। यह फ़ंक्शन app और parentAddon नामक दो एरग्यूमेंट्स लेता है। यह पहले app में शामिल होता है और फिर emojify.js को app या parentAddon में इम्पोर्ट करता है। अगर _emojiConfig.mode 'sprites' है, तो यह emojify.png और emojify@2x.png इमेज को भी app या parentAddon में इम्पोर्ट करता है।"
  },
  {
    "id": "sample_50408",
    "language": "javascript",
    "length_bucket": "medium",
    "code": "function MouseEdges(parent, options) {\n        _classCallCheck(this, MouseEdges);\n\n        var _this = _possibleConstructorReturn(this, (MouseEdges.__proto__ || Object.getPrototypeOf(MouseEdges)).call(this, parent));\n\n        options = options || {};\n        _this.options = options;\n        _this.reverse = options.reverse ? 1 : -1;\n        _this.noDecelerate = options.noDecelerate;\n        _this.linear = options.linear;\n        _this.radiusSquared = Math.pow(options.radius, 2);\n        _this.resize();\n        _this.speed = options.speed || 8;\n        return _this;\n    }",
    "docstring": "Scroll viewport when mouse hovers near one of the edges.\n@private\n@param {Viewport} parent\n@param {object} [options]\n@param {number} [options.radius] distance from center of screen in screen pixels\n@param {number} [options.distance] distance from all sides in screen pixels\n@param {number} [options.top] alternatively, set top distance (leave unset for no top scroll)\n@param {number} [options.bottom] alternatively, set bottom distance (leave unset for no top scroll)\n@param {number} [options.left] alternatively, set left distance (leave unset for no top scroll)\n@param {number} [options.right] alternatively, set right distance (leave unset for no top scroll)\n@param {number} [options.speed=8] speed in pixels/frame to scroll viewport\n@param {boolean} [options.reverse] reverse direction of scroll\n@param {boolean} [options.noDecelerate] don't use decelerate plugin even if it's installed\n@param {boolean} [options.linear] if using radius, use linear movement (+/- 1, +/- 1) instead of angled movement (Math.cos(angle from center), Math.sin(angle from center))\n@param {boolean} [options.allowButtons] allows plugin to continue working even when there's a mousedown event\n\n@event mouse-edge-start(Viewport) emitted when mouse-edge starts\n@event mouse-edge-end(Viewport) emitted when mouse-edge ends",
    "model_name": "gemma-2-9b-it",
    "summary_english": "MouseEdges is a constructor function that initializes an object responsible for handling mouse-driven edge animations. It takes two arguments: parent, which is the parent element of the edges, and options, an object containing configuration settings. The options object can include properties like reverse, noDecelerate, linear, and radius, which control the direction, deceleration, animation style, and radius of the edges, respectively. The function sets default values for the options and calculates the squared radius. It then calls a resize method and sets the initial speed of the animation.",
    "summary_chinese": "MouseEdges 函数用于创建鼠标边缘交互效果。它接受两个参数：parent，表示父元素，类型为 DOM 元素；options，表示配置选项，类型为对象。 \n\n配置选项包括 reverse，用于控制边缘方向，noDecelerate，用于禁用减速效果，linear，用于启用线性运动，radius，用于设置边缘半径，speed，用于设置移动速度。 \n\n函数内部首先初始化选项，然后计算半径平方值，并调用 resize 方法进行尺寸调整。最后，设置默认速度为 8。",
    "summary_french": "La fonction MouseEdges est un constructeur qui initialise un objet représentant les bords de la souris. Elle prend deux arguments : parent, qui est un objet parent, et options, un objet contenant des options de configuration. L'objet options peut inclure des propriétés telles que reverse, noDecelerate, linear, et radius. La fonction initialise les propriétés de l'objet en fonction des options fournies. Elle calcule également la valeur de radiusSquared à partir de la propriété radius de l'objet options. Enfin, elle appelle la méthode resize pour ajuster les bords de la souris.",
    "summary_spanish": "La función MouseEdges es un constructor que crea un objeto para manejar los bordes del mouse. Recibe dos argumentos: parent, que es el elemento padre, y options, un objeto con opciones. Las opciones incluyen reverse, noDecelerate, linear, y radius. La función inicializa las propiedades del objeto con los valores de las opciones. También calcula el cuadrado del radio y redimensiona el objeto. Finalmente, establece la velocidad del objeto a 8 o al valor especificado en la opción speed.",
    "summary_portuguese": "A função MouseEdges é um construtor que cria um objeto responsável por gerenciar as bordas do mouse em um gráfico. Ela recebe dois argumentos: parent, que é o elemento pai, e options, um objeto com configurações opcionais. As configurações incluem reverse, que define a direção do movimento, noDecelerate, que desabilita a desaceleração, linear, que define o movimento como linear, radius, que define o raio das bordas, e speed, que define a velocidade do movimento. A função inicializa as propriedades do objeto com os valores fornecidos nas opções e chama o método resize para ajustar o tamanho do objeto.",
    "summary_arabic": "function MouseEdges  يُستخدم لإنشاء ميزة تفاعلية على شكل حدود حول الفأرة. يتلقى الوظيفة  `parent`  الذي يشير إلى عنصر الوالد و `options`  الذي يحتوي على إعدادات مثل اتجاه دوران الحدود، سرعة الحركة، ونسبة التباطؤ.  يُحدد الوظيفة  `reverse`  اتجاه دوران الحدود،  `noDecelerate`  يُعطى قيمة `true`  لإيقاف التباطؤ،  `linear`  يُعطى قيمة `true`  لإزالة التباطؤ الخطي،  `radius`  يحدد نصف قطر الحدود،  `speed`  يحدد سرعة الحركة.  يُدعى  `resize`  لتحديث حجم الحدود.",
    "summary_hindi": "MouseEdges नामक फ़ंक्शन एक ऐसा ऑब्जेक्ट बनाता है जो माउस की गति के आधार पर एक ग्राफिकल इफेक्ट प्रदर्शित करता है। यह फ़ंक्शन दो आर्गुमेंट्स लेता है: `parent` जो एक HTML एलिमेंट का रेफरेंस होता है और `options` जो एक ऑब्जेक्ट होता है जिसमें इफेक्ट के लिए सेटिंग्स होती हैं।  \n\n`options` ऑब्जेक्ट में `reverse`, `noDecelerate`, `linear`, और `radius` जैसे विकल्प होते हैं जो इफेक्ट की दिशा, गति, और त्रिज्या को नियंत्रित करते हैं। फ़ंक्शन `options` से इन सेटिंग्स को प्राप्त करता है और उन्हें `_this.options` में स्टोर करता है। \n\nइसके बाद, फ़ंक्शन `_this.resize()` को कॉल करता है जो इफेक्ट के आकार को समायोजित करता है और `_this.speed` को सेट करता है जो इफेक्ट की गति को नियंत्रित करता है।"
  },
  {
    "id": "sample_53664",
    "language": "javascript",
    "length_bucket": "medium",
    "code": "function() {\n      // Make sure a node version is intalled that satisfies\n      // the projects required engine. If not, prompt to install.\n      nvmLs('local', function() {\n        var matches = semver.maxSatisfying(locals, expected);\n\n        if (matches) {\n          bestMatch = matches;\n          nvmUse = nvmInit + 'nvm use ' + bestMatch;\n\n          childProcess.exec(nvmUse, cmdOpts,function(err, stdout, stderr) {\n            printVersion(stdout.split(' ')[3]);\n            extendExec();\n            checkPackages(options.globals);\n          });\n        } else {\n          if (options.alwaysInstall) {\n            nvmInstall();\n          } else {\n            askInstall();\n          }\n        }\n      });\n    }",
    "docstring": "Check for compatible node version",
    "model_name": "gemma-2-9b-it",
    "summary_english": "This function checks if a compatible Node.js version is installed. It uses `nvmLs` to list locally available Node.js versions and `semver.maxSatisfying` to find the best match for the project's requirements. If a match is found, it uses `nvmUse` to switch to that version, prints the version, and proceeds with further execution. If no match is found, it prompts the user to install a compatible version if the `alwaysInstall` option is set, otherwise, it asks for confirmation before installing. \n\n\nThe function takes an `options` object as an argument, which includes a `globals` property.",
    "summary_chinese": "这个函数名为 `function()`, 它的目的是检查并使用满足项目要求的 Node.js 版本。 \n\n它接受一个名为 `options` 的参数，其中包含一个名为 `globals` 的属性。\n\n该函数首先使用 `nvmLs` 函数列出本地可用的 Node.js 版本。然后，它使用 `semver.maxSatisfying` 函数找到与项目要求最匹配的版本。如果找到匹配的版本，则使用 `nvmUse` 命令切换到该版本，并打印版本号。最后，它调用 `extendExec` 和 `checkPackages` 函数。如果找不到匹配的版本，则根据 `options.alwaysInstall` 属性的值，选择安装新版本或提示用户安装。",
    "summary_french": "Cette fonction vérifie si une version de Node.js satisfaisant les exigences du projet est installée. Si ce n'est pas le cas, elle invite l'utilisateur à l'installer. Elle utilise la commande `nvmLs` pour lister les versions locales de Node.js et `semver.maxSatisfying` pour trouver la version la plus compatible avec les exigences du projet. Si une version compatible est trouvée, elle est utilisée avec la commande `nvm use`. Sinon, si l'option `alwaysInstall` est activée, elle installe la version requise. Sinon, elle demande à l'utilisateur s'il souhaite l'installer. \n\n\nArguments:\n\noptions (objet) \n\n\nLogique clé:\n\n- Vérifier la présence d'une version de Node.js compatible.\n- Si une version compatible est trouvée, l'utiliser.\n- Sinon, installer la version requise si l'option `alwaysInstall` est activée, sinon demander à l'utilisateur.",
    "summary_spanish": "La función verifica si existe una versión de Node.js instalada que cumpla con los requisitos del proyecto. Si no se encuentra una versión compatible, solicita al usuario que la instale. Si se encuentra una versión compatible, la utiliza y ejecuta las siguientes acciones: imprime la versión de Node.js, ejecuta una función extendida llamada extendExec y verifica los paquetes.",
    "summary_portuguese": "A função verifica se uma versão do Node.js compatível com o projeto está instalada. Se não estiver, ela solicita ao usuário que instale a versão necessária. Caso contrário, usa a versão encontrada e executa as etapas seguintes: imprime a versão do Node.js, executa uma função chamada extendExec e verifica os pacotes. \n\n\nA função recebe um objeto options como argumento, que contém a propriedade globals.",
    "summary_arabic": "هذه الدالة تقوم بتحقق من وجود إصدار من Node.js مثبت يلبي متطلبات المشروع. إذا لم يكن هناك إصدار مناسب مثبت، فستطلب من المستخدم تثبيته. \n\nتستدعي الدالة `nvmLs` للحصول على قائمة بالإصدارات المحلية المتوفرة. ثم تستخدم `semver.maxSatisfying` لتحديد الإصدار الأفضل المتوافق مع الإصدار المطلوب. \n\nإذا وجد إصدار متوافق، ستستخدم `nvmUse` لتشغيله. وإلا، ستقوم بإجراء أحد الإجراءات التالية: تثبيت الإصدار المطلوب إذا تم تعيين خيار `alwaysInstall`، أو سؤال المستخدم عن تثبيت الإصدار.",
    "summary_hindi": "यह फ़ंक्शन Node.js के एक विशिष्ट संस्करण का उपयोग करने के लिए आवश्यक है। यह पहले उपलब्ध स्थानीय Node.js संस्करणों की जाँच करता है और आवश्यक संस्करण के साथ सबसे अच्छा मिलान खोजता है। यदि मिलान होता है, तो यह उस संस्करण का उपयोग करता है और प्रोग्राम को आगे बढ़ाता है। यदि मिलान नहीं होता है, तो यह उपयोगकर्ता से स्थापना की पुष्टि करने के लिए कहता है या यदि `alwaysInstall` विकल्प सच है, तो स्वचालित रूप से स्थापित करता है।"
  },
  {
    "id": "sample_55012",
    "language": "javascript",
    "length_bucket": "medium",
    "code": "function functionName( fcn ) {\n\tvar name;\n\tif ( !isFunction( fcn ) ) {\n\t\tthrow new TypeError( 'invalid input argument. Must provide a function. Value: `' + fcn + '`.' );\n\t}\n\tif ( isString( fcn.name ) ) {\n\t\tname = fcn.name;\n\t} else {\n\t\tname = RE.exec( fcn.toString() )[ 1 ];\n\t}\n\treturn (name === '') ? 'anonymous' : name;\n}",
    "docstring": "FUNCTION NAME // \nFUNCTION: functionName( fcn )\nReturns the name of a function.\n\n@param {Function} fcn - input function\n@returns {String} function name or null",
    "model_name": "gemma-2-9b-it",
    "summary_english": "functionName takes a function as input. It checks if the input is a valid function. If it is, it attempts to retrieve the function's name. If the function has a name property, it uses that. Otherwise, it extracts the name from the function's string representation using a regular expression. Finally, it returns the function's name or 'anonymous' if no name is found. \n\n\nThe function's arguments are:\n\nfcn: function",
    "summary_chinese": "functionName 函数用于获取一个函数的名称。它接受一个函数作为参数，如果参数不是一个函数，则抛出一个 TypeError 错误。如果函数有名称属性，则使用该属性的值作为函数名称；否则，它会从函数的 toString() 返回值中提取名称。最后，如果函数名称为空字符串，则返回 \"anonymous\"，否则返回函数名称。",
    "summary_french": "La fonction functionName prend en argument une fonction fcn. Elle vérifie si l'argument est bien une fonction. Si ce n'est pas le cas, elle lance une erreur. Si l'argument est une fonction, elle extrait son nom. Si le nom est une chaîne de caractères, elle l'utilise. Sinon, elle extrait le nom à partir de la représentation en chaîne de la fonction. Enfin, elle retourne le nom de la fonction, ou \"anonymous\" si le nom est vide.",
    "summary_spanish": "La función functionName recibe una función como argumento. Si el argumento no es una función, lanza un error. Si el nombre de la función es una cadena, lo devuelve. De lo contrario, extrae el nombre de la función del código fuente de la función. Finalmente, devuelve el nombre de la función, o \"anonymous\" si no se puede determinar.",
    "summary_portuguese": "function functionName recebe uma função como argumento. Verifica se o argumento é realmente uma função. Se não for, lança um erro. Se o nome da função for uma string, usa o nome da função. Caso contrário, extrai o nome da função da sua representação em string. Retorna o nome da função, ou \"anonymous\" se o nome não puder ser determinado.",
    "summary_arabic": "function functionName تستقبل دالة كمدخل وتقوم بتحديد اسم الدالة. إذا لم تكن المدخل دالة، يتم إلقاء خطأ TypeError. إذا كان اسم الدالة متوفرًا كسلسلة، يتم استخدامه. وإلا، يتم استخراج اسم الدالة من سلسلة تمثيل الدالة باستخدام صيغة دورية. يتم إرجاع اسم الدالة، أو \"anonymous\" إذا كان الاسم فارغًا.",
    "summary_hindi": "function functionName एक फ़ंक्शन है जो किसी दिए गए फ़ंक्शन का नाम वापस करता है। यह फ़ंक्शन एक फ़ंक्शन argument लेता है जो एक फ़ंक्शन होना चाहिए। यदि argument एक फ़ंक्शन है और उसका नाम स्ट्रिंग में है, तो फ़ंक्शन उस नाम को वापस करता है। यदि नाम स्ट्रिंग में नहीं है, तो यह फ़ंक्शन फ़ंक्शन के toString() का उपयोग करके नाम निकालता है। यदि कोई नाम नहीं मिलता है, तो यह \"anonymous\" वापस करता है।"
  },
  {
    "id": "sample_49707",
    "language": "javascript",
    "length_bucket": "medium",
    "code": "function isNumericRefined(attribute, operator, value) {\n    if (isUndefined(value) && isUndefined(operator)) {\n      return !!this.numericRefinements[attribute];\n    }\n\n    var isOperatorDefined = this.numericRefinements[attribute] &&\n      !isUndefined(this.numericRefinements[attribute][operator]);\n\n    if (isUndefined(value) || !isOperatorDefined) {\n      return isOperatorDefined;\n    }\n\n    var parsedValue = valToNumber(value);\n    var isAttributeValueDefined = !isUndefined(\n      findArray(this.numericRefinements[attribute][operator], parsedValue)\n    );\n\n    return isOperatorDefined && isAttributeValueDefined;\n  }",
    "docstring": "Test if the triple (attribute, operator, value) is already refined.\nIf only the attribute and the operator are provided, it tests if the\ncontains any refinement value.\n@method\n@param {string} attribute attribute for which the refinement is applied\n@param {string} [operator] operator of the refinement\n@param {string} [value] value of the refinement\n@return {boolean} true if it is refined",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function isNumericRefined checks if a given attribute, operator, and value combination represents a valid numeric refinement. It takes three arguments: attribute (string), operator (string), and value (string). \n\nIf both value and operator are undefined, it returns whether a numeric refinement exists for the given attribute. \n\nIf the operator is defined for the attribute, it checks if the value is defined within the operator's allowed values. It parses the value to a number and checks if it exists in the array of allowed values for the operator. \n\nFinally, it returns true only if both the operator and the value are valid for the given attribute.",
    "summary_chinese": "isNumericRefined 函数用于检查属性、运算符和值是否满足数值筛选条件。它接受三个参数：attribute（属性名，字符串类型）、operator（运算符，字符串类型）、value（值，字符串类型）。 \n\n函数首先判断值和运算符是否都未定义，如果是，则返回该属性是否存在数值筛选。 \n\n如果值未定义或运算符未定义，则返回运算符是否已定义。 \n\n如果值已定义，则将值解析为数字，并检查该运算符下是否存在该数字值。最后，返回运算符是否已定义且该数字值是否已定义。",
    "summary_french": "La fonction `isNumericRefined` vérifie si une affinité numérique est définie pour un attribut donné. Elle prend trois arguments : `attribute` (chaîne de caractères), `operator` (chaîne de caractères) et `value` (chaîne de caractères). Si `value` et `operator` sont indéfinis, elle retourne la valeur de l'affinité numérique pour l'attribut. Sinon, elle vérifie si l'opérateur est défini pour l'attribut et si la valeur est définie pour cet opérateur. La fonction retourne `true` si l'opérateur et la valeur sont définis, sinon elle retourne `false`.",
    "summary_spanish": "La función isNumericRefined determina si una refinación numérica específica está definida para un atributo dado. Recibe tres argumentos: attribute (cadena), operator (cadena) y value (cualquier tipo). Si value y operator no están definidos, la función devuelve si existe una refinación numérica para el atributo. Si operator está definido, la función verifica si existe una refinación numérica para el atributo y el operador. Si value está definido, la función verifica si el valor está presente en la lista de valores permitidos para el operador. La función devuelve true si todas las condiciones se cumplen, false en caso contrario.",
    "summary_portuguese": "A função `isNumericRefined` verifica se uma refinamento numérico específico está definido para um atributo dado. Ela recebe três argumentos: `attribute` (string), o nome do atributo; `operator` (string), o operador de refinamento; e `value` (string ou número), o valor do refinamento. A função primeiro verifica se `value` e `operator` estão indefinidos. Se sim, ela retorna se o refinamento numérico para o atributo está definido. Caso contrário, ela verifica se o operador está definido para o atributo e se o valor está definido para o operador. Finalmente, ela retorna `true` se ambos os operadores e o valor estiverem definidos, caso contrário, retorna `false`.",
    "summary_arabic": "function isNumericRefined  يقوم بفحص ما إذا كان هناك تعديل رقمي محدد لخاصية معينة. \n\nيتلقى الوظيفة ثلاثة أُسطر: attribute (اسم الخاصية) من نوع string, operator (اسم المَشْغل) من نوع string, value (القيمة) من نوع string.\n\nإذا كان كلا من value و operator غير مُعرّف، فإنه يعود قيمة `true` إذا وجد تعديل رقمي لهذا attribute، وإلا يعود `false`.\n\nإذا كان operator مُعرّف، ولكن value غير مُعرّف، فإنه يعود قيمة `true` إذا وجد مشغل لهذا attribute، وإلا يعود `false`.\n\nإذا كان كلا من value و operator مُعرّف، فإنه يحاول تحويل value إلى رقم، ثم يبحث عن هذا الرقم في قائمة القيم المسموح بها لهذا المشغل و لهذا attribute. يعود قيمة `true` إذا وجد الرقم في القائمة، وإلا يعود `false`.",
    "summary_hindi": "इस फ़ंक्शन का नाम `isNumericRefined` है। यह फ़ंक्शन यह जांचता है कि दिए गए `attribute`, `operator` और `value` के साथ कोई संख्यात्मक फ़िल्टर लागू है या नहीं। \n\nयह फ़ंक्शन तीन मान लेता है: `attribute` (स्ट्रिंग), `operator` (स्ट्रिंग), और `value` (कोई भी)। \n\nयदि `value` और `operator` दोनों undefined हैं, तो यह फ़ंक्शन `this.numericRefinements` में दिए गए `attribute` के लिए कोई फ़िल्टर मौजूद है या नहीं की जाँच करता है। यदि `value` undefined है या `operator` के लिए कोई फ़िल्टर नहीं है, तो यह फ़ंक्शन `operator` के लिए फ़िल्टर मौजूद है या नहीं बताता है। यदि `value` परिभाषित है, तो यह फ़ंक्शन `value` को संख्या में परिवर्तित करता है और यह जाँचता है कि `operator` के लिए फ़िल्टर में यह संख्या मौजूद है या नहीं। अंत में, यह फ़ंक्शन `operator` के लिए फ़िल्टर मौजूद है और `value` उस फ़िल्टर में मौजूद है या नहीं, यह बताता है।"
  },
  {
    "id": "sample_50578",
    "language": "javascript",
    "length_bucket": "medium",
    "code": "function UserSockets(sio, sessionStore) {\n  this.sio = sio;\n  this.sockets = {};\n  this.sessionStore = sessionStore;\n  //sio.enable('browser client minification');  // send minified client\n  //sio.enable('browser client etag');          // apply etag caching logic based on version number\n  //sio.enable('browser client gzip');\n  //sio.set('log level', 1);\n  //sio.set('authorization', authorize.bind(this, sessionStore))\n  sio.use(authorize.bind(this, sessionStore));\n  sio.sockets.on('connection', this.connected.bind(this));\n}",
    "docstring": "/*\nwebsockets.init()\n\nInitialize the Socket.io server.\n sio: socketio server. ex: io.listen(server)",
    "model_name": "gemma-2-9b-it",
    "summary_english": "UserSockets is a constructor function that initializes a Socket.IO server with user authentication. It takes two arguments: sio, which is the Socket.IO instance, and sessionStore, which is a function for managing user sessions. The function initializes an empty sockets object to store connected clients and binds the connected event listener to the connected method of the UserSockets instance. It also uses the authorize function to authenticate incoming connections based on the sessionStore.",
    "summary_chinese": "UserSockets 函数用于管理用户连接。它接受两个参数：sio（一个 Socket.IO 实例）和 sessionStore（一个会话存储器）。它初始化一个存储用户连接的 sockets 对象。然后，它使用 authorize 函数进行身份验证，该函数绑定到 sessionStore。最后，它监听连接事件，并调用 connected 函数处理连接。",
    "summary_french": "La fonction UserSockets initialise un serveur Socket.IO. Elle prend deux arguments: sio, qui représente l'instance de Socket.IO, et sessionStore, qui est utilisé pour gérer les sessions utilisateur. La fonction initialise un objet sockets pour stocker les connexions utilisateur et utilise la fonction authorize pour authentifier les connexions. Elle écoute les événements de connexion et appelle la fonction connected lorsqu'une nouvelle connexion est établie.",
    "summary_spanish": "La función UserSockets se encarga de gestionar las conexiones de usuarios a través de sockets. Recibe dos argumentos: sio, que es un objeto de la librería Socket.IO, y sessionStore, que es un objeto para almacenar sesiones de usuario. La función inicializa un objeto para almacenar las conexiones de los usuarios y configura Socket.IO para usar un middleware de autorización basado en el objeto sessionStore. Además, se registra un manejador de eventos para la conexión de nuevos usuarios, que se ejecuta cuando un usuario se conecta.",
    "summary_portuguese": "A função UserSockets gerencia conexões de sockets para usuários. Ela recebe dois argumentos: sio, que é um objeto Socket.IO, e sessionStore, que é um objeto para armazenar sessões. A função inicializa um objeto para armazenar sockets de usuários e configura o middleware de autenticação usando a função authorize. Quando uma nova conexão é estabelecida, a função connected é chamada.",
    "summary_arabic": "UserSockets هو فئة تقوم بتشغيل مهام تتعلق بالاتصالات بين المستخدمين باستخدام Socket.IO.  \n\nتستقبل هذه الفئة  اثنين من المدخلات: sio وهو م实例 من Socket.IO و sessionStore وهو مستودع للمشغل. \n\nتتضمن الفئة  خوارزمية  لتفعيل  الوظائف  المتعلقة  ب Socket.IO مثل  التصغير  و  التخزين  باستخدام  etag  و  التضغط  و  تعيين  مستوى  التسجيل. \n\nكما  تستخدم  وظيفة  authorize  لتأمين  الاتصالات. \n\nعند  توصيل  مستخدم  جديد  تُنفذ  الوظيفة  connected.",
    "summary_hindi": "UserSockets नामक फ़ंक्शन एक सॉकेट सर्वर को संभालने के लिए डिज़ाइन किया गया है। यह एक Socket.IO इंस्टेंस (sio) और एक सत्र स्टोर (sessionStore) को लेता है।  इसका मुख्य उद्देश्य सत्रों को प्रबंधित करना और नए कनेक्शन पर कार्रवाई करना है। यह एक उपयोगकर्ता के लिए सत्रों को प्रबंधित करने के लिए authorize फ़ंक्शन का उपयोग करता है।  जब कोई नया कनेक्शन स्थापित होता है, तो connected फ़ंक्शन को कॉल किया जाता है।"
  },
  {
    "id": "sample_50661",
    "language": "javascript",
    "length_bucket": "medium",
    "code": "function() {\n\t\t\t\tif (!self) {\n\t\t\t\t\treturn; // obviously already destroyed\n\t\t\t\t}\n\n\t\t\t\tvar shimContainer = Dom.get(this.shimid);\n\t\t\t\tif (shimContainer) {\n\t\t\t\t\tshimContainer.parentNode.removeChild(shimContainer);\n\t\t\t\t}\n\n\t\t\t\tif (_shim) {\n\t\t\t\t\t_shim.removeAllInstances();\n\t\t\t\t}\n\n\t\t\t\tthis.unbindAll();\n\t\t\t\tdelete runtimes[this.uid];\n\t\t\t\tthis.uid = null; // mark this runtime as destroyed\n\t\t\t\t_uid = self = _shim = shimContainer = null;\n\t\t\t}",
    "docstring": "Destroys the runtime (removes all events and deletes DOM structures)\n\n@method destroy",
    "model_name": "gemma-2-9b-it",
    "summary_english": "This function is designed to destroy a runtime instance. It first checks if the instance has already been destroyed. If not, it removes the shim container associated with the runtime from the DOM. It then removes all instances of a shim object, unbinds all events associated with the runtime, and removes the runtime from a runtime registry. Finally, it sets various internal variables to null to indicate that the runtime has been destroyed. \n\n\nThe function takes no arguments.",
    "summary_chinese": "该函数名为 `destroy`，用于销毁一个运行时环境。它接受一个 `this` 参数，代表当前运行时环境实例。函数首先检查 `self` 是否存在，如果不存在则直接返回，因为运行时环境已经销毁。然后，它获取名为 `shimid` 的元素的 DOM 节点，如果存在则将其从父节点中移除。接着，它调用名为 `_shim` 的对象的方法 `removeAllInstances`，清除所有实例。然后，它解绑所有事件，从 `runtimes` 对象中删除当前运行时环境的记录，并将其 `uid` 属性设置为 `null`，标记为已销毁。最后，它将 `_uid`、`self`、`_shim`、`shimContainer` 等变量设置为 `null`，释放资源。",
    "summary_french": "La fonction détruit un runtime. Elle prend aucun argument. Elle vérifie si le runtime a déjà été détruit. Si non, elle supprime le conteneur DOM associé au runtime, supprime toutes les instances du shim, désenregistre tous les écouteurs d'événements, supprime le runtime de la liste des runtimes actifs et met les variables internes à null pour indiquer que le runtime a été détruit.",
    "summary_spanish": "La función destruye un runtime. Recibe como argumento `this` que representa el objeto runtime. Primero verifica si el runtime ya ha sido destruido. Luego, elimina el contenedor DOM asociado al runtime. Si existe una instancia de _shim, se eliminan todas sus instancias. Se desasocian todos los eventos del runtime y se elimina la referencia al runtime del mapa `runtimes`. Finalmente, se liberan las referencias a las variables internas del runtime.",
    "summary_portuguese": "A função destrói um runtime. Ela verifica se o runtime já foi destruído e, se não, remove o container DOM, remove todas as instâncias do shim, desfaz todos os bindings, remove o runtime do mapa de runtimes e marca o runtime como destruído.  \n\n\nArgs:\n\n- None\n\n\nLogic:\n\n- Verifica se o runtime já foi destruído.\n- Remove o container DOM do runtime.\n- Remove todas as instâncias do shim.\n- Desfaz todos os bindings do runtime.\n- Remove o runtime do mapa de runtimes.\n- Marca o runtime como destruído.\n- Define as variáveis internas como null.",
    "summary_arabic": "function destroyRuntime  \n\nThis function is responsible for destroying a runtime instance. \n\nArguments: \n\n- none\n\nLogic:\n\nThe function first checks if the runtime instance has already been destroyed. If it has, it returns. Otherwise, it removes the shim container associated with the runtime from the DOM. It then removes all instances of the shim and unbinds all events associated with the runtime. Finally, it removes the runtime from the runtimes map and sets its unique identifier to null to mark it as destroyed. It also sets several internal variables to null to prevent memory leaks.",
    "summary_hindi": "यह फ़ंक्शन एक रनटाइम इंस्टेंस को डिस्ट्रॉय करने के लिए जिम्मेदार है। यह पहले यह जांचता है कि क्या रनटाइम पहले से ही डिस्ट्रॉय हो चुका है। अगर नहीं, तो यह शिम कंटेनर को हटा देता है, सभी शिम इंस्टेंस को रिमूव करता है, सभी बाइंडिंग को अनबाइंड करता है, रनटाइम को रनटाइम्स डेटा स्ट्रक्चर से हटा देता है और अंत में सभी स्थानीय वैरिएबल्स को निल करता है।"
  },
  {
    "id": "sample_54952",
    "language": "javascript",
    "length_bucket": "medium",
    "code": "function() {\n      var data = {};\n      data = this.serializeData();\n      data = this.mixinTemplateHelpers(data);\n  \n      this.triggerMethod('before:render:template');\n  \n      var template = this.getTemplate();\n      var html = Marionette.Renderer.render(template, data, this);\n      this.attachElContent(html);\n  \n      // the ui bindings is done here and not at the end of render since they\n      // will not be available until after the model is rendered, but should be\n      // available before the collection is rendered.\n      this.bindUIElements();\n      this.triggerMethod('render:template');\n    }",
    "docstring": "Render the root template that the children views are appended to",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function renders a template. It takes no arguments. It first serializes the data, mixes in template helpers, and triggers a 'before:render:template' event. Then, it retrieves the template, renders it with the data and the current context, and attaches the resulting HTML to the element. It then binds UI elements and triggers a 'render:template' event.",
    "summary_chinese": "该函数名为 render，用于渲染模板并绑定UI元素。 \n\n参数：无\n\n逻辑：首先，函数将数据序列化并与模板帮助器混合。然后，它触发 'before:render:template' 事件。接着，函数获取模板并使用 Marionette.Renderer 渲染模板，将数据和上下文对象作为参数传递。渲染后的 HTML 内容被附加到元素内容中。 随后，函数绑定 UI 元素，并触发 'render:template' 事件。",
    "summary_french": "La fonction décrit un processus de rendu de template dans un framework Marionette. Elle prend en entrée les données du composant, les mélange avec des helpers de template et les utilise pour générer du HTML. Le HTML généré est ensuite attaché au contenu de l'élément du composant.  La fonction déclenche également des événements 'before:render:template' et 'render:template' pour informer les autres parties du framework de l'état du rendu.  Enfin, elle lie les éléments de l'interface utilisateur.",
    "summary_spanish": "La función renderiza una plantilla. Toma como entrada los datos serializados del objeto, los mezcla con helpers de plantilla y los utiliza para renderizar la plantilla. Luego, asigna el contenido HTML resultante al elemento del objeto. Finalmente, vincula los elementos de la interfaz de usuario y dispara el evento 'render:template'.",
    "summary_portuguese": "A função renderiza um template. Ela recebe `this` como argumento, que representa o objeto corrente.  A função serializa os dados, mistura helpers de template, dispara um evento 'before:render:template', obtém o template, renderiza o template com os dados e o contexto atual, anexa o conteúdo HTML ao elemento, vincula elementos da interface e dispara um evento 'render:template'.",
    "summary_arabic": "الوظيفة تُسمى  function()  وتهدف إلى عرض قالب مع بيانات محددة. \n\nتستقبل الوظيفة  this  كحجة. \n\nتُجمع البيانات من خلال  this.serializeData()  ثم يتم مزجها مع مساعدات القالب باستخدام  this.mixinTemplateHelpers(data). \n\nبعد ذلك، يتم تنشيط الحدث  'before:render:template' . \n\nيتم استدعاء قالب من خلال  this.getTemplate()  و يتم إرساله إلى  Marionette.Renderer.render  مع البيانات  data  و  this  لتوليد HTML. \n\nيتم إرفاق HTML  بالمحتوى  من خلال  this.attachElContent(html). \n\nثم يتم ربط عناصر واجهة المستخدم  بواسطة  this.bindUIElements()  قبل تنشيط الحدث  'render:template'.",
    "summary_hindi": "यह फ़ंक्शन एक Marionette.View के लिए रेंडरिंग प्रक्रिया को संभालता है। यह `serializeData` और `mixinTemplateHelpers` का उपयोग करके डेटा को तैयार करता है, फिर `getTemplate` का उपयोग करके टेम्पलेट प्राप्त करता है।  `Marionette.Renderer.render` का उपयोग करके टेम्पलेट को डेटा के साथ रेंडर किया जाता है और परिणामी HTML को `attachElContent` में जोड़ा जाता है।  इसके बाद, `bindUIElements` का उपयोग करके UI एलिमेंट्स को बांधता है और `render:template` इवेंट को ट्रिगर करता है।"
  },
  {
    "id": "sample_53373",
    "language": "javascript",
    "length_bucket": "medium",
    "code": "function(identifier, target, cb) {\n    var systemId = _sr.findSystem(identifier);\n    if (!systemId) { logger.error(ERR_NOSYSID); return cb(new Error(ERR_NOSYSID)); }\n    fetchTarget(systemId, target, function(err, target) {\n      if (err) { return cb(err); }\n      logger.info({ systemId: systemId, target: target }, 'get deployed system');\n      _sr.getDeployedRevision(systemId, target, cb);\n    });\n  }",
    "docstring": "get the full deployed system definition",
    "model_name": "gemma-2-9b-it",
    "summary_english": "This function retrieves the deployed revision of a system. It takes three arguments: identifier (string), target (string), and cb (callback function). It first finds the system ID using the provided identifier. If the system ID is not found, it logs an error and returns an error to the callback. Otherwise, it fetches the target and then calls another function to get the deployed revision of the system, passing the error and target to the callback.",
    "summary_chinese": "该函数名为 `function`，用于获取部署在特定系统中的目标版本的详细信息。它接受三个参数：`identifier` (字符串，系统标识符)、`target` (字符串，目标名称) 和 `cb` (函数，回调函数)。函数首先通过 `_sr.findSystem` 方法查找系统标识符对应的系统ID。如果找不到系统ID，则记录错误日志并返回错误。否则，调用 `fetchTarget` 方法获取目标信息，并将其传递给 `_sr.getDeployedRevision` 方法获取部署的版本信息，最终通过回调函数 `cb` 返回结果。",
    "summary_french": "Cette fonction nommée `function` récupère la dernière version déployée d'un système. Elle prend trois arguments : `identifier` (une chaîne de caractères), `target` (une chaîne de caractères) et `cb` (une fonction de rappel). Elle recherche d'abord l'identifiant du système dans une base de données (`_sr.findSystem`). Si l'identifiant n'est pas trouvé, elle déclenche une erreur et retourne la fonction de rappel avec une erreur. Sinon, elle utilise la fonction `fetchTarget` pour récupérer les informations sur la cible (`systemId`, `target`). Une fois les informations récupérées, elle appelle la fonction `_sr.getDeployedRevision` pour obtenir la dernière version déployée du système.",
    "summary_spanish": "La función busca un sistema dado un identificador. Si el sistema no se encuentra, devuelve un error. De lo contrario, recupera el objetivo del sistema y llama a una función para obtener la revisión desplegada del sistema. \n\nArguments:\nidentifier: string\ntarget: string\ncb: function\n\nLogic:\nBusca el sistema por su identificador. Si no se encuentra, devuelve un error. Si se encuentra, recupera el objetivo del sistema y llama a una función para obtener la revisión desplegada del sistema.",
    "summary_portuguese": "A função busca um sistema pelo seu identificador. Se o sistema for encontrado, ela busca o alvo especificado dentro do sistema. Em seguida, ela obtém a revisão implantada para o alvo e chama a função de callback com o resultado. A função recebe três argumentos: o identificador do sistema, o alvo e uma função de callback.",
    "summary_arabic": "هذه الدالة تُسمى  `function` وتستهدف استرجاع الإصدار المُنفذ لنظام معين. \n\nتستقبل الدالة ثلاثة مُدخلات: `identifier` وهو معرف النظام، `target` وهو اسم الهدف، و `cb` وهو دالة مُستدعاة عند الانتهاء. \n\nتُستخدم الدالة `_sr.findSystem` للعثور على معرف النظام من خلال `identifier`. إذا لم يتم العثور على معرف النظام، يتم تسجيل خطأ وتُدعى الدالة `cb` مع خطأ. \n\nإذا تم العثور على معرف النظام، يتم استدعاء الدالة `fetchTarget` لاسترجاع الهدف. \n\nعند الانتهاء من استرجاع الهدف، يتم تسجيل رسالة معلومات وتُدعى الدالة `_sr.getDeployedRevision` لاسترجاع الإصدار المُنفذ للنظام.",
    "summary_hindi": "यह फ़ंक्शन किसी सिस्टम की तैनात रिवीजन प्राप्त करता है। यह 'identifier', 'target' और 'cb' नामक तीन मान लेता है। 'identifier' सिस्टम की पहचान है, 'target' तैनात लक्ष्य है और 'cb' एक कॉलबैक फ़ंक्शन है। यह फ़ंक्शन पहले सिस्टम की पहचान _sr.findSystem() का उपयोग करके पाता है। यदि सिस्टम नहीं पाया जाता है, तो यह एक त्रुटि लौटाता है। यदि सिस्टम पाया जाता है, तो यह fetchTarget() फ़ंक्शन का उपयोग करके लक्ष्य प्राप्त करता है। लक्ष्य प्राप्त करने पर, यह _sr.getDeployedRevision() फ़ंक्शन का उपयोग करके तैनात रिवीजन प्राप्त करता है और परिणाम कॉलबैक फ़ंक्शन में लौटाता है।"
  },
  {
    "id": "sample_49484",
    "language": "javascript",
    "length_bucket": "medium",
    "code": "async function createSourceMapConsumer(compiler: Compiler, url: string) {\n  const response = await fetch(url);\n  const sourceMap = await response.text();\n\n  // we stop here if we couldn't find that map\n  if (!sourceMap) {\n    logger.warn(messages.sourceMapFileNotFound());\n    return null;\n  }\n\n  // feed the raw source map into our consumer\n  try {\n    return new SourceMapConsumer(sourceMap);\n  } catch (err) {\n    logger.error(messages.sourceMapInvalidFormat());\n    return null;\n  }\n}",
    "docstring": "Creates a SourceMapConsumer so we can query it.",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function createSourceMapConsumer takes a compiler and a URL as input. It fetches the source map from the given URL, checks if it was successfully retrieved, and attempts to create a SourceMapConsumer object from the fetched source map data. If the source map is invalid or not found, it logs an error and returns null. \n\n\ncompiler: Compiler\nurl: string",
    "summary_chinese": "该函数名为 createSourceMapConsumer，用于根据给定的 URL 创建 SourceMapConsumer 对象。它接受两个参数：compiler（类型为 Compiler）和 url（类型为字符串）。函数首先通过 fetch 获取源映射文件的内容，然后检查是否成功获取到文件。如果获取成功，则尝试使用源映射内容创建一个 SourceMapConsumer 对象。如果创建失败，则记录错误日志并返回 null。",
    "summary_french": "La fonction `createSourceMapConsumer` prend en entrée un objet `Compiler` et une chaîne de caractères représentant une URL. Elle tente de récupérer le contenu du fichier de mappage source à partir de l'URL fournie. Si le fichier n'est pas trouvé, la fonction affiche un message d'avertissement et retourne `null`. Sinon, elle essaie de créer un objet `SourceMapConsumer` à partir du contenu du fichier. Si la création échoue, la fonction affiche un message d'erreur et retourne `null`.",
    "summary_spanish": "La función createSourceMapConsumer toma un compilador y una URL como argumentos. Su propósito es obtener el contenido del mapa de fuentes desde la URL especificada y crear un consumidor de mapas de fuentes. Si no se encuentra el mapa de fuentes o tiene un formato inválido, la función devuelve null. En caso contrario, devuelve un nuevo consumidor de mapas de fuentes.",
    "summary_portuguese": "A função createSourceMapConsumer recebe um objeto Compiler e uma URL como argumentos. Ela tenta carregar o conteúdo da URL, que é esperado ser um mapa de fontes. Se o carregamento for bem-sucedido, a função cria um consumidor de mapa de fontes a partir do conteúdo carregado. Caso contrário, se o mapa de fontes não for encontrado ou tiver um formato inválido, a função retorna null.",
    "summary_arabic": "function createSourceMapConsumer  يُستخدم لإنشاء مُستهلك خريطة مصادر من ملف خريطة مصادر. يتلقى compiler ك引ام الأول و url ك引ام ثاني. يقوم بفتح ملف url و قراءة محتواه. إذا لم يتم العثور على الخريطة، يقوم بإصدار تحذير و يعود null. وإلا، يحاول إنشاء مُستهلك خريطة مصادر من محتوى الملف. إذا حدث خطأ، يقوم بإصدار خطأ و يعود null.",
    "summary_hindi": "यह async function 'createSourceMapConsumer' है। यह एक स्रोत मानचित्र उपभोक्ता बनाता है। यह दो argument लेता है: 'compiler' जो Compiler प्रकार का है और 'url' जो एक स्ट्रिंग है। यह 'url' से स्रोत मानचित्र प्राप्त करता है और इसे SourceMapConsumer ऑब्जेक्ट में परिवर्तित करता है। यदि मानचित्र नहीं मिलता है या मानचित्र अमान्य प्रारूप में होता है, तो यह null वापस करता है।"
  },
  {
    "id": "sample_52997",
    "language": "javascript",
    "length_bucket": "medium",
    "code": "function isArrayLike( value ) {\n\treturn (\n\t\tvalue !== void 0 &&\n\t\tvalue !== null &&\n\t\ttypeof value !== 'function' &&\n\t\tisInteger( value.length ) &&\n\t\tvalue.length >= 0 &&\n\t\tvalue.length <= MAX\n\t);\n}",
    "docstring": "IS ARRAY-LIKE // \nFUNCTION: isArrayLike( value )\nValidates if a value is array-like.\n\n@param {*} value - value to validate\n@param {Boolean} boolean indicating if a value is array-like",
    "model_name": "gemma-2-9b-it",
    "summary_english": "isArrayLike is a function that checks if a given value is array-like. It takes one argument, value, which can be of any type. The function returns true if the value is not undefined or null, is not a function, has a length property that is an integer and is within the range of 0 to MAX (a predefined constant). Otherwise, it returns false.",
    "summary_chinese": "isArrayLike 函数判断一个值是否类似数组。它接受一个值作为参数，并返回一个布尔值，指示该值是否类似数组。 \n\n参数：\n\nvalue (any)\n\n逻辑：\n\n函数首先检查值是否非空、非 null、非函数，并且其长度为整数且在 0 到 MAX 之间。如果所有条件都满足，则返回 true，否则返回 false。",
    "summary_french": "La fonction isArrayLike vérifie si une valeur est semblable à un tableau. Elle prend une valeur en argument de type quelconque. La fonction retourne vrai si la valeur n'est pas indéfinie, n'est pas nulle, n'est pas une fonction, si sa longueur est un entier, si sa longueur est supérieure ou égale à zéro et inférieure ou égale à MAX.",
    "summary_spanish": "La función isArrayLike determina si un valor es similar a un array. Recibe un argumento llamado 'value' de cualquier tipo.  Su lógica comprueba si el valor no es indefinido ni nulo, no es una función, si su longitud es un entero, y si la longitud es mayor o igual a 0 y menor o igual a MAX.  Si todas estas condiciones son verdaderas, la función devuelve true, de lo contrario devuelve false.",
    "summary_portuguese": "A função isArrayLike verifica se um valor é semelhante a um array. Ela recebe um argumento 'value' de qualquer tipo. A lógica da função é verificar se o valor não é indefinido, nulo, uma função, se seu comprimento é um inteiro, e se o comprimento está entre 0 e MAX.  Se todas essas condições forem verdadeiras, a função retorna true, caso contrário, retorna false.",
    "summary_arabic": "function isArrayLike  يقوم بفحص ما إذا كان القيمة تشبه مصفوفة. \n\nيحتاج إلى قيمة واحدة من نوع أي. \n\nيُحقق الشرط التالي: \nالقيمة ليست غير معرفة ولا تساوي null ولا هي دالة، ويجب أن يكون طول القيمة عدد صحيحًا، وأن يكون طولها أكبر من أو يساوي صفر وأقل من أو يساوي MAX. \n \nإذا تم تلبية جميع الشروط، يتم إرجاع قيمة true، وإلا يتم إرجاع false.",
    "summary_hindi": "isArrayLike नामक यह फ़ंक्शन किसी मान को ऐसी संरचना की जाँच करता है जो एक तरह से एक एरे जैसी व्यवहार करती है। यह फ़ंक्शन `value` नामक एक मान लेता है और यह जाँच करता है कि क्या यह `void 0` या `null` नहीं है, फ़ंक्शन नहीं है, इसका `length` एक पूर्णांक है, और यह `length` 0 से `MAX` के बीच है। यदि सभी शर्तें सत्य हैं, तो फ़ंक्शन `true` वापस करता है, अन्यथा `false` वापस करता है।"
  },
  {
    "id": "sample_52344",
    "language": "javascript",
    "length_bucket": "medium",
    "code": "function _removeSubscribersPerEvent(oEventsCallbacks, sChannelId, oSubscriber) {\n  let nUnsubscribed = 0;\n  iterateObject(oEventsCallbacks, function (oItem, sEvent) {\n    const aEventsParts = sEvent.split(':');\n    let sChannel = sChannelId;\n    let sEventType = sEvent;\n    if (aEventsParts[0] === 'global') {\n      sChannel = aEventsParts[0];\n      sEventType = aEventsParts[1];\n    }\n    nUnsubscribed += _removeSubscribers(oChannels[sChannel][sEventType], oSubscriber);\n  });\n  return nUnsubscribed;\n}",
    "docstring": "Loops per all the events to remove subscribers.\n@param {Object} oEventsCallbacks\n@param {String} sChannelId\n@param {Object} oSubscriber\n@return {Number}\n@private",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function _removeSubscribersPerEvent removes subscribers from event callbacks for a specific channel. It takes three arguments: oEventsCallbacks, which is an object containing event callbacks, sChannelId, which is the ID of the channel, and oSubscriber, which is the subscriber object. The function iterates through each event in the oEventsCallbacks object. For each event, it splits the event name into channel and event type parts. It then removes the subscriber from the list of subscribers for that channel and event type using the _removeSubscribers function. Finally, it returns the total number of subscribers removed.",
    "summary_chinese": "该函数名为 _removeSubscribersPerEvent，用于从事件回调对象中移除特定事件和通道的订阅者。它接受三个参数：oEventsCallbacks（事件回调对象）、sChannelId（通道ID）和oSubscriber（订阅者对象）。 \n\n函数首先初始化一个计数器nUnsubscribed，然后遍历事件回调对象。对于每个事件，它将事件名称拆分为通道和事件类型，并根据通道ID和事件类型从对应的订阅者列表中移除指定订阅者。最后，函数返回移除的订阅者数量。",
    "summary_french": "La fonction _removeSubscribersPerEvent supprime les abonnés pour un canal spécifique et un abonné donné. Elle prend en argument oEventsCallbacks, un objet contenant les callbacks d'événements, sChannelId, l'identifiant du canal, et oSubscriber, l'abonné à supprimer. La fonction parcourt chaque événement dans oEventsCallbacks et, pour chaque événement, elle vérifie si l'événement est lié au canal spécifié. Si c'est le cas, elle utilise la fonction _removeSubscribers pour supprimer l'abonné de la liste des abonnés de cet événement. La fonction retourne le nombre total d'abonnés supprimés.",
    "summary_spanish": "La función _removeSubscribersPerEvent elimina suscriptores de eventos específicos para un canal dado. Recibe como argumentos oEventsCallbacks (un objeto con callbacks de eventos), sChannelId (el ID del canal) y oSubscriber (el suscriptor a eliminar).  \n\nEl código itera sobre los callbacks de eventos en oEventsCallbacks. Para cada evento, divide el nombre del evento en partes (canal y tipo de evento). Luego, busca el suscriptor en la lista de suscriptores del canal y tipo de evento correspondiente y lo elimina. Finalmente, devuelve el número total de suscriptores eliminados.",
    "summary_portuguese": "A função _removeSubscribersPerEvent remove assinantes de eventos específicos para um canal. Ela recebe três argumentos: o objeto de callbacks de eventos, o ID do canal e o assinante a ser removido. A função itera sobre os callbacks de eventos, dividindo cada evento em canal e tipo de evento. Para cada evento, ela remove o assinante do conjunto de assinantes do canal e tipo de evento correspondente. A função retorna o número total de assinantes removidos.",
    "summary_arabic": "دالة _removeSubscribersPerEvent  تُستخدم لإزالة المشتركين من أحداث معينة لقناة محددة. \n\nتستقبل الدالة ثلاثة أُسْباب: \noEventsCallbacks:  مُعْرِف  بِمُعْرِفِ الوظائف التي تُنفّذ عند حدوث الأحداث.\nsChannelId:  اسم القناة التي تريد إزالة المشتركين منها.\noSubscriber:  مُعْرِف المشترك الذي تريد إزالته.\n\nتُنفّذ الدالة عملية بحث عن جميع الأحداث المُسجّلة في oEventsCallbacks  والتي تتعلّق بالقناة المحدّدة.  للكلّ حدث، يتمّ فحص اسم القناة واسم النوع.  إذا كان اسم القناة هو \"global\" ، يتمّ استخراج اسم القناة واسم النوع من أجزاء اسم الحدث.  ثمّ يتمّ استدعاء الدالة _removeSubscribers  لإزالة المشترك من قائمة المشتركين لهذا الحدث.  يتمّ حساب عدد المشتركين الذين تمّ إزالتهم ويتمّ إرجاع هذا الرقم.",
    "summary_hindi": "यह फ़ंक्शन _removeSubscribersPerEvent नाम का है। इसका उद्देश्य दिए गए चैनल आईडी और सब्सक्राइबर के लिए सभी इवेंट्स से सब्सक्रिप्शन को हटाना है। यह फ़ंक्शन `oEventsCallbacks`, `sChannelId` और `oSubscriber` नामक तीन एरग्यूमेंट्स लेता है। `oEventsCallbacks` इवेंट्स के लिए सब्सक्राइबर की जानकारी रखने वाला एक ऑब्जेक्ट है, `sChannelId` चैनल आईडी है और `oSubscriber` हटाने के लिए सब्सक्राइबर है। यह फ़ंक्शन `oEventsCallbacks` ऑब्जेक्ट में प्रत्येक इवेंट को इटरेट करता है और `_removeSubscribers` फ़ंक्शन का उपयोग करके दिए गए चैनल और इवेंट के लिए सब्सक्राइबर को हटाता है। अंत में, यह हटाए गए सब्सक्राइबर की संख्या लौटाता है।"
  },
  {
    "id": "sample_51707",
    "language": "javascript",
    "length_bucket": "medium",
    "code": "function () {\n                if (isSandboxVariableWiped) {\n                    return;\n                }\n\n                for (var i = 0, c = this[1].length, varItem; i < c; i++) {\n                    varItem = this[1][i];\n                    if (varItem[0] === 'sandbox') {\n                        isSandboxVariableWiped = true;\n                        this[1].splice(i, 1);\n\n                        return this;\n                    }\n                }\n            }",
    "docstring": "wipe sandobx variable",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function iterates through an array stored in the object's property at index 1. It checks if any element in the array starts with 'sandbox'. If found, it sets a flag 'isSandboxVariableWiped' to true, removes the element from the array, and returns the modified object. If no 'sandbox' element is found, the function does nothing and returns.",
    "summary_chinese": "该函数名为匿名函数，其目的是检查并删除名为“sandbox”的变量。它接受一个参数，类型为对象，该对象包含一个数组。函数首先检查一个名为isSandboxVariableWiped的变量，如果为真，则直接返回。然后，它遍历数组，如果找到名为“sandbox”的变量，则将其删除并设置isSandboxVariableWiped为真，最后返回自身。",
    "summary_french": "La fonction vérifie si une variable nommée 'sandbox' existe dans un tableau. Si elle est trouvée, la variable est supprimée du tableau et une variable globale 'isSandboxVariableWiped' est mise à true. La fonction retourne ensuite l'objet modifié. \n\n\nL'argument de la fonction est 'this', qui représente l'objet courant.",
    "summary_spanish": "La función busca eliminar una variable llamada 'sandbox' de un arreglo. Si la variable 'isSandboxVariableWiped' es verdadera, la función regresa. Si no, itera sobre cada elemento del arreglo, y si encuentra un elemento cuyo primer valor es 'sandbox', marca la variable 'isSandboxVariableWiped' como verdadera, elimina el elemento del arreglo y regresa la instancia actual de la función.",
    "summary_portuguese": "A função verifica se uma variável 'sandbox' existe em um array. Se encontrada, marca a variável como apagada e remove o elemento do array.  A função recebe um objeto como argumento. O objeto possui um atributo '1' que é um array.  A lógica percorre o array e, se encontrar um elemento cujo primeiro valor seja 'sandbox', marca a variável como apagada, remove o elemento do array e retorna o objeto modificado.",
    "summary_arabic": "function  يُقوم هذا الدالة بتحقق وجود متغير اسمه \"sandbox\" في مجموعة من البيانات. إذا وجد المتغير، يتم حذف المتغير من المجموعة وإعلام المتغيّر global  isSandboxVariableWiped  بأن المتغير قد تم حذفه.  \n\narguments: \nthis:  مجموعة من البيانات \n\nlogic: \n1. التحقق من قيمة المتغير global  isSandboxVariableWiped  إذا كان قيمته true يتم الخروج من الدالة.\n2.  تدوير حلقة على كل عنصر في المجموعة.\n3.  إذا وجد عنصر اسمه \"sandbox\" يتم حذف العنصر من المجموعة وإعلام المتغير global  isSandboxVariableWiped  بأن المتغير قد تم حذفه.\n4.  يتم إرجاع المجموعة المعدلة.",
    "summary_hindi": "यह फ़ंक्शन एक ऑब्जेक्ट पर चलेगा और उसमें 'sandbox' नामक एक विशेष तत्व की तलाश करेगा। यदि 'sandbox' तत्व पाया जाता है, तो यह तत्व हटा दिया जाएगा और एक वैरिएबल `isSandboxVariableWiped` को `true` पर सेट किया जाएगा।  इस फ़ंक्शन में कोई इनपुट आर्गुमेंट नहीं है।"
  },
  {
    "id": "sample_53144",
    "language": "javascript",
    "length_bucket": "medium",
    "code": "function iterateKeys(value, callback, accumulate) {\r\n    return isAsyncFunction(callback)\r\n        ? (async () => await iterate(value, async (row, key, iteration) => await callback(key, row, iteration), accumulate))()\r\n        : iterate(value, (row, key, iteration) => callback(key, row, iteration), accumulate);\r\n}",
    "docstring": "[[include: iterate-keys.md]]\n@param value\n@param callback\n@param accumulate",
    "model_name": "gemma-2-9b-it",
    "summary_english": "iterateKeys is a function that iterates over the keys of a value and executes a callback function for each key. It takes three arguments: value, a callback function, and an accumulate function. If the callback function is asynchronous, it uses an async/await pattern to iterate over the keys. Otherwise, it uses a synchronous iteration. The function returns the result of the accumulate function.",
    "summary_chinese": "iterateKeys 函数用于迭代对象中的键，并执行回调函数。它接受三个参数：value（要迭代的对象）、callback（一个回调函数，用于处理每个键和对应的值）、accumulate（一个可选参数，用于累积结果）。如果 callback 是一个异步函数，则使用异步迭代；否则使用同步迭代。迭代过程中，回调函数会为每个键和对应的值调用一次。",
    "summary_french": "La fonction `iterateKeys` permet d'itérer sur les clés d'un objet `value` en utilisant une fonction de rappel `callback`. Elle prend en argument `value` (l'objet à itérer), `callback` (une fonction qui sera appelée pour chaque clé) et `accumulate` (une fonction optionnelle pour accumuler les résultats). Si `callback` est une fonction asynchrone, elle utilise `iterate` avec une version asynchrone de la fonction de rappel. Sinon, elle utilise `iterate` avec la fonction de rappel synchrone.",
    "summary_spanish": "La función iterateKeys itera sobre las claves de un valor proporcionado, ejecutando una función de devolución de llamada para cada clave. Recibe tres argumentos: value (el valor a iterar), callback (una función que se ejecutará para cada clave), y accumulate (una función opcional para acumular resultados). Si callback es una función asíncrona, la función utiliza un bucle asíncrono para iterar sobre las claves. De lo contrario, utiliza un bucle normal.",
    "summary_portuguese": "A função iterateKeys itera sobre as chaves de um objeto ou array, executando uma função de callback para cada chave e valor. Ela recebe três argumentos: value, que é o objeto ou array a ser iterado; callback, uma função que será executada para cada chave e valor; e accumulate, uma função opcional para acumular o resultado da iteração. Se callback for uma função assíncrona, a função utiliza um loop assíncrono para iterar sobre os elementos. Caso contrário, utiliza um loop síncrono.",
    "summary_arabic": "دالة iterateKeys تقوم بتكرار مفاتيح قيمة معينة باستخدام دالة callback.  \nتستقبل الدالة قيمة، دالة callback، و خيارا accumulate. \nإذا كانت callback دالة أسنكريت، فإنها تقوم بتنفيذ دالة iterate بشكل أسنكريت. \nفي غير ذلك، تقوم بتنفيذ دالة iterate بشكل متزامن. \nدالة iterate تقوم بتكرار كل عنصر في القيمة وتدعى callback مع كل مفتاح، قيمة العنصر، وعدد الدورة.",
    "summary_hindi": "iterateKeys फ़ंक्शन किसी मान के लिए चाबियों पर इटरेट करता है और एक कॉलबैक फ़ंक्शन को प्रत्येक चाबी, मान और पुनरावृत्ति के साथ बुलाता है। यह फ़ंक्शन तीन मानों को लेता है: value (जिस पर इटरेट करना है), callback (एक फ़ंक्शन जो प्रत्येक चाबी, मान और पुनरावृत्ति के साथ बुलाया जाता है), और accumulate (एक फ़ंक्शन जो परिणामों को एकत्रित करता है)। यदि callback एक एसिंक्रोनस फ़ंक्शन है, तो यह एसिंक्रोनस रूप से इटरेट करता है; अन्यथा, यह सिंक्रोनस रूप से इटरेट करता है।"
  },
  {
    "id": "sample_49736",
    "language": "javascript",
    "length_bucket": "medium",
    "code": "function getId(payloadPiece, conf, path, fullPayload) {\n    if (isWhat.isString(payloadPiece))\n        return payloadPiece;\n    if (isWhat.isPlainObject(payloadPiece)) {\n        if ('id' in payloadPiece)\n            return payloadPiece.id;\n        var keys = Object.keys(payloadPiece);\n        if (keys.length === 1)\n            return keys[0];\n    }\n    return '';\n}",
    "docstring": "gets an ID from a single piece of payload.\n\n@export\n@param {(object | string)} payloadPiece\n@param {object} [conf] (optional - for error handling) the vuex-easy-access config\n@param {string} [path] (optional - for error handling) the path called\n@param {(object | any[] | string)} [fullPayload] (optional - for error handling) the full payload on which each was `getId()` called\n@returns {string} the id",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function getId extracts an 'id' from a given payload piece. It accepts four arguments: payloadPiece (any), conf (any), path (any), and fullPayload (any).  The function first checks if payloadPiece is a string, returning it directly if it is. If payloadPiece is an object, it checks if it has an 'id' property and returns it if found. If no 'id' is present, it checks if the object has only one key and returns that key. If none of these conditions are met, an empty string is returned.",
    "summary_chinese": "getId 函数用于从 payloadPiece 中提取 id。它接受四个参数：payloadPiece（类型为任何值）、conf（类型为对象）、path（类型为字符串）、fullPayload（类型为任何值）。 \n\n该函数首先检查 payloadPiece 是否为字符串，如果是，则直接返回 payloadPiece。 \n\n如果 payloadPiece 是一个对象，则检查它是否包含 'id' 属性，如果包含，则返回 'id' 属性的值。 \n\n如果 payloadPiece 是一个对象且只有一个属性，则返回该属性的名称。 \n\n否则，返回空字符串。",
    "summary_french": "La fonction getId extrait l'identifiant d'un élément à partir d'un payload. Elle prend en argument payloadPiece (de type string ou objet), conf (objet), path (string) et fullPayload (objet). Si payloadPiece est une chaîne de caractères, elle est retournée directement. Si c'est un objet, la fonction vérifie s'il contient une propriété 'id'. Si oui, l'id est retourné. Sinon, elle vérifie si l'objet ne contient qu'une seule clé et retourne cette clé. Dans tous les autres cas, une chaîne vide est retournée.",
    "summary_spanish": "La función getId busca un identificador (id) dentro de un fragmento de datos llamado payloadPiece. Recibe como argumentos payloadPiece (cualquier tipo), conf (no se utiliza), path (no se utiliza) y fullPayload (no se utiliza). Primero, verifica si payloadPiece es una cadena de texto, en cuyo caso lo devuelve directamente. Si es un objeto, busca una propiedad llamada 'id' y la devuelve. Si no encuentra 'id', revisa si el objeto tiene solo una clave y la devuelve como identificador. Si no encuentra ningún identificador válido, devuelve una cadena vacía.",
    "summary_portuguese": "A função getId busca um identificador (id) dentro de um dado fornecido. Ela recebe como argumentos: payloadPiece (o dado a ser analisado), conf (um objeto de configuração), path (uma string com o caminho para o id) e fullPayload (o payload completo). A função primeiro verifica se payloadPiece é uma string, caso seja, retorna a própria string. Se payloadPiece é um objeto, verifica se possui uma propriedade 'id' e, se sim, retorna o valor dessa propriedade. Caso contrário, verifica se o objeto possui apenas uma chave e, se sim, retorna o nome dessa chave. Se nenhuma dessas condições for satisfeita, a função retorna uma string vazia.",
    "summary_arabic": "function getId  تستخرج الرقم التعريف من قطعة البيانات المدخلة. \nيتقبل الدالة payloadPiece من نوع string أو object, conf من نوع object, path من نوع string, fullPayload من نوع object. \nإذا كانت payloadPiece عبارة عن سلسلة نصية، يتم إرجاعها مباشرة. \nإذا كانت payloadPiece عبارة عن كائن بسيط، يتم التحقق من وجود مفتاح \"id\" في الكائن، وإذا وجد يتم إرجاع قيمته. \nإذا لم يوجد مفتاح \"id\"، يتم التحقق من عدد المفاتيح في الكائن، وإذا كان عدد المفاتيح يساوي 1، يتم إرجاع المفتاح الوحيد. \nفي جميع الحالات الأخرى، يتم إرجاع سلسلة فارغة.",
    "summary_hindi": "getId नामक यह फ़ंक्शन किसी payload के अंदर 'id' की पहचान करने का काम करता है। यह payloadPiece, conf, path और fullPayload नामक चार argument लेता है।  यह पहले payloadPiece को जांचता है कि यह स्ट्रिंग है या नहीं। अगर हाँ, तो उसे ही वापस करता है। अगर नहीं, तो यह जांचता है कि क्या यह एक ऑब्जेक्ट है। अगर हाँ, तो यह ऑब्जेक्ट में 'id' की उपस्थिति की जांच करता है और अगर मिलता है तो उसे वापस करता है। अगर 'id' नहीं मिलता है, तो यह ऑब्जेक्ट में मौजूद केवल एक की की पहचान करता है और उसे वापस करता है। अगर कोई भी उपरोक्त स्थिति पूरी नहीं होती है, तो यह एक खाली स्ट्रिंग वापस करता है।"
  },
  {
    "id": "sample_51130",
    "language": "javascript",
    "length_bucket": "long",
    "code": "function AstNode(type, token) {\n  let _type = type;\n  let _token = token;\n  let _children = [];\n\n  this.getType = function getType() {\n    return _type;\n  };\n\n  this.getToken = function getToken() {\n    return _token;\n  };\n\n  this.getChildren = function getChildren() {\n    return _children;\n  };\n\n  this.setToken = function setToken(t) {\n    _token = t;\n  };\n\n  this.isLeaf = function isLeaf() {\n    return _children.length === 0;\n  };\n\n  this.addChild = function addChild(childNode) {\n    _children.push(childNode);\n  };\n\n  this.print = function print(nArg) {\n    let n = nArg;\n    if (!n) {\n      n = 0;\n    }\n    console.log(' '.repeat(n) + String(_type) + (_token ? (': ' + _token.value) : ''));\n    n += 1;\n    _children.forEach((child) => {\n      child.print(n);\n    });\n  };\n}",
    "docstring": "/*\nThis file is part of the lps.js project, released open source under\nthe BSD 3-Clause license. For more info, please see https://github.com/mauris/lps.js",
    "model_name": "gemma-2-9b-it",
    "summary_english": "AstNode is a class that represents a node in an abstract syntax tree. It takes a type and a token as arguments. It stores the type, token, and a list of child nodes. It provides methods to get and set the type, token, and children. It also has methods to check if the node is a leaf node, add a child node, and print the node and its children in a tree-like structure.",
    "summary_chinese": "AstNode 函数用于创建抽象语法树节点。它接受两个参数：type (类型) 和 token (令牌)。该函数定义了多种方法，包括获取节点类型、令牌、子节点、设置令牌、判断是否为叶子节点、添加子节点以及打印节点结构。打印方法会根据节点层次结构以缩进的方式输出节点信息。",
    "summary_french": "La fonction AstNode est un constructeur qui crée des nœuds d'un arbre syntaxique abstrait. Elle prend deux arguments : type, de type string, qui représente le type du nœud, et token, de type objet, qui représente le jeton associé au nœud. La fonction définit plusieurs méthodes pour accéder aux informations du nœud, modifier le jeton associé, vérifier si le nœud est une feuille, ajouter des enfants au nœud et imprimer l'arbre syntaxique.",
    "summary_spanish": "La función AstNode es un constructor para nodos en un árbol de análisis sintáctico. Recibe dos argumentos: type (string) que representa el tipo del nodo y token (objeto) que representa el token asociado al nodo.  \n\nLa función define varios métodos: \n\n* getType: devuelve el tipo del nodo.\n* getToken: devuelve el token asociado al nodo.\n* getChildren: devuelve una lista de los hijos del nodo.\n* setToken: establece un nuevo token para el nodo.\n* isLeaf: devuelve true si el nodo es una hoja (no tiene hijos), false en caso contrario.\n* addChild: agrega un nuevo nodo hijo al nodo actual.\n* print: imprime el árbol de análisis sintáctico de forma recursiva, con indentación.",
    "summary_portuguese": "A função AstNode é um construtor que cria nós de um árvore sintática abstrata (AST). Ela recebe dois argumentos: type, que define o tipo do nó, e token, que é um token associado ao nó. O nó armazena seu tipo, token, uma lista de filhos e métodos para acessar e manipular esses dados.  A lógica principal da função é inicializar as propriedades do nó e definir métodos para obter e definir o tipo, token, filhos e imprimir o nó na console.  O método addChild adiciona um nó filho à lista de filhos do nó atual. O método isLeaf verifica se o nó é uma folha (sem filhos). O método print imprime o nó e seus filhos em formato hierárquico na console.",
    "summary_arabic": "AstNode هو فئة تمثل عقدة في تمثيل جذرية لبرنامج. \nتستقبل عقدة AstNode نوعا ورمزًا. \nتحتوي على قائمة بنود أطفال. \nتقدم وظائف لطلب النوع، الرمز، قائمة الأبناء، وإضافة أطفال. \nتُستخدم وظيفة print لطباعة تمثيل جذرية للعقدة.",
    "summary_hindi": "AstNode नामक फ़ंक्शन एक एबस्ट्रेक्ट सिंटैक्स ट्री (AST) नोड का प्रतिनिधित्व करने के लिए एक क्लास बनाता है। यह नोड एक टाइप और एक टोकन से बना होता है और इसमें शाखाएँ (बच्चों) हो सकती हैं।  \n\nयह फ़ंक्शन `type` और `token` नामक दो मानों को लेता है। \n\nइस क्लास में `getType`, `getToken`, `getChildren`, `setToken`, `isLeaf`, `addChild` और `print` नामक कई फ़ंक्शन होते हैं। `getType` और `getToken` क्रमशः नोड का प्रकार और टोकन वापस करते हैं। `getChildren` नोड के बच्चों की एक सूची वापस करता है। `setToken` टोकन को बदलने के लिए उपयोग किया जाता है। `isLeaf` यह बताता है कि नोड एक लीव नोड है या नहीं। `addChild` एक बच्चे नोड को जोड़ता है। `print` नोड और उसके बच्चों को एक निश्चित स्तर पर प्रिंट करता है।"
  },
  {
    "id": "sample_49517",
    "language": "javascript",
    "length_bucket": "long",
    "code": "function initData(tx, data) {\n  if (data) {\n    if (typeof data === \"string\") {\n      data = to.buffer(data);\n    }\n    if (Buffer.isBuffer(data)) {\n      data = rlp.decode(data);\n    }\n    const self = tx;\n    if (Array.isArray(data)) {\n      if (data.length > tx._fields.length) {\n        throw new Error(\"wrong number of fields in data\");\n      }\n\n      // make sure all the items are buffers\n      data.forEach((d, i) => {\n        self[self._fields[i]] = ethUtil.toBuffer(d);\n      });\n    } else if ((typeof data === \"undefined\" ? \"undefined\" : typeof data) === \"object\") {\n      const keys = Object.keys(data);\n      tx._fields.forEach(function(field) {\n        if (keys.indexOf(field) !== -1) {\n          self[field] = data[field];\n        }\n        if (field === \"gasLimit\") {\n          if (keys.indexOf(\"gas\") !== -1) {\n            self[\"gas\"] = data[\"gas\"];\n          }\n        } else if (field === \"data\") {\n          if (keys.indexOf(\"input\") !== -1) {\n            self[\"input\"] = data[\"input\"];\n          }\n        }\n      });\n\n      // Set chainId value from the data, if it's there and the data didn't\n      // contain a `v` value with chainId in it already. If we do have a\n      // data.chainId value let's set the interval v value to it.\n      if (!tx._chainId && data && data.chainId != null) {\n        tx.raw[self._fields.indexOf(\"v\")] = tx._chainId = data.chainId || 0;\n      }\n    } else {\n      throw new Error(\"invalid data\");\n    }\n  }\n}",
    "docstring": "Parses the given data object and adds its properties to the given tx.\n@param {Transaction} tx\n@param {Object} [data]",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function initData initializes a transaction object (tx) with provided data. It accepts two arguments: tx, which is the transaction object, and data, which is the data to initialize the transaction with. \n\nThe function first checks if data is provided. If so, it ensures data is in a valid format (buffer or object). If data is an array, it populates the transaction fields with buffer values from the array. If data is an object, it maps object keys to transaction fields, handling special cases for \"gasLimit\" and \"data\". Finally, it sets the chainId value from the data if available. If the data format is invalid, it throws an error.",
    "summary_chinese": "initData 函数用于初始化交易数据。它接受两个参数：tx（交易对象）和 data（交易数据）。 \n\n如果 data 不为空，函数会根据 data 的类型进行处理：\n\n* 如果 data 是字符串，将其转换为 Buffer。\n* 如果 data 是 Buffer，将其解码为 RLP 数据。\n\n然后，函数会根据 data 的类型进行处理：\n\n* 如果 data 是数组，则将数组中的每个元素转换为 Buffer 并赋值给 tx 对象的相应字段。\n* 如果 data 是对象，则将对象中的键值对赋值给 tx 对象的相应字段。 \n\n如果 data 中包含 chainId 字段，则将其赋值给 tx 对象的 _chainId 属性。\n\n如果 data 类型不符合预期，则抛出错误。",
    "summary_french": "La fonction initData prend deux arguments : tx et data. Elle initialise les données d'une transaction tx à partir d'un objet data. Si data est une chaîne de caractères, elle est convertie en buffer. Si data est déjà un buffer, il est décodée en utilisant rlp.decode. Si data est un tableau, chaque élément est converti en buffer et assigné aux champs correspondants de la transaction. Si data est un objet, les champs de l'objet sont utilisés pour initialiser les champs de la transaction. La fonction vérifie également si la chaîne d'identification de la chaîne est fournie dans data et la définit si nécessaire. Si aucun des types de données ci-dessus n'est fourni, une erreur est levée.",
    "summary_spanish": "La función initData toma dos argumentos: tx y data. Su propósito es inicializar un objeto tx con datos proporcionados en data. Si data es un string, se convierte a un buffer. Si data es un buffer, se decodifica usando rlp. Si data es un array, se asume que contiene los valores para los campos de tx. Si data es un objeto, se asignan los valores de los campos del objeto a los campos correspondientes de tx. Si data no es ninguno de estos tipos, se lanza un error. La función también establece el valor de chainId de tx si se encuentra en data.",
    "summary_portuguese": "A função initData recebe dois argumentos: tx e data. O objetivo da função é inicializar os dados de uma transação (tx) com base nos dados fornecidos (data). \n\nSe data for fornecido, a função verifica o tipo de data. Se for uma string, converte-a para um buffer. Se for um buffer, decodifica-o usando o algoritmo RLP. \n\nEm seguida, a função verifica se data é um array ou um objeto. \n\nSe for um array, verifica se o número de elementos no array é igual ao número de campos na transação. Se for, converte cada elemento do array para um buffer e atribui-o aos campos correspondentes na transação. \n\nSe for um objeto, itera sobre os campos da transação e atribui os valores correspondentes do objeto aos campos da transação. \n\nSe data não for fornecido ou não for um array ou objeto válido, a função lança um erro.",
    "summary_arabic": "function initData  يُستخدم لتعيين بيانات  tx.  يتلقى  tx  و  data  كمدخلات.  إذا كان  data  محددًا، يتم التحقق من نوعه. إذا كان سلسلة، يتم تحويله إلى  Buffer.  إذا كان  Buffer، يتم فك تشفيرها باستخدام  rlp.  ثم يتم تعيين بيانات  data  في  tx  بناءً على نوعه.  إذا كان  data  مصفوفة، يتم تعيين كل عنصر في  tx  باستخدام  ethUtil.toBuffer.  إذا كان  data  مُعْجَم، يتم تعيين القيم في  tx  باستخدام  keys  من  data.  يتم أيضًا تعيين  chainId  من  data  في  tx  إذا كان موجودًا.  إذا كان  data  غير صحيح، يتم إلقاء خطأ.",
    "summary_hindi": "`initData` फ़ंक्शन एक ट्रांज़ैक्शन ऑब्जेक्ट को इनपुट डेटा से इनिटियलाइज़ करता है। यह `tx` (एक ट्रांज़ैक्शन ऑब्जेक्ट) और `data` (डेटा) दो एर्ग्यूमेंट्स लेता है। \n\nयदि `data` उपलब्ध है, तो यह डेटा को स्ट्रिंग से बफर में, और बफर से आरएलपी डिकोड में परिवर्तित करता है। फिर यह `data` को एक एरे या ऑब्जेक्ट के रूप में प्रोसेस करता है। \n\nयदि `data` एक एरे है, तो यह प्रत्येक आइटम को बफर में परिवर्तित करके ट्रांज़ैक्शन ऑब्जेक्ट के फ़ील्ड्स को सेट करता है। \n\nयदि `data` एक ऑब्जेक्ट है, तो यह ट्रांज़ैक्शन ऑब्जेक्ट के फ़ील्ड्स को ऑब्जेक्ट के की-वैल्यू पेयर से सेट करता है। \n\nयदि `data` इनमें से कोई भी प्रकार नहीं है, तो यह एक त्रुटि उत्पन्न करता है।"
  },
  {
    "id": "sample_52527",
    "language": "javascript",
    "length_bucket": "long",
    "code": "function(keyAt) {\n                var hi = (arr.length >> 1) - 1, lo = 0, i = (lo + hi) >> 1, val = arr[(i << 1) + 1];\n\n                if (keyAt > arr[(hi << 1) + 1] || keyAt < 0) {\n                  return;\n                }\n\n                while (true) {                    \n                  if (hi - lo <= 1) {\n                    if (i < hi) {\n                      return {\n                        block_no:     i,\n                        comp_offset:  arr[i <<= 1],\n                        comp_size:    arr[i + 2] - arr[i],\n                        decomp_offset:arr[i + 1],\n                        decomp_size:  arr[i + 3] - arr[i + 1]\n                      };\n                    } else {\n                      return;\n                    }\n                  }\n\n                  (keyAt < val)  ? hi = i : lo = i;\n                  i = (lo + hi) >> 1;\n                  val = arr[(i << 1) + 1];\n                }\n              }",
    "docstring": "Given offset of a keyword after decompression, return a record block info containing it, else undefined if not found.",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function searches for a specific key within a sorted array and returns information about the corresponding block. It takes a single argument, keyAt, of type number. The function first initializes variables to define the search range within the array. It then checks if the keyAt is within the valid range of the array. If not, it returns. The function then enters a loop that repeatedly narrows the search range by comparing the keyAt with the middle element of the current range. If the range is narrowed down to a single element, it returns information about the corresponding block.",
    "summary_chinese": "该函数名为 `function(keyAt)`, 用于在二叉树中查找指定位置的块信息。 \n\n参数：\n\n* keyAt:  查找位置的键值\n\n逻辑：\n\n函数首先计算二叉树的边界值，然后通过二分查找的方式，不断缩小查找范围。 \n\n如果查找位置超出树的范围，则返回空。 \n\n如果找到目标位置，则返回包含块号、压缩偏移量、压缩大小、解压缩偏移量和解压缩大小的结构体。",
    "summary_french": "La fonction recherche un élément dans un tableau trié. Elle prend un argument `keyAt` de type nombre représentant la valeur à rechercher. La fonction utilise une recherche binaire pour trouver l'élément. Si l'élément n'est pas trouvé, elle retourne null. Sinon, elle retourne un objet contenant des informations sur l'élément trouvé, telles que son numéro de bloc, son décalage de compression et sa taille.",
    "summary_spanish": "La función busca un elemento en un arreglo ordenado binariamente. Recibe un argumento `keyAt` que representa el valor a buscar.  El código realiza una búsqueda binaria en el arreglo `arr`. Si `keyAt` es mayor que el último elemento del arreglo o menor que 0, la función devuelve sin hacer nada. En caso contrario, la función itera hasta encontrar el elemento o reducir el rango de búsqueda a un solo elemento. Si se encuentra el elemento, devuelve información sobre su posición y tamaño en el arreglo.",
    "summary_portuguese": "A função busca um elemento em uma estrutura de dados binária. Ela recebe como argumento `keyAt`, que representa o valor a ser buscado. A lógica da função utiliza a busca binária para encontrar o índice do elemento desejado. Se o elemento não for encontrado, a função retorna nulo. Caso contrário, retorna um objeto contendo informações sobre o elemento encontrado, como o número do bloco, o offset de compressão e de descompressão, e o tamanho da compressão e descompressão.",
    "summary_arabic": "The function searches for a specific key within a sorted array. It takes a single argument, keyAt, which represents the value to search for. The function utilizes a binary search algorithm to efficiently locate the index of the key within the array. If the key is found, it returns an object containing information about the key's position and size within the array. If the key is not found, the function returns nothing.",
    "summary_hindi": "यह फ़ंक्शन `keyAt` नामक एक मान के लिए एक सरणी में एक ब्लॉक की तलाश करता है। यह सरणी में संग्रहीत ब्लॉक की जानकारी प्रदान करता है। \n\nयह फ़ंक्शन `keyAt` नामक एक मान लेता है जो तलाशे जाने वाले ब्लॉक की पहचान करता है।\n\nयदि `keyAt` सरणी के अंतिम मान से बड़ा या 0 से कम है, तो यह फ़ंक्शन कुछ नहीं लौटाता है। अन्यथा, यह एक द्विआधारी खोज का उपयोग करके सरणी में `keyAt` के लिए सबसे उपयुक्त ब्लॉक को खोजता है। \n\nयदि ब्लॉक पाया जाता है, तो यह फ़ंक्शन ब्लॉक की जानकारी, जैसे ब्लॉक नंबर, संपीड़न और विस्तारित ऑफसेट और आकार, एक ऑब्जेक्ट के रूप में लौटाता है।"
  },
  {
    "id": "sample_50967",
    "language": "javascript",
    "length_bucket": "long",
    "code": "function createAppChannel (app, key) {\n  assert(~['consumerChannel', 'publisherChannel'].indexOf(key),\n    'Channel key must be \"consumerChannel\" or \"publisherChannel\"')\n  assert(app.connection, 'Cannot create a channel without a connection')\n  assert(!app[key], 'Channel \"' + key + '\" already exists')\n\n  return co(function * () {\n    const channel =\n      app[key] =\n        yield app.connection.createChannel()\n\n    channel.__coworkersCloseHandler = module.exports.closeHandler.bind(null, app, key)\n    channel.__coworkersErrorHandler = module.exports.errorHandler.bind(null, app, key)\n    channel.once('close', channel.__coworkersCloseHandler)\n    channel.once('error', channel.__coworkersErrorHandler)\n    app.emit('channel:create', channel)\n\n    // attach special event to determine if a message has been confirmed\n    // this event is handled in context.js\n    if (key === 'consumerChannel') {\n      if (app.prefetchOpts) {\n        channel.prefetch(app.prefetchOpts.count, app.prefetchOpts.global)\n      }\n      wrap(channel, ['ack', 'nack'], function (fn, args) {\n        const message = args[0]\n        assert(!message.messageAcked, 'Messages cannot be acked/nacked more than once (will close channel)')\n\n        const ret = fn.apply(this, args)\n        message.messageAcked = true\n        return ret\n      })\n    }\n\n    return channel\n  })\n}",
    "docstring": "Create consumer or publisher RabbitMQ channel\n@param {String} key channel key {consumer, publisher}\n@return {Promise} channel promise",
    "model_name": "gemma-2-9b-it",
    "summary_english": "createAppChannel is a function that creates a RabbitMQ channel for an application. It takes two arguments: app, which is an object representing the application, and key, which is a string specifying the type of channel (\"consumerChannel\" or \"publisherChannel\"). The function first asserts that the channel key is valid and that the application has a connection. It then creates a new channel using the application's connection and assigns it to the app object. The function sets up event handlers for the channel's 'close' and 'error' events. It also emits a 'channel:create' event. If the channel type is 'consumerChannel', the function sets up a prefetch strategy and wraps the 'ack' and 'nack' methods to ensure that messages are not acked or nacked multiple times. Finally, the function returns a generator function that yields the created channel.",
    "summary_chinese": "createAppChannel 函数用于创建应用程序频道。它接受两个参数：app（应用程序对象）和 key（频道类型，可以是 \"consumerChannel\" 或 \"publisherChannel\"）。 \n\n该函数首先进行一些断言检查，确保 key 参数有效，app 对象有连接，并且指定的频道尚未存在。然后，它使用 co 函数生成一个协程，在协程中创建频道，并为频道添加关闭和错误处理程序。最后，它触发 \"channel:create\" 事件，并根据 key 参数设置消费者频道的预取选项和确认处理程序。",
    "summary_french": "La fonction `createAppChannel` crée un canal d'application. Elle prend deux arguments : `app` (un objet d'application) et `key` (une chaîne de caractères représentant le type de canal, soit \"consumerChannel\" ou \"publisherChannel\"). La fonction vérifie que le type de canal est valide et que l'application a une connexion. Si un canal du même type existe déjà, elle lève une erreur.  \n\nLa fonction utilise `co` pour créer un canal via la connexion de l'application. Elle ajoute des gestionnaires d'événements de fermeture et d'erreur au canal. Elle émet un événement \"channel:create\" lorsque le canal est créé. \n\nSi le type de canal est \"consumerChannel\", la fonction configure le pré-fetch et ajoute des wrappers aux événements 'ack' et 'nack' pour gérer l'état d'accusé de réception des messages. Enfin, elle retourne le canal créé.",
    "summary_spanish": "La función createAppChannel crea un canal de aplicación. Recibe dos argumentos: app (un objeto de aplicación) y key (una cadena que puede ser \"consumerChannel\" o \"publisherChannel\").  Primero, verifica que el valor de key sea válido y que la aplicación tenga una conexión. Luego, crea un nuevo canal utilizando la conexión de la aplicación y lo almacena en el objeto app.  Se añaden manejadores de eventos para cerrar y manejar errores del canal.  Finalmente, emite un evento 'channel:create' y configura el canal para manejar mensajes confirmados si key es \"consumerChannel\".",
    "summary_portuguese": "createAppChannel é uma função que cria um canal de aplicativo. Ela recebe dois argumentos: app, que é um objeto de aplicativo, e key, que é uma string que especifica o tipo de canal (\"consumerChannel\" ou \"publisherChannel\"). A função primeiro verifica se a chave do canal é válida e se o aplicativo possui uma conexão. Em seguida, cria um novo canal usando a conexão do aplicativo e o registra no objeto aplicativo. A função também define manipuladores de eventos para o canal, que são chamados quando o canal é fechado ou ocorre um erro. Se o tipo de canal for \"consumerChannel\", a função também configura o prefetch e adiciona um manipulador de eventos para mensagens confirmadas. Por fim, a função retorna o canal criado.",
    "summary_arabic": "function createAppChannel  يُنشئ قناة تطبيقية. يتلقى التطبيق ك引امين: app (التطبيق) و key (مفتاح القناة).  يُؤكد أن مفتاح القناة هو \"consumerChannel\" أو \"publisherChannel\" وأن التطبيق لديه اتصال.  يُؤكد أيضًا عدم وجود قناة بهذا المفتاح بالفعل.  \n\nيعود الدالة بوظيفة generator التي تقوم بإنشاء قناة جديدة باستخدام اتصال التطبيق.  تُضاف معالجات لخطأ وإغلاق القناة.  يُصدر التطبيق حدث \"channel:create\" عند إنشاء القناة.  \n\nإذا كان مفتاح القناة هو \"consumerChannel\" ، يتم تعيين عدد الاستلام المسبق (prefetch) إذا تم تعيينه في التطبيق.  يتم أيضًا إضافة طبقة لمعالجة الأحداث \"ack\" و \"nack\" لضمان عدم إعادة تأكيد الرسائل.",
    "summary_hindi": "createAppChannel फ़ंक्शन एक ऐप के लिए कंज्यूमर चैनल या पब्लिशर चैनल बनाता है। यह दो मान लेता है: app (एक ऐप ऑब्जेक्ट) और key (\"consumerChannel\" या \"publisherChannel\"). यह सुनिश्चित करता है कि ऐप में कनेक्शन हो और चैनल पहले से मौजूद न हो। फिर, यह एक नया चैनल बनाता है, इसे ऐप ऑब्जेक्ट में संग्रहीत करता है और चैनल के बंद होने और त्रुटि होने पर हैंडलर जोड़ता है।  यदि चैनल कंज्यूमर चैनल है, तो यह प्रीफेच विकल्पों को सेट करता है और एक्क और नैक कार्यक्षमताओं को संशोधित करता है ताकि यह सुनिश्चित हो सके कि संदेश केवल एक बार एक्क या नैक किए जाएं। अंत में, यह बनाए गए चैनल को वापस देता है।"
  },
  {
    "id": "sample_54210",
    "language": "javascript",
    "length_bucket": "long",
    "code": "function parseExpression(expr) {\n    var parentList = [];\n    var parsedTokenizedExpression = [];\n    var parsedExpression = '';\n    var testInvalidChar;\n\n    if (expr && expr.trim()) {\n      parsedExpression = expr.replace(/\\040/g, '');\n      testInvalidChar = /[^a-zA-Z0-9_&|!()_]/.test(parsedExpression); //valid characters\n\n      if (!testInvalidChar) {\n          var pos = '0';\n          var prevprev = '?';\n          var prev = '?';\n          var head = '';\n          var key = '';\n          var rbrackets = 0;\n          var tmpparent = '';\n          var tmpexpression = '';\n          \n          // parser rules:\n          //\n          // left hand side of rule determines the rule to apply to the current element of the expression:\n          //\n          //   first element of key indicates the position of the expression element being evaluated:\n          //    1 - first position\n          //    n - other position\n          //   second element of key represents the position before the previous position:\n          //    ? - don't care\n          //    & - logical AND\n          //    | - logical OR\n          //   third element of key represents the previous position on the expression:\n          //    ? - don't care\n          //    ( - opening parenthesis\n          //    # - alpha numeric characters and underscore\n          //    ) - closing parenthesis\n          //    ! - logical NOT\n          //\n          // right hand side of rule represents valid symbols for that key\n          //\n          // example:\n          //\n          //  parsing expression 'a&&b' (one position at a time):\n          //  \n          //  - 'a' element is evaluated by first rule:\n          //    key: 1st position, before previous and previous positions elements don't care\n          //    validation: any alpha numeric character or open parenthesis or underscore or NOT \n          //  - '&' element is evaluated by the third rule:\n          //    key: (any position but first, indiferent before previous element, any valid previous element)\n          //    validation: any alpha numeric character or closing parenthesis or underscore or AND or OR \n          //  - '&' element is evaluated by sixth rule:\n          //    key: any position but first, indiferent before previous element, OR previous element\n          //    validation: value has to be '&'\n          //  - 'b' element is evaluated by the seventh rule:\n          //    key: any position but first, '&' before previous element, '&' previous element\n          //    validation: any alpha numeric character or open parenthesis or underscore or NOT or opening parenthesis\n          //  \n          var rules = {\n            '1??': /[a-zA-Z0-9_(!]/,\n            'n?(': /[a-zA-Z0-9_(!]/,\n            'n?#': /[a-zA-Z0-9_)&|]/,\n            'n?!': /[a-zA-Z0-9_(]/,\n            'n?)': /[&|)]/,\n            'n?&': /[&]/,\n            'n&&': /[a-zA-Z0-9_(!]/,\n            'n&#': /[a-zA-Z0-9_)&|]/,\n            'n&(': /[a-zA-Z0-9_(!]/,\n            'n?|': /[|]/,\n            'n||': /[a-zA-Z0-9_(!]/,\n            'n|(': /[a-zA-Z0-9_(!]/,\n            'n|#': /[a-zA-Z0-9_)&|]/,\n            'n|&': /[]/,\n            'n&|': /[]/,\n          };\n\n          for (var i = 0; i < parsedExpression.length; i += 1) {\n            pos = (i === 0 ? '1' : 'n');\n            head = parsedExpression.charAt(i);\n            key = pos + prevprev + prev;\n\n            if (!rules[key].test(head)) {\n              err.code = 'InvalidCharacter';\n              err.message = 'failed dependency expression validation (invalid character at position ' + (i + 1) + ')'; \n              return err;\n            }\n\n            if (head === '(') {\n              rbrackets += 1;\n            }\n\n            if (head === ')') {\n              if (rbrackets <= 0) {\n                err.code = 'UnopenedParentheses';\n                err.message = 'failed dependency expression validation (unopened parenthesis)'; \n                return err;\n              } else {\n                rbrackets -= 1;\n              }\n            }\n\n            // last character\n            if (i === parsedExpression.length - 1) {\n              // ), # -> expression terminators\n              if (/[a-zA-Z0-9)]/.test(head)) {\n                if (rbrackets !== 0) {\n                  err.code = 'UnclosedParentheses';\n                  err.message = 'failed dependency expression validation (unclosed parenthesis)';\n                  return err;\n                }\n              } else {\n                err.code = 'InvalidTerminator';\n                err.message = 'failed dependency expression validation (invalid expression terminator)';\n                return err;\n              }\n            } else {\n              if (prev === '&' || prev === '|') {\n                prevprev = prev;\n              } else {\n                prevprev = '?'; // ? -> don't care\n              }\n\n              if (/[a-zA-Z0-9_]/.test(head)) {\n                prev = '#'; // # -> valid identifier character\n              } else {\n                prev = head;\n              }\n\n            }\n            \n            // handle parent list and tokenized expression\n            if (/[a-zA-Z0-9_]/.test(head)) {\n              \n              if (tmpexpression !== '') {\n                parsedTokenizedExpression.push(tmpexpression);\n                tmpexpression = '';\n              }\n              \n              if (parsedExpression.length === 1) {\n                if (id === head) {\n                  err.name = 'SelfDependency';\n                  err.message = 'failed dependency expression validation (agent self dependency)';\n                  return err;\n                } else {\n                  parentList.push(head); \n                  parsedTokenizedExpression.push(head);\n                }\n              } else {\n                if (i === parsedExpression.length - 1) {\n                  tmpparent = tmpparent + head;\n                  if (id === tmpparent) {\n                    err.name = 'SelfDependency';\n                    err.message = 'failed dependency expression validation (agent self dependency)';\n                    return err;\n                  } else {  \n                    parentList.push(tmpparent); \n                    parsedTokenizedExpression.push(tmpparent);\n                  }\n                } else {\n                  tmpparent = tmpparent + head;\n                }\n              }\n              \n            } else {\n              if (tmpparent !== '') {\n                if (id === tmpparent) {\n                  err.name = 'SelfDependency';\n                  err.message = 'failed dependency expression validation (agent self dependency)';\n                  return err;\n                } else {\n                  parentList.push(tmpparent);\n                  parsedTokenizedExpression.push(tmpparent);\n                  tmpparent = '';\n                }\n              }\n              tmpexpression = tmpexpression + head;\n              if (i === parsedExpression.length - 1) {\n                parsedTokenizedExpression.push(tmpexpression);\n              }\n            }\n          \n          }\n        expression = parsedExpression;\n        tokenizedExpression = parsedTokenizedExpression;\n        dependencies = arrayGetUniques(parentList); \n      } else {\n        err.name = 'InvalidExpression';\n        err.message = 'failed dependency expression validation (please use underscore, alphanumeric and logical chars)';\n        return err;\n      }\n    } else {\n      expression = '';\n      dependencies = []; \n      tokenizedExpression = [];\n    }\n\n  }",
    "docstring": "parses the dependency logical expression of each agent and populates the auxiliary structures used by the agency to control the flow of execution",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `parseExpression` validates and parses a dependency expression string. It accepts a single argument, `expr` of type string. \n\nThe function first removes whitespace from the input string and checks if it contains any invalid characters. If invalid characters are found, an error is returned. \n\nIf the input string is valid, the function iterates through each character, applying a set of rules to determine the structure of the expression. It handles parentheses, logical operators (AND, OR, NOT), and identifiers. The function builds a list of dependencies and a tokenized representation of the expression. \n\nFinally, the function returns the parsed expression, tokenized expression, and a list of unique dependencies. If the input string is empty or invalid, it returns empty values for the parsed expression, tokenized expression, and dependencies.",
    "summary_chinese": "parseExpression 函数解析一个表达式，检查其语法是否正确。 \n\n该函数接受一个字符串类型的表达式作为参数。\n\n如果表达式不为空且有效，函数会：\n\n1. 去除表达式中的空格。\n2. 检查表达式中是否包含无效字符。\n3. 如果表达式有效，则使用一系列规则解析表达式，并将其分解成一系列令牌。\n4. 识别表达式中的依赖项，并将其存储在一个数组中。\n\n如果表达式无效，函数会返回一个错误对象。",
    "summary_french": "La fonction `parseExpression` analyse une expression de dépendance. Elle prend une chaîne de caractères `expr` en argument. La fonction vérifie si l'expression est valide en utilisant un ensemble de règles. Si l'expression est valide, elle extrait les dépendances et les stocke dans la variable `dependencies`. Si l'expression est invalide, elle retourne une erreur.",
    "summary_spanish": "La función `parseExpression` analiza una expresión de dependencia. Toma una cadena `expr` como argumento, que representa la expresión de dependencia. \n\nLa función valida la expresión para asegurarse de que solo contiene caracteres válidos (alfanuméricos, guiones bajos, operadores lógicos y paréntesis). Si la expresión es válida, la función la tokeniza en una lista de tokens y extrae una lista de dependencias. \n\nSi la expresión es inválida, la función devuelve un objeto de error con un código de error y un mensaje de error.",
    "summary_portuguese": "The function `parseExpression` validates and parses a dependency expression string. It accepts a single argument, `expr`, which is the expression string to be parsed. The function first removes any whitespace from the expression and checks if it contains any invalid characters. If the expression is valid, it then parses the expression using a set of rules that define the allowed characters and their positions in the expression. The function returns an object containing the parsed expression, the tokenized expression, and an array of unique dependencies. If the expression is invalid, the function returns an error object.",
    "summary_arabic": "The function `parseExpression` takes a string `expr` as input and validates it as a dependency expression. It checks for valid characters, parentheses balance, and logical operators. \n\nThe function returns an array of unique dependencies extracted from the expression. \n\nThe function uses a set of rules to parse the expression character by character. Each rule defines a pattern for a specific position in the expression and the allowed characters at that position.",
    "summary_hindi": "parseExpression फ़ंक्शन एक व्यंजक को पार्स करने के लिए डिज़ाइन किया गया है। यह एक व्यंजक स्ट्रिंग को लेता है और मान्यता प्राप्त प्रारूप में विभाजित करता है। \n\n**आर्गुमेंट:**\n\nexpr (स्ट्रिंग) - पार्स करने के लिए व्यंजक\n\n**लॉजिक:**\n\n1.  अगर व्यंजक वैध है और खाली नहीं है, तो यह इसे स्पेस से साफ़ करता है और अक्षरों, संख्याओं, अंडरस्कोर, और तार्किक संचालकों के अलावा अन्य वर्णों की जाँच करता है।\n2.  अगर व्यंजक वैध है, तो यह एक सेट नियमों का उपयोग करके व्यंजक को टोकन में विभाजित करता है।\n3.  यह सुनिश्चित करता है कि सभी खुले और बंद समूहों का सही क्रम है।\n4.  यह टोकन को एक सूची में संग्रहीत करता है और अद्वितीय निर्भरताओं की एक सूची देता है।\n5.  अगर व्यंजक अमान्य है, तो यह एक त्रुटि कोड और संदेश लौटाता है।"
  },
  {
    "id": "sample_49104",
    "language": "javascript",
    "length_bucket": "long",
    "code": "function encodeName(name) {\n    var littleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (typeof name !== \"string\") throw new TypeError(\"name parameter is a required string\");\n\n    if (name.length > 13) throw new TypeError(\"A name can be up to 13 characters long\");\n\n    var bitstr = \"\";\n    for (var i = 0; i <= 12; i++) {\n        // process all 64 bits (even if name is short)\n        var c = i < name.length ? charidx(name[i]) : 0;\n        var bitlen = i < 12 ? 5 : 4;\n        var bits = Number(c).toString(2);\n        if (bits.length > bitlen) {\n            throw new TypeError(\"Invalid name \" + name);\n        }\n        bits = \"0\".repeat(bitlen - bits.length) + bits;\n        bitstr += bits;\n    }\n\n    var value = Long.fromString(bitstr, true, 2);\n\n    // convert to LITTLE_ENDIAN\n    var leHex = \"\";\n    var bytes = littleEndian ? value.toBytesLE() : value.toBytesBE();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = (0, _getIterator3.default)(bytes), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var b = _step.value;\n\n            var n = Number(b).toString(16);\n            leHex += (n.length === 1 ? \"0\" : \"\") + n;\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n\n    var ulName = Long.fromString(leHex, true, 16).toString();\n\n    // console.log('encodeName', name, value.toString(), ulName.toString(), JSON.stringify(bitstr.split(/(.....)/).slice(1)))\n    return ulName.toString();\n}",
    "docstring": "Original Name encode and decode logic is in github.com/eosio/eos  native.hpp \nEncode a name (a base32 string) to a number.\n\nFor performance reasons, the blockchain uses the numerical encoding of strings\nfor very common types like account names.\n\n@see types.hpp string_to_name\n\n@arg {string} name - A string to encode, up to 12 characters long.\n@return {string<uint64>} - compressed string (from name arg).  A string is\nalways used because a number could exceed JavaScript's 52 bit limit.",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `encodeName` encodes a given name into a unique numerical representation. It takes a `name` string as the first argument and an optional `littleEndian` boolean as the second argument, defaulting to `true`. \n\nThe function first validates the input name, ensuring it's a string and no longer than 13 characters. It then converts each character of the name into its binary representation, padding shorter representations with leading zeros. These binary strings are concatenated to form a single binary string. This binary string is then converted into a Long integer. \n\nFinally, the Long integer is converted to its hexadecimal representation in little-endian byte order. This hexadecimal representation is then converted back into a string and returned as the encoded name.",
    "summary_chinese": "encodeName 函数用于将一个字符串类型的姓名编码成一个长整数，并将其转换为十六进制字符串。 \n\n参数：\n\nname: string, 姓名字符串\n\nlittleEndian: boolean, 是否使用小端序 (可选，默认值为 true)\n\n逻辑：\n\n1. 检查输入参数的类型和长度。\n2. 将姓名字符串转换为二进制字符串，每个字符对应 5 或 4 位。\n3. 将二进制字符串转换为 Long 类型。\n4. 将 Long 类型转换为十六进制字符串，并根据 littleEndian 参数选择小端序或大端序。\n5. 返回十六进制字符串。",
    "summary_french": "La fonction encodeName prend un nom en chaîne de caractères comme argument et retourne un identifiant numérique encodé. Elle vérifie que le nom est une chaîne de caractères et qu'il ne dépasse pas 13 caractères. Ensuite, elle convertit chaque caractère du nom en bits et les concatène en une chaîne de bits. Cette chaîne de bits est ensuite convertie en un nombre entier Long. Le nombre entier est converti en une représentation hexadécimale en utilisant le format little-endian. Enfin, la représentation hexadécimale est convertie en une chaîne de caractères et retournée.",
    "summary_spanish": "La función encodeName codifica un nombre en un formato de número largo. Recibe un argumento obligatorio, name, que es una cadena, y un argumento opcional, littleEndian, que es un booleano y por defecto es true. La función primero verifica que el nombre sea una cadena y que tenga una longitud máxima de 13 caracteres. Luego, convierte cada carácter del nombre en un número binario de 5 o 4 bits, dependiendo de la posición del carácter. Estos bits se concatenan para formar una cadena binaria que se convierte en un número largo. El número largo se convierte a bytes en el orden especificado por littleEndian y luego a una cadena hexadecimal. Finalmente, la cadena hexadecimal se convierte en un número largo y se devuelve como una cadena.",
    "summary_portuguese": "The function `encodeName` encodes a given name into a unique numerical representation. It takes a `name` string as its first argument and an optional `littleEndian` boolean as the second argument, defaulting to `true`. \n\nThe function first validates the input name, ensuring it's a string and no longer than 13 characters. It then converts each character of the name into its binary representation, padding shorter representations with zeros. These binary strings are concatenated to form a single binary string.\n\nThis binary string is then converted into a Long integer. The function then converts this integer into its hexadecimal representation in little-endian byte order. Finally, it converts the hexadecimal representation back into a string and returns it.",
    "summary_arabic": "encodeName is a function that encodes a name into a unique numerical representation. It takes a name string as its first argument and an optional boolean argument littleEndian, which defaults to true. The function first checks if the input name is a string and if its length is within the allowed limit (13 characters). It then converts each character of the name into its binary representation and concatenates these binary strings. The resulting binary string is then converted into a Long integer. Finally, the function converts the Long integer into its hexadecimal representation in little-endian order and returns the resulting string.",
    "summary_hindi": "encodeName नामक फ़ंक्शन एक नाम को 64-बिट लॉन्ग इंटीजर में एन्कोड करता है। यह नाम एक स्ट्रिंग मान लेता है और एक बूलियन मान लेता है जो लिटिल-एंडियन ऑर्डर का निर्धारण करता है। \n\nयह फ़ंक्शन नाम को 13 वर्णों तक सीमित करता है और प्रत्येक वर्ण को 5 या 4 बिट्स में परिवर्तित करता है। सभी 64 बिट्स को संभालने के लिए, यदि नाम छोटा है तो शेष बिट्स 0 से भरे जाते हैं। \n\nबिट्स को एक स्ट्रिंग में जोड़ा जाता है और इसे एक लॉन्ग इंटीजर में परिवर्तित किया जाता है। फिर, लॉन्ग इंटीजर को लिटिल-एंडियन या बड़ा-एंडियन ऑर्डर में बाइट्स में परिवर्तित किया जाता है और प्रत्येक बाइट को 16-हेक्स में परिवर्तित किया जाता है। अंत में, सभी 16-हेक्स मानों को मिलाकर एक स्ट्रिंग लौटाया जाता है।"
  },
  {
    "id": "sample_51229",
    "language": "javascript",
    "length_bucket": "long",
    "code": "function Iconic() {\n    // default path\n    var assetPath = 'assets/img/iconic/';\n\n    /**\n     * Sets the path used to locate the iconic SVG files\n     * @param {string} path - the base path used to locate the iconic SVG files\n     */\n    this.setAssetPath = function (path) {\n      assetPath = angular.isString(path) ? path : assetPath;\n    };\n\n    /**\n     * Service implementation\n     * @returns {{}}\n     */\n    this.$get = function () {\n      var iconicObject = new IconicJS();\n\n      var service = {\n        getAccess: getAccess,\n        getAssetPath: getAssetPath\n      };\n\n      return service;\n\n      /**\n       *\n       * @returns {Window.IconicJS}\n       */\n      function getAccess() {\n        return iconicObject;\n      }\n\n      /**\n       *\n       * @returns {string}\n       */\n      function getAssetPath() {\n        return assetPath;\n      }\n    };\n  }",
    "docstring": "iconic wrapper",
    "model_name": "gemma-2-9b-it",
    "summary_english": "Iconic is a service that provides access to IconicJS, a library for working with SVG icons. It takes a path argument to specify the location of the SVG files. The service exposes two functions: getAccess, which returns an instance of IconicJS, and getAssetPath, which returns the path to the SVG files.",
    "summary_chinese": "Iconic 函数是一个 Angular 服务，用于管理图标 SVG 文件的路径。它接受一个可选的路径参数，用于指定图标 SVG 文件的存储位置。如果未提供路径，则使用默认路径 'assets/img/iconic/'.  该服务提供两个方法：getAccess 返回 IconicJS 对象，getAssetPath 返回当前的图标 SVG 文件路径。",
    "summary_french": "La fonction Iconic est un service Angular qui permet d'accéder à des fichiers SVG d'icônes. Elle prend un argument optionnel, path, qui est une chaîne de caractères représentant le chemin d'accès aux fichiers SVG. La fonction définit un chemin par défaut 'assets/img/iconic/'. Elle retourne un objet contenant deux fonctions : getAccess qui retourne l'instance de IconicJS et getAssetPath qui retourne le chemin d'accès aux fichiers SVG.",
    "summary_spanish": "La función Iconic es un servicio Angular que proporciona acceso a archivos SVG del conjunto de iconos IconicJS.  \n\nAcepta un argumento opcional:\n\n* path (string): Ruta base para localizar los archivos SVG.\n\nLa lógica principal de la función es:\n\n1. Define una ruta predeterminada para los archivos SVG.\n2. Ofrece un método setAssetPath para cambiar la ruta.\n3. Crea una instancia de IconicJS.\n4. Define un objeto de servicio con métodos para acceder a la instancia de IconicJS y a la ruta de los archivos SVG. \n5. Devuelve el objeto de servicio.",
    "summary_portuguese": "A função Iconic é um serviço Angular que fornece acesso a ícones SVG. Ela define um caminho padrão para os arquivos SVG e permite que o usuário defina um caminho personalizado. A função $get retorna um objeto com métodos para acessar o objeto IconicJS e o caminho dos ativos.  O método getAccess retorna o objeto IconicJS, enquanto o método getAssetPath retorna o caminho dos ativos.",
    "summary_arabic": "Iconic هي دالة تقوم بإنشاء خدمة IconicJS.  تستقبل دالة IconicJS  引數 واحد من نوع string  يسمى path  ويستخدم لتحديد المسار الذي يتم استخدامه للوصول إلى ملفات SVG Iconic.  تحتوي الدالة على وظيفتين: getAccess  التي تعيد  IconicJS  و getAssetPath  التي تعيد المسار الحالي للملفات SVG.",
    "summary_hindi": "Iconic नामक एक फ़ंक्शन है जो आइकॉनिक SVG फ़ाइलों के लिए एक पथ सेट करने और एक सेवा प्रदान करने के लिए डिज़ाइन किया गया है। यह फ़ंक्शन `setAssetPath` नामक एक फ़ंक्शन लेता है जो एक स्ट्रिंग प्रकार का मान लेता है और यह आइकॉनिक SVG फ़ाइलों के लिए उपयोग किए जाने वाले आधार पथ को सेट करता है।  `$get` फ़ंक्शन एक `IconicJS` ऑब्जेक्ट बनाता है और `getAccess` और `getAssetPath` नामक दो फ़ंक्शन लौटाता है। `getAccess` फ़ंक्शन `IconicJS` ऑब्जेक्ट को लौटाता है, जबकि `getAssetPath` फ़ंक्शन आइकॉनिक SVG फ़ाइलों के लिए उपयोग किए जाने वाले आधार पथ को लौटाता है।"
  },
  {
    "id": "sample_54600",
    "language": "javascript",
    "length_bucket": "long",
    "code": "function(data, target) {\n      //Keys which we will exclude from the dataMap\n      const excludeKeys = self.initRun ? [] : ['option', 'query', 'shorthand', 'mixin'];\n      self.initRun = false;\n      //data map struc to be popultated\n      const emptyDataMap = Immutable.Map({\n        static: Immutable.OrderedMap(),\n        obj: Immutable.OrderedMap()\n      });\n\n      //check for use keywork, if false we don't use the data\n      data = self.doNotUse(data);\n      if (!data) {\n        return {\n          emptyDataMap,\n          target\n        };\n      }\n\n      //we need to map out the raw objects into two maps, obj and staic\n      const dataMap = _.reduce(data, function (map, val, key) {\n        const addTo = _.isPlainObject(val) ? 'obj' : 'static';\n        if (!_.includes(excludeKeys, key)) {\n          return map.update(addTo, function (m) {\n            return m.set(key, val);\n          });\n        }\n        return map;\n      }, emptyDataMap);\n\n      return {\n        dataMap,\n        target\n      };\n    }",
    "docstring": "config data",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function processes data and a target value. It excludes certain keys ('option', 'query', 'shorthand', 'mixin') from the data map unless it's the first run. It checks if the data should be used and returns an empty data map and target if not. Otherwise, it maps the raw objects into two maps, 'obj' and 'static', based on whether the value is a plain object.  It excludes keys specified in the 'excludeKeys' array. Finally, it returns the populated data map and the target value. \n\n\nThe function takes two arguments:\n\n* data: an object\n* target: a value",
    "summary_chinese": "该函数名为 `function(data, target)`, 它的目的是将输入数据 `data` 映射到两个 Immutable OrderedMap 中，分别为 `obj` 和 `static`。 \n\n参数：\n\n* `data`: 需要映射的数据，可以是对象或数组。\n* `target`: 目标值，用途不明。\n\n逻辑：\n\n1. 首先，根据 `self.initRun` 的值，确定需要排除的键 `excludeKeys`。\n2. 然后，调用 `self.doNotUse(data)` 检查是否需要使用数据，如果不需要，则直接返回 `emptyDataMap` 和 `target`。\n3. 否则，使用 `_.reduce` 函数遍历数据 `data`，将每个键值对映射到 `obj` 或 `static` 中。\n4. 如果键不在 `excludeKeys` 中，则将键值对添加到对应的 `OrderedMap` 中。\n5. 最后，返回包含映射后的数据 `dataMap` 和 `target` 的对象。",
    "summary_french": "La fonction traite un ensemble de données et un paramètre cible. Elle exclut certaines clés du jeu de données avant de les organiser en deux cartes immuables : 'obj' pour les objets plats et 'static' pour les valeurs non-objets. Si le paramètre 'data' est invalide, la fonction retourne une carte vide et le paramètre cible. Sinon, elle retourne la carte organisée et le paramètre cible. \n\n\nArguments:\ndata: un objet contenant les données à traiter\ntarget: un paramètre cible\n\nLogique clé:\n1. Exclure certaines clés du jeu de données.\n2. Vérifier si les données sont valides.\n3. Réduire les données en deux cartes immuables en fonction du type de valeur.\n4. Retourner les cartes organisées et le paramètre cible.",
    "summary_spanish": "La función procesa datos y los organiza en dos mapas, 'obj' y 'static'.  Recibe dos argumentos: 'data' (un objeto) y 'target' (un valor desconocido). Primero, identifica las claves que se excluyen del mapeo. Luego, verifica si se debe usar el 'data' y, si no, devuelve un objeto vacío. Si se usa el 'data', recorre cada clave-valor del objeto y determina si se debe agregar a 'obj' o 'static' según su tipo. Las claves excluidas se ignoran. Finalmente, devuelve un objeto con los mapas 'dataMap' (que contiene los datos organizados) y 'target'.",
    "summary_portuguese": "A função processa dados e os organiza em dois mapas, 'obj' e 'static'. Ela recebe dois argumentos: 'data', que contém os dados brutos, e 'target', que não é utilizado na lógica da função. A função exclui algumas chaves específicas dos dados antes de organizá-los nos mapas. Se os dados forem inválidos, a função retorna um objeto com os mapas vazios e o valor de 'target'. Caso contrário, a função retorna um objeto com os mapas preenchidos com os dados processados e o valor de 'target'.",
    "summary_arabic": "function(data, target)  \nيُستخدم هذا الدالة لمعالجة بيانات المدخلات وتنظيمها في خريطة بيانات. \narguments:\ndata:  بيانات المدخلات.\ntarget:  الهدف.\nlogic:\n1. تحدد قائمة المفاتيح التي يجب استبعادها من خريطة البيانات.\n2.  تُنشئ خريطة بيانات فارغة.\n3.  تُفحص البيانات للتأكد من أنها صالحة للاستخدام.\n4.  تُستخدم دالة _.reduce لتمرير البيانات وتجميعها في خريطة بيانات.\n5.  تُقسّم البيانات إلى قسمين: 'obj' و 'static' بناءً على نوعها.\n6.  تُستبعد المفاتيح المحددة من الخريطة.\n7.  تُرجَع خريطة البيانات المحسنة والهدف.",
    "summary_hindi": "यह फ़ंक्शन `data` और `target` दो मानों को लेता है। इसका उद्देश्य `data` को दो अलग-अलग मानचित्रों में विभाजित करना है: 'obj' और 'static'।  'obj' मानचित्र में साधारण वस्तुएँ और 'static' मानचित्र में अन्य प्रकार के डेटा संग्रहीत किए जाते हैं। कुछ विशिष्ट कुंजी ('option', 'query', 'shorthand', 'mixin') को छोड़ दिया जाता है।  यदि `data` खाली है या उपयोग नहीं किया जाना चाहिए, तो फ़ंक्शन एक खाली मानचित्र और `target` मान वापस करता है। अन्यथा, यह विभाजित मानचित्र और `target` मान वापस करता है।"
  },
  {
    "id": "sample_54632",
    "language": "javascript",
    "length_bucket": "long",
    "code": "function(prop, value) {\n        var me = this,\n            dom = me.dom,\n            hooks = me.styleHooks,\n            style = dom.style,\n            valueFrom = Ext.valueFrom,\n            name, hook;\n\n        // we don't promote the 2-arg form to object-form to avoid the overhead...\n        if (typeof prop == 'string') {\n            hook = hooks[prop];\n\n            if (!hook) {\n                hooks[prop] = hook = { name: Ext.dom.Element.normalize(prop) };\n            }\n            value = valueFrom(value, '');\n\n            if (hook.set) {\n                hook.set(dom, value, me);\n            } else {\n                style[hook.name] = value;\n            }\n        }\n        else {\n            for (name in prop) {\n                if (prop.hasOwnProperty(name)) {\n                    hook = hooks[name];\n\n                    if (!hook) {\n                        hooks[name] = hook = { name: Ext.dom.Element.normalize(name) };\n                    }\n\n                    value = valueFrom(prop[name], '');\n\n                    if (hook.set) {\n                        hook.set(dom, value, me);\n                    }\n                    else {\n                        style[hook.name] = value;\n                    }\n                }\n            }\n        }\n\n        return me;\n    }",
    "docstring": "Wrapper for setting style properties, also takes single object parameter of multiple styles.\n@param {String/Object} property The style property to be set, or an object of multiple styles.\n@param {String} [value] The value to apply to the given property, or `null` if an object was passed.\n@return {Ext.dom.Element} this",
    "model_name": "gemma-2-9b-it",
    "summary_english": "This function sets CSS styles on an element. It takes two arguments: 'prop' which can be a string representing a single style property or an object containing multiple style properties, and 'value' which is the value to set for the property. If 'prop' is a string, it looks up a corresponding style hook in the 'hooks' object. If a hook exists and has a 'set' method, it calls the method to set the style. Otherwise, it directly sets the style on the element's style object. If 'prop' is an object, it iterates through the properties and applies the same logic.  Finally, it returns the element object.",
    "summary_chinese": "该函数名为 `function(prop, value)`，用于设置 DOM 元素的样式。它接受两个参数：`prop`，表示样式属性名，类型为字符串或对象；`value`，表示样式值，类型为任何值。函数首先检查 `prop` 的类型，如果是字符串，则直接设置对应的样式属性值；如果是对象，则遍历对象中的每个属性，并依次设置对应的样式属性值。",
    "summary_french": "Cette fonction permet de définir les styles d'un élément DOM. Elle prend deux arguments : `prop` qui peut être une chaîne de caractères représentant le nom d'une propriété de style ou un objet contenant plusieurs propriétés de style, et `value` qui représente la valeur de la propriété de style. La fonction parcourt les propriétés de `prop` et utilise un tableau interne `hooks` pour trouver la méthode appropriée pour définir la propriété de style. Si une méthode `set` est définie pour la propriété, elle est appelée. Sinon, la propriété de style est définie directement sur l'élément DOM. La fonction retourne l'instance courante.",
    "summary_spanish": "La función establece estilos en un elemento DOM. Recibe dos argumentos: `prop`, que puede ser una cadena con el nombre de un estilo o un objeto con múltiples estilos, y `value`, que es el valor del estilo. Si `prop` es una cadena, busca un hook asociado al nombre del estilo en el objeto `hooks`. Si el hook existe y tiene un método `set`, se llama al método con el elemento DOM, el valor del estilo y el objeto `me`. De lo contrario, se establece el estilo directamente en el elemento DOM. Si `prop` es un objeto, se itera sobre cada propiedad del objeto y se realiza el mismo proceso. Finalmente, la función devuelve el objeto `me`.",
    "summary_portuguese": "A função define estilos para um elemento DOM. Aceita dois argumentos: um objeto com propriedades de estilo ou uma string com o nome de uma propriedade de estilo e seu valor. Se for uma string, procura um hook correspondente em um mapa de hooks de estilo. Se o hook tiver um método set, ele é chamado para definir o estilo. Caso contrário, o estilo é definido diretamente na propriedade do objeto style. Se for um objeto, itera sobre as propriedades e aplica o mesmo processo.",
    "summary_arabic": "This function is used to set CSS styles for an HTML element. It takes two arguments: 'prop' which can be a string representing a single CSS property or an object containing multiple CSS properties, and 'value' which is the value to set for the property. \n\nThe function first checks if 'prop' is a string. If it is, it looks up a corresponding style hook in the 'hooks' object. If the hook exists, it calls the hook's 'set' method to apply the style. Otherwise, it directly sets the style using the element's 'style' object.\n\nIf 'prop' is an object, the function iterates over each property in the object and applies the same logic as above. \n\nFinally, the function returns the current element.",
    "summary_hindi": "यह फ़ंक्शन किसी DOM तत्व के स्टाइल को सेट करने के लिए उपयोग किया जाता है। यह दो प्रकार के इनपुट ले सकता है: एक स्ट्रिंग जो स्टाइल प्रॉपर्टी का नाम है और एक मान, या एक ऑब्जेक्ट जिसमें स्टाइल प्रॉपर्टी और उनके मान दिए गए हैं। \n\nयह फ़ंक्शन पहले से परिभाषित स्टाइल हुक्स का उपयोग करता है जो विशिष्ट स्टाइल प्रॉपर्टी को सेट करने के लिए अलग-अलग फ़ंक्शन प्रदान करते हैं। यदि हुक उपलब्ध है, तो यह हुक का सेट फ़ंक्शन कॉल करता है; अन्यथा, यह स्टाइल प्रॉपर्टी को सीधे DOM तत्व के स्टाइल ऑब्जेक्ट में सेट करता है।"
  },
  {
    "id": "sample_51983",
    "language": "javascript",
    "length_bucket": "long",
    "code": "function configureLanProxy(options, config, done) {\n  var portfinder = require('portfinder'),\n      request = require('request'),\n      credentials = config.proxy.gateway.auth,\n      gatewayPort,\n      expectedAuthorizationHeader,\n      requestViaHeader,\n      responseViaHeader;\n\n  handles = handles || {};\n\n  handles.gatewayServer = require('http').createServer(function (req, res) {\n    expectedAuthorizationHeader = 'Basic ' + new Buffer(credentials).toString('base64');\n\n    // HACK: node 0.12.x appears to inject a slash at the front\n    //       of absolute URLs\n    //       ex., GET http://www.example.com --> GET /http://www.exampel.com\n    if (req.url.charAt(0) === '/') {\n      req.url = req.url.substr(1);\n    }\n\n    // validate the proxy target\n    if (req.url !== req.headers['x-forwarded-url']) {\n        res.writeHead(500);\n        res.end('{ \"error\": 500, \"message\": \"invalid proxy request, expected X-Forwarded-Url header ' + req.headers['x-forwarded-url'] + '\" }');\n        return;\n    }\n\n    // validate the proxy credentials\n    if (req.headers['authorization'] !== expectedAuthorizationHeader) {\n      res.writeHead(401);\n      res.end('{ \"error\": 401, \"message\": \"invalid proxy credentials, expected ' + expectedAuthorizationHeader + '\" }');\n      return;\n    }\n\n    // determine if we are using a proxy that is not RFC compliant\n    requestViaHeader = options.headers['Via'] ||\n                        '127.0.0.1:' + handles.port;\n\n    responseHostHeader = options.headers['Host'] ||\n                        req.headers['host'];\n\n    responseViaHeader = options.headers['Via'] ||\n                        'http://localhost:' + gatewayPort;\n\n    // validate the via header was injected and points to 127.0.0.1 in either ipv4 or ipv6 format\n    if (req.headers['via'] === undefined || req.headers['via'] === null || req.headers['via'].indexOf(requestViaHeader) === -1) {\n      res.writeHead(400);\n      res.end('{ \"error\": 400, \"message\": \"invalid via header, expected ' + requestViaHeader + '\" }');\n      return;\n    }\n\n    // strip the proxy credentials header\n    req.headers['authorization'] = null;\n    // simulate the behavior of x-forwarded-for with multiple proxies\n    req.headers['x-forwarded-for'] = [req.headers['x-forwarded-for'], req.headers['via']].join(', ');\n    // change the via header to this server\n    req.headers['via'] = responseViaHeader;\n    req.headers['host'] = responseHostHeader;\n\n    var errorCallback = function errorCallback(err, repsonse, body) {\n      if (err) {\n        res.writeHead(500);\n        res.end(JSON.stringify({ \"error\": 500, \"message\": err.message  }));\n        return;\n      }\n    }\n\n    request(req, errorCallback).pipe(res);\n  });\n\n  portfinder.getPort(function (err, port) {\n    if (err) done(err);\n\n    config.proxy.gateway.port = port;\n    gatewayPort = port;\n\n    handles.gatewayServer.listen(port, function() {\n      done(null);\n    });\n  });\n}",
    "docstring": "Creates a simple LAN proxy using a vanilla HTTP server\nthat verifies the state of the proxy credentials and the x-forwarded-url\nare correct.\n\n@param  {Object.<string, string>} options  the options for configuring this\ntest suite\n@param  {Object.<string, string>} config   the config of the json-proxy for\nthis test suite\n@param  {Function} done",
    "model_name": "gemma-2-9b-it",
    "summary_english": "configureLanProxy is a function that sets up a local proxy server. It takes three arguments: options, config, and done. Options is an object containing headers for the proxy, config is an object containing proxy configuration details, and done is a callback function. The function first defines variables for portfinder, request, credentials, gateway port, expected authorization header, request via header, and response via header. It then creates an HTTP server using the 'http' module. The server listens for incoming requests and performs several validations: it checks if the requested URL matches the X-Forwarded-Url header, validates the authorization header, and ensures the Via header is correctly set. If the validations pass, the server strips the authorization header, simulates the X-Forwarded-For header, and modifies the Via and Host headers. Finally, the server forwards the request to the target using the 'request' module and pipes the response back to the client. The function then uses portfinder to find an available port and starts the gateway server on that port. Once the server is running, the done callback is executed.",
    "summary_chinese": "configureLanProxy 函数用于配置 LAN 代理。它接受三个参数：options（配置选项）、config（配置信息）和 done（回调函数）。 \n\n该函数首先获取一个空闲端口，然后创建一个 HTTP 服务器，该服务器处理来自代理用户的请求。 \n\n服务器首先验证请求的 X-Forwarded-Url 和 Authorization 头部，确保它们与预期值相匹配。 然后，它修改请求头，例如 Via 和 Host，以确保请求能够正确转发到目标服务器。 最后，服务器使用 request 库转发请求到目标服务器，并将服务器的响应发送回代理用户。",
    "summary_french": "La fonction `configureLanProxy` configure un proxy local. Elle prend trois arguments : `options` (un objet contenant des options), `config` (un objet de configuration) et `done` (une fonction de callback). La fonction utilise `portfinder` pour trouver un port disponible et crée un serveur HTTP qui intercepte les requêtes. Elle vérifie les en-têtes d'autorisation et d'URL, puis redirige les requêtes vers le serveur cible en modifiant les en-têtes `Via` et `Host`. Enfin, elle appelle la fonction de callback `done` avec un éventuel erreur ou `null` si la configuration est réussie.",
    "summary_spanish": "La función `configureLanProxy` configura un proxy local. Recibe como argumentos `options`, `config` y `done`.  `options` contiene información sobre los encabezados de la solicitud, `config` contiene la configuración del proxy y `done` es una función de llamada de retorno. La función busca un puerto disponible, crea un servidor HTTP que actúa como proxy y configura el servidor para reenviar las solicitudes a la puerta de enlace especificada en `config`. El servidor proxy valida las solicitudes entrantes, incluyendo la URL, las credenciales y el encabezado Via. Si las solicitudes son válidas, el servidor proxy las reenvía a la puerta de enlace y devuelve la respuesta al cliente.",
    "summary_portuguese": "A função `configureLanProxy` configura um proxy local. Ela recebe três argumentos: `options`, um objeto com configurações do proxy; `config`, um objeto com configurações gerais; e `done`, uma função callback para indicar a conclusão da configuração. A função busca uma porta livre, cria um servidor HTTP que atua como o proxy, e configura o servidor para receber solicitações, validar credenciais e encaminhar solicitações para o destino especificado.  A função utiliza módulos externos como `portfinder` para encontrar uma porta livre e `request` para fazer requisições HTTP.  Após a configuração, a função chama a função callback `done` com um erro ou `null` se a configuração for bem-sucedida.",
    "summary_arabic": "function configureLanProxy  يُستخدم لتهيئة بروكسي LAN. يتلقى خيارات، إعدادات، ووظيفة لإكمال العملية.  \n\nيحتوي على  `options`  من نوع  `object`،  `config`  من نوع  `object`، و `done`  من نوع  `function`.\n\nيُستخدم `portfinder` لمعرفة ميناء متاح، ثم يُنشئ خادم HTTP.  يُفحص خادم HTTP  `X-Forwarded-Url`  و `authorization`  للطلبات.  يُعدل  `Via`  و  `Host`  للطلبات.  يُستخدم `request`  لإرسال الطلبات إلى الهدف المحدد.  عند الانتهاء، يتم إعلام `done`  بنجاح أو خطأ.",
    "summary_hindi": "configureLanProxy फ़ंक्शन एक LAN प्रॉक्सी को कॉन्फ़िगर करने के लिए जिम्मेदार है। यह `options`, `config` और `done` नामक तीन एर्ग्यूमेंट्स लेता है। \n\n`options` एक ऑब्जेक्ट है जो प्रॉक्सी हेडर्स को परिभाषित करता है। `config` एक ऑब्जेक्ट है जो प्रॉक्सी सेटिंग्स को संग्रहीत करता है। `done` एक फ़ंक्शन है जो प्रॉक्सी कॉन्फ़िगरेशन के पूरा होने पर कॉल किया जाता है।\n\nइस फ़ंक्शन का मुख्य तर्क यह है कि यह एक HTTP सर्वर शुरू करता है जो प्रॉक्सी के रूप में कार्य करता है। यह सर्वर प्रॉक्सी के लिए आवश्यक हेडर्स को सत्यापित करता है और प्रॉक्सी के माध्यम से अनुरोधों को आगे बढ़ाता है।"
  },
  {
    "id": "sample_50260",
    "language": "javascript",
    "length_bucket": "long",
    "code": "function ExecutionProfile(name, options) {\n  if (typeof name !== 'string') {\n    throw new TypeError('Execution profile name must be a string');\n  }\n  options = options || utils.emptyObject;\n  /**\n   * Name of the execution profile.\n   * @type {String}\n   */\n  this.name = name;\n  /**\n   * Consistency level.\n   * @type {Number}\n   */\n  this.consistency = options.consistency;\n  /**\n   * Load-balancing policy\n   * @type {LoadBalancingPolicy}\n   */\n  this.loadBalancing = options.loadBalancing;\n  /**\n   * Client read timeout.\n   * @type {Number}\n   */\n  this.readTimeout = options.readTimeout;\n  /**\n   * Retry policy.\n   * @type {RetryPolicy}\n   */\n  this.retry = options.retry;\n  /**\n   * Serial consistency level.\n   * @type {Number}\n   */\n  this.serialConsistency = options.serialConsistency;\n}",
    "docstring": "Creates a new instance of {@link ExecutionProfile}.\n@classdesc\nRepresents a set configurations to be used in a statement execution to be used for a single {@link Client} instance.\n<p>\nAn {@link ExecutionProfile} instance should not be shared across different {@link Client} instances.\n</p>\n@param {String} name Name of the execution profile.\n<p>\nUse <code>'default'</code> to specify that the new instance should be the default {@link ExecutionProfile} if no\nprofile is specified in the execution.\n</p>\n@param {Object} [options] Profile options, when any of the options is not specified the {@link Client} will the use\nthe ones defined in the default profile.\n@param {Number} [options.consistency] The consistency level to use for this profile.\n@param {LoadBalancingPolicy} [options.loadBalancing] The load-balancing policy to use for this profile.\n@param {Number} [options.readTimeout] The client per-host request timeout to use for this profile.\n@param {RetryPolicy} [options.retry] The retry policy to use for this profile.\n@param {Number} [options.serialConsistency] The serial consistency level to use for this profile.\n@constructor",
    "model_name": "gemma-2-9b-it",
    "summary_english": "ExecutionProfile is a constructor function that creates an execution profile object. It takes two arguments: name (a string representing the profile name) and options (an object containing configuration options). The function validates the name argument and initializes properties of the execution profile object based on the provided options, including consistency level, load balancing policy, read timeout, retry policy, and serial consistency level.",
    "summary_chinese": "ExecutionProfile 函数用于创建执行配置文件。它接受两个参数：name（必须是字符串，表示执行配置文件的名称）和 options（可选，是一个对象，包含执行配置文件的选项）。函数首先检查 name 参数的类型是否为字符串，如果类型不正确，则抛出 TypeError。然后，它将 options 参数设置为一个空对象，如果 options 参数未提供。最后，函数将 name、consistency、loadBalancing、readTimeout、retry 和 serialConsistency 属性设置为 options 参数中的相应值。",
    "summary_french": "La fonction ExecutionProfile prend en entrée un nom (obligatoire, type chaîne de caractères) et un objet options (optionnel). Elle vérifie que le nom est bien une chaîne de caractères. Si l'objet options est absent, elle utilise un objet vide par défaut. La fonction initialise ensuite les propriétés de l'objet ExecutionProfile avec les valeurs provenant de l'objet options : consistency, loadBalancing, readTimeout, retry et serialConsistency.",
    "summary_spanish": "La función ExecutionProfile recibe dos argumentos: name (un string que representa el nombre del perfil de ejecución) y options (un objeto opcional que contiene configuraciones adicionales).  \n\nSi el nombre no es una cadena, la función lanza un error.  \n\nEl constructor inicializa propiedades del objeto como name, consistency, loadBalancing, readTimeout, retry y serialConsistency, tomando los valores de las opciones proporcionadas.",
    "summary_portuguese": "A função ExecutionProfile recebe o nome do perfil de execução e opções como argumentos. Ela valida se o nome é uma string. Se não for, lança um erro. As opções são inicializadas como um objeto vazio se não forem fornecidas. A função então define propriedades para o nome do perfil, nível de consistência, política de balanceamento de carga, timeout de leitura, política de retry e nível de consistência serial, todas baseadas nas opções fornecidas.",
    "summary_arabic": "function ExecutionProfile  يُستخدم لإنشاء ملف تعريف تنفيذ. يتلقى اسم الملف تعريف التنفيذ و خيارات إضافية.  يجب أن يكون الاسم نصا.  الخيارات هي خيار إضافي وتشمل مستويات الاتساق، سياسة توزيع الأحمال، وقت الانتظار للقراءة، سياسة إعادة المحاولة، ومستوى الاتساق التسلسلي.  يُخزن كل من هذه القيم في خصائص object ExecutionProfile.",
    "summary_hindi": "ExecutionProfile नामक फ़ंक्शन एक एक्सेक्शन प्रोफ़ाइल का निर्माण करता है। यह एक नाम और वैकल्पिक विकल्पों को लेता है। यह सुनिश्चित करता है कि नाम एक स्ट्रिंग हो। विकल्पों को डिफ़ॉल्ट रूप से एक खाली ऑब्जेक्ट सेट किया जाता है।  इसके बाद, यह प्रोफ़ाइल के नाम, कंसिस्टेंसी स्तर, लोड बैलेंसिंग नीति, क्लाइंट रीड टाइमआउट, रिट्री पॉलिसी और सीरियल कंसिस्टेंसी जैसे गुणों को सेट करता है।"
  },
  {
    "id": "sample_55271",
    "language": "javascript",
    "length_bucket": "long",
    "code": "async function (fname, attrs) {\n        \n        let partialDirs;\n\n        if (typeof module.exports.configuration.partialDirs === 'undefined'\n         || !module.exports.configuration.partialDirs\n         || module.exports.configuration.partialDirs.length <= 0) {\n            partialDirs = [ __dirname ];\n         } else {\n            partialDirs = module.exports.configuration.partialDirs;\n         }\n\n        var partialFound = await globfs.findAsync(partialDirs, fname);\n        if (!partialFound) throw new Error(`No partial found for ${fname} in ${util.inspect(partialDirs)}`);\n        // Pick the first partial found\n        partialFound = partialFound[0];\n        // console.log(`module.exports.configuration renderPartial ${partialFound}`);\n        if (!partialFound) throw new Error(`No partial found for ${fname} in ${util.inspect(partialDirs)}`);\n    \n        var partialFname = path.join(partialFound.basedir, partialFound.path);\n        var stats = await fs.stat(partialFname);\n        if (!stats.isFile()) {\n            throw new Error(`doPartialAsync non-file found for ${fname} - ${partialFname}`);\n        }\n        var partialText = await fs.readFile(partialFname, 'utf8');\n        if (/\\.ejs$/i.test(partialFname)) {\n            try { return ejs.render(partialText, attrs); } catch (e) {\n                throw new Error(`EJS rendering of ${fname} failed because of ${e}`);\n            }\n        } /* else if (/\\.literal$/i.test(partialFname)) {\n            try {\n                const t = literal(partialText);\n                return t(attrs);\n            } catch (e) {\n                throw new Error(`Literal rendering of ${fname} failed because of ${e}`);\n            }\n        } */ else if (/\\.html$/i.test(partialFname)) {\n            // NOTE: The partialBody gets lost in this case\n            return partialText;\n        } else {\n            throw new Error(\"No rendering support for ${fname}\");\n        }\n    }",
    "docstring": "Replaceable function to handle rendering",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `doPartialAsync` renders a partial template given a filename and attributes. It takes two arguments: `fname` (string) which is the name of the partial template file, and `attrs` (object) which contains data to be passed to the template. The function first determines the directories to search for the partial file based on the configuration. It then uses `globfs.findAsync` to locate the partial file. If found, it reads the file contents and renders it based on its extension. If the extension is `.ejs`, it uses EJS templating engine. If it's `.html`, it returns the raw HTML content. If it's neither, it throws an error.",
    "summary_chinese": "该函数名为 `doPartialAsync`，用于渲染模板文件。它接受两个参数：`fname`（字符串，模板文件名）和 `attrs`（对象，模板参数）。 \n\n函数首先根据配置确定模板文件所在的目录，然后使用 `globfs.findAsync` 函数查找指定名称的模板文件。如果找不到模板文件，则抛出错误。找到模板文件后，函数读取模板文件内容，并根据文件扩展名进行渲染。如果文件扩展名为 `.ejs`，则使用 `ejs.render` 函数渲染模板；如果文件扩展名为 `.html`，则直接返回模板内容；其他类型的文件将抛出错误。",
    "summary_french": "La fonction `doPartialAsync` est utilisée pour trouver et rendre un template partiel. Elle prend deux arguments : `fname` (une chaîne de caractères représentant le nom du template partiel) et `attrs` (un objet contenant les données à passer au template). La fonction recherche d'abord le template partiel dans un répertoire spécifié par la configuration. Si le template est trouvé, il est lu et rendu en fonction de son extension. Les extensions prises en charge sont `.ejs`, `.html` et `.literal`. Si l'extension n'est pas reconnue, une erreur est levée.",
    "summary_spanish": "La función asíncrona busca un archivo parcial (fname) en una lista de directorios. Si se encuentra, lee su contenido y lo renderiza según su extensión. Si la extensión es '.ejs', se utiliza EJS para renderizarlo. Si es '.html', se devuelve el contenido sin cambios. Si es de otro tipo, se lanza un error.  \n\nfname (string): Nombre del archivo parcial a buscar.\nattrs (object): Atributos para el renderizado. \n\n\nLa función primero busca el archivo parcial en una lista de directorios configurados. Si se encuentra, lee su contenido y lo renderiza según su extensión. Si no se encuentra, lanza un error.",
    "summary_portuguese": "A função `doPartialAsync` busca e renderiza um template parcial. Ela recebe dois argumentos: `fname` (string) que é o nome do template parcial e `attrs` (objeto) que contém os dados para renderização. A função primeiro procura o template parcial em uma lista de diretórios configurados. Se o template for encontrado, ele é lido e renderizado usando o motor EJS se o arquivo tiver extensão `.ejs`. Se a extensão for `.html`, o conteúdo é retornado diretamente. Caso contrário, uma exceção é lançada.",
    "summary_arabic": "The function `doPartialAsync` renders a partial template file. It takes two arguments: `fname` (a string representing the name of the partial file) and `attrs` (an object containing data to be passed to the template). The function first determines the directories to search for the partial file based on the configuration. It then uses `globfs.findAsync` to locate the partial file. If found, it reads the file contents and renders it based on its extension: EJS, literal, or HTML. If the file extension is not supported, it throws an error.",
    "summary_hindi": "यह फ़ंक्शन `doPartialAsync` नाम से जाना जाता है और यह एक टेम्पलेट को रेंडर करने के लिए जिम्मेदार है। यह दो आर्गुमेंट्स लेता है: `fname` जो स्ट्रिंग प्रकार का होता है और `attrs` जो एक ऑब्जेक्ट होता है। \n\nयह फ़ंक्शन पहले `partialDirs` नामक एक एरे को परिभाषित करता है जो टेम्पलेट्स की खोज करने के लिए उपयोग किए जाने वाले निर्देशिकाओं की सूची है। फिर यह `globfs.findAsync` फ़ंक्शन का उपयोग करके `fname` नामक टेम्पलेट को `partialDirs` में खोजता है। यदि टेम्पलेट नहीं पाया जाता है तो यह एक त्रुटि उत्पन्न करता है। \n\nटेम्पलेट पाए जाने पर, यह `fs.stat` का उपयोग करके फ़ाइल की जांच करता है और यह सुनिश्चित करता है कि यह एक फ़ाइल है। फिर यह `fs.readFile` का उपयोग करके टेम्पलेट की सामग्री को पढ़ता है। \n\nअंत में, यह टेम्पलेट के प्रकार के आधार पर इसे रेंडर करता है। यदि टेम्पलेट `.ejs` के साथ समाप्त होता है, तो यह `ejs.render` का उपयोग करके इसे रेंडर करता है। यदि टेम्पलेट `.html` के साथ समाप्त होता है, तो यह इसे सीधे वापस देता है। अन्यथा, यह एक त्रुटि उत्पन्न करता है।"
  },
  {
    "id": "sample_53011",
    "language": "javascript",
    "length_bucket": "long",
    "code": "function mount(opts, cb) {\n    \"use strict\";\n    \n    var params = [ 'mount' ];\n    \n    if (opts.overlay) {\n        params.push('-O');\n    }\n    \n    if (opts.options) {\n        if (opts.options.length) {\n            //opts.options is an array\n            for (var x =0; x < opts.options.length; x++) {\n                params.push('-o', opts.options[x]);\n            }\n        } else {\n            //opts.options is a single object, callback err and return\n            cb({error:'invalid argu: the options should be a string array'});\n            return;\n        }\n    }\n    \n    if (opts.dataset) {\n        params.push(opts.dataset);  \n    } else {\n        params.push('-a');\n    }\n    \n    zfs(params, cb);\n}",
    "docstring": "/*\n\nMount the specified dataset/all datasets to the mountpoint\n\nPARAMS:\nopts: {\ndataset: string // the name of the zfs dataset. if the dataset is null, then mount all datasets with '-a'\noverlay: boolean // whether use overlay mode\noptions: [string, string, ...] // the temporal properties set for the mount duration,\nsuch as ro/rw for readonly and readwrite (optional)\n}",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `mount` mounts a ZFS dataset. It takes two arguments: `opts` which is an object containing options for mounting, and `cb` which is a callback function. \n\nThe function constructs an array `params` that will be used to call the `zfs` function. \n\nIt checks if the `opts` object contains properties for `overlay`, `options`, and `dataset`. Based on the presence and type of these properties, it appends appropriate flags and values to the `params` array. \n\nFinally, it calls the `zfs` function with the constructed `params` array and the callback function `cb`.",
    "summary_chinese": "该函数名为 mount，用于执行 ZFS 挂载操作。它接受两个参数：opts 和 cb。 opts 是一个对象，包含挂载选项，例如 overlay、options 和 dataset。 cb 是一个回调函数，用于处理挂载结果。 \n\n函数首先定义一个参数数组 params，并根据 opts 的值添加相应的选项参数。如果 opts.overlay 为真，则添加 -O 参数；如果 opts.options 是一个字符串数组，则添加 -o 参数和每个选项值；如果 opts.options 是一个对象，则返回错误信息；如果 opts.dataset 存在，则添加 dataset 参数；否则添加 -a 参数。最后，函数调用 zfs 函数执行挂载操作，并将结果传递给回调函数 cb。",
    "summary_french": "La fonction `mount` a pour but de monter un système de fichiers ZFS. Elle prend deux arguments : `opts` qui est un objet contenant des options de montage et `cb` qui est une fonction de rappel. \n\nL'objet `opts` peut contenir les propriétés suivantes : `overlay`, `options` et `dataset`. \n\nLa fonction construit une liste d'arguments pour la commande `zfs` en fonction des options fournies. Si `overlay` est défini, l'option `-O` est ajoutée à la liste. Si `options` est un tableau, chaque élément du tableau est ajouté à la liste avec l'option `-o`. Si `options` est un objet, la fonction renvoie une erreur car l'argument `options` doit être un tableau de chaînes. Si `dataset` est défini, il est ajouté à la liste. Sinon, l'option `-a` est ajoutée. \n\nEnfin, la fonction appelle la fonction `zfs` avec la liste d'arguments construite et le callback `cb`.",
    "summary_spanish": "La función mount tiene como propósito montar un volumen ZFS. Recibe dos argumentos: opts, un objeto con opciones de montaje, y cb, una función de devolución de llamada. \n\nEl código construye un array llamado params que contiene los parámetros necesarios para la llamada a la función zfs. \n\nSi la opción overlay está presente en opts, se agrega '-O' a params. Si la opción options está presente en opts y es un array, se agregan cada uno de los elementos del array como '-o' seguido del valor al array params. Si la opción options es un objeto, se devuelve un error. Si la opción dataset está presente en opts, se agrega el valor del dataset a params. De lo contrario, se agrega '-a'. Finalmente, se llama a la función zfs con el array params y la función de devolución de llamada cb.",
    "summary_portuguese": "A função `mount` tem como objetivo montar um sistema de arquivos ZFS. Ela recebe dois argumentos: `opts`, um objeto com opções de montagem, e `cb`, uma função de callback. \n\nSe `opts.overlay` for verdadeiro, o parâmetro `-O` é adicionado à lista de parâmetros. Se `opts.options` for um array, cada elemento do array é adicionado à lista de parâmetros como `-o` seguido do valor. Caso contrário, a função retorna um erro, pois `opts.options` deve ser um array de strings. Se `opts.dataset` for fornecido, ele é adicionado à lista de parâmetros. Caso contrário, o parâmetro `-a` é adicionado. Finalmente, a função `zfs` é chamada com a lista de parâmetros e a função de callback.",
    "summary_arabic": "The function mount is used to mount a ZFS dataset. It takes two arguments: opts, an object containing options, and cb, a callback function. \n\nThe opts object can have the following properties: overlay, a boolean indicating whether to mount the dataset as an overlay; options, an array of strings representing mount options; and dataset, a string representing the dataset to mount.\n\nThe function constructs an array of parameters to be passed to the zfs command. It adds the 'mount' command, and based on the opts object, it adds additional parameters like '-O' for overlay, '-o' followed by each option in the options array, and the dataset name or '-a' if no dataset is specified. Finally, it calls the zfs function with the constructed parameters and the callback function.",
    "summary_hindi": "यह फ़ंक्शन 'mount' नाम से ज़ेफ़्स फ़ाइल सिस्टम को माउंट करता है। यह दो आर्गुमेंट्स लेता है: 'opts' जो माउंटिंग के विकल्पों का एक ऑब्जेक्ट है और 'cb' जो एक कॉलबैक फ़ंक्शन है। \n\n'opts' ऑब्जेक्ट में 'overlay', 'options' और 'dataset' जैसे विकल्प हो सकते हैं। \n\nयदि 'overlay' सत्य है, तो '-O' जोड़ दिया जाता है। यदि 'options' एक स्ट्रिंग एरे है, तो प्रत्येक विकल्प '-o' के साथ जोड़ा जाता है। यदि 'options' एक ऑब्जेक्ट है, तो त्रुटि उत्पन्न होती है। यदि 'dataset' दिया गया है, तो यह जोड़ा जाता है। यदि नहीं, तो '-a' जोड़ा जाता है। \n\nअंत में, 'zfs' फ़ंक्शन को 'params' एरे और 'cb' कॉलबैक के साथ कॉल किया जाता है।"
  },
  {
    "id": "sample_51221",
    "language": "javascript",
    "length_bucket": "long",
    "code": "function createModal(id, title, body, footer) {\n            var $modalHeaderButton = $('<button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">&times;</button>');\n            var $modalHeaderTitle = $('<h4 class=\"modal-title\" id=\"' + id + '_modal_title\">' + title + '</h4>');\n\n            var $modalHeader = $('<div class=\"modal-header\"></div>');\n            $modalHeader.append($modalHeaderButton);\n            $modalHeader.append($modalHeaderTitle);\n\n            var $modalBody = $('<div class=\"modal-body\" id=\"' + id + '_modal_body\">' + body + '</div>');\n\n            var $modalFooter = $('<div class=\"modal-footer\" id=\"' + id + '_modal_footer\"></div>');\n            if (typeof(footer) !== 'undefined') {\n                var $modalFooterAddOn = $('<div>' + footer + '</div>');\n                $modalFooter.append($modalFooterAddOn);\n            }\n\n            var $modalContent = $('<div class=\"modal-content\"></div>');\n            $modalContent.append($modalHeader);\n            $modalContent.append($modalBody);\n            $modalContent.append($modalFooter);\n\n            var $modalDialog = $('<div class=\"modal-dialog\"></div>');\n            $modalDialog.append($modalContent);\n\n            var $modalFade = $('<div class=\"modal fade\" id=\"' + id + '_modal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"' + id + '_modal_title\" aria-hidden=\"true\"></div>');\n            $modalFade.append($modalDialog);\n\n            $modalFade.data('dateId', id);\n            $modalFade.attr(\"dateId\", id);\n\n            return $modalFade;\n        }",
    "docstring": "/* ----- Modal functions -----",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function createModal generates a Bootstrap modal element. It takes four arguments: id (string), title (string), body (string), and footer (string). The function constructs the modal's header, body, and footer elements using jQuery, appending the provided title, body content, and footer content respectively. It then assembles the modal dialog, content, and fade elements, setting the modal's ID and data attributes. Finally, it returns the complete modal element as a jQuery object.",
    "summary_chinese": "createModal 函数用于创建模态框。它接受四个参数：id（字符串）、title（字符串）、body（字符串）、footer（字符串）。函数首先创建模态框的头部、主体和尾部元素，然后将它们组合成模态框内容。最后，将模态框内容添加到模态框对话框中，并返回整个模态框元素。",
    "summary_french": "La fonction `createModal` crée un élément modal HTML. Elle prend quatre arguments : `id` (string), `title` (string), `body` (string) et `footer` (string, optionnel). La fonction construit les éléments HTML pour l'en-tête, le corps et le pied de page du modal, puis les assemble dans un élément modal complet. Elle ajoute également un bouton de fermeture et définit l'ID du modal. Enfin, la fonction retourne l'élément modal complet.",
    "summary_spanish": "La función createModal crea un elemento modal HTML. Recibe cuatro argumentos: id (string), title (string), body (string) y footer (opcional, string).  \n\nLa función crea elementos HTML para el encabezado, el cuerpo y el pie del modal, utilizando los argumentos proporcionados.  Si se proporciona un valor para el argumento footer, se agrega a la estructura del modal. Finalmente, la función devuelve el elemento modal completo como un objeto jQuery.",
    "summary_portuguese": "A função createModal gera um modal HTML. Ela recebe quatro argumentos: id, título, corpo e rodapé. O id é usado para identificar o modal. O título é exibido no cabeçalho do modal. O corpo contém o conteúdo principal do modal. O rodapé é opcional e pode conter botões ou outros elementos. A função cria elementos HTML para o cabeçalho, corpo, rodapé e conteúdo do modal, e os combina em um único elemento modal. O elemento modal é então retornado.",
    "summary_arabic": "function createModal  يُنشئ مربع حوار. يتلقى id, title, body, footer كمدخلات.  يُنشئ عناصر HTML لـ header, body, footer, content, dialog, و fade.  يُضاف المحتوى إلى كل عنصر.  يُضاف dialog إلى fade.  يُ設定 id للمربع الحوار.  يعود المربع الحوار.",
    "summary_hindi": "createModal नामक फ़ंक्शन एक मॉडल बनाता है। यह id, title, body और footer नामक चार मानों को लेता है।  यह मानों का उपयोग करके मॉडल के शीर्षक, शरीर और फ़ीटर को बनाता है।  यह मॉडल को एक डायलॉग बॉक्स के अंदर रखता है और इसे वापस करता है।"
  },
  {
    "id": "sample_54498",
    "language": "javascript",
    "length_bucket": "long",
    "code": "function redact(_options, callback) {\n\tvar imports = [], \t// List of scss to import\n\t\toutput = '', \t// The scss output\n\t\terrors = [];\t// List of errors encountered\n\n\t// Build core\n\ttheme['core'] = {};\n\t_.each(_options.build.core, function(objects, family) {\n\t\ttheme['core'][family] = {};\n\t\t_.each(objects, function(objectName) {\n\t\t\tluiTheme('core.' + family + '.' + objectName);\n\t\t\timports.push('core/' + family + '/' + objectName);\n\t\t});\n\t});\n\n\t// Build plugins\n\tif (_options.build.plugins) {\n\t\ttheme['plugins'] = {};\n\t\t_.each(_options.build.plugins, function(plugin) {\n\t\t\tluiTheme('plugins.' + plugin);\n\t\t});\n\t}\n\n\toutput = tosass.format({theme: theme, imports: imports});\n\n\tif (typeof(callback) === 'function') {\n\t\tcallback(output);\n\t}\n\treturn output;\n}",
    "docstring": "Compiles build definitions and theme variables into a ready-to-import scss string.\n\n@param {Object} options\n@param {Function} callback\n@return {String} the scss output",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `redact` generates SCSS output based on provided options. It takes two arguments: `_options` (an object containing build configurations) and `callback` (a function to be executed with the generated SCSS). The function first initializes variables for imports, output, and errors. It then builds the core SCSS by iterating through `_options.build.core` and importing corresponding files. If `_options.build.plugins` is provided, it builds plugin SCSS by importing specified plugins. Finally, it formats the SCSS using `tosass.format` and calls the callback function with the generated output or returns the output directly.",
    "summary_chinese": "redact 函数用于生成 SCSS 代码。它接受两个参数：_options（包含构建选项）和 callback（可选的回调函数）。函数首先构建核心主题，然后构建插件主题。最后，它使用 tosass 库格式化主题和导入列表，生成最终的 SCSS 代码。如果提供了回调函数，则将输出传递给回调函数。否则，函数返回生成的 SCSS 代码。",
    "summary_french": "La fonction `redact` génère du code SCSS à partir d'options. Elle prend deux arguments : `_options` qui contient les paramètres de construction et `callback` une fonction à exécuter après la génération du code. La fonction construit un objet `theme` qui contient les chemins des fichiers SCSS à importer. Elle parcourt les options `build.core` et `build.plugins` pour identifier les fichiers à inclure. Ensuite, elle utilise la fonction `tosass.format` pour générer le code SCSS final. Si une fonction `callback` est fournie, elle est appelée avec le code SCSS généré. La fonction retourne également le code SCSS généré.",
    "summary_spanish": "La función redact procesa opciones de construcción para generar código SCSS. Recibe dos argumentos: _options, un objeto con configuraciones de construcción, y callback, una función que se ejecutará con el código SCSS generado.  La función construye un objeto theme con información sobre los componentes core y plugins. Luego, utiliza la función tosass.format para generar el código SCSS final. Si se proporciona una función callback, se ejecuta con el código SCSS generado. De lo contrario, la función devuelve el código SCSS.",
    "summary_portuguese": "A função redact processa opções de construção de temas e gera código SCSS. Ela recebe duas entradas: _options, um objeto contendo configurações de construção, e callback, uma função a ser executada após a geração do código. A função itera pelas configurações de construção para o núcleo e plugins do tema, adicionando imports e definindo o tema. Em seguida, utiliza a biblioteca tosass para formatar o código SCSS com as informações do tema e imports. Finalmente, a função executa a função callback com o código SCSS gerado ou retorna o código diretamente.",
    "summary_arabic": "دالة redact تقوم بتجميع ملفات SCSS وتكوين ملف SCSS رئيسي. \n\nتستقبل الدالة _options (مجموعة خيارات) و callback (دالة). \n\n_options تحتوي على معلومات عن البناء الأساسي والملحقات. \n\nالدالة تقوم بتجميع ملفات SCSS الأساسية بناءً على الخيارات في _options.build.core. \n\nإذا كانت هناك ملحقات في _options.build.plugins، يتم أيضًا تجميع ملفات SCSS الخاصة بها. \n\nثم تقوم الدالة بتكوين ملف SCSS رئيسي باستخدام  tosass.format. \n\nإذا تم إعطاء callback، يتم تنفيذها مع ملف SCSS الناتج.",
    "summary_hindi": "redact फ़ंक्शन एक SCSS फ़ाइल उत्पन्न करता है। यह _options और callback दो प्रकार के मानों को लेता है।  _options एक ऑब्जेक्ट है जिसमें build का एक गुण होता है जो core और plugins के लिए निर्देशों को रखता है। callback एक फ़ंक्शन है जो उत्पन्न SCSS को प्राप्त करेगा।  \n\nकार्यक्रम पहले theme ऑब्जेक्ट को core और plugins के लिए सेट करता है। यह _options से core और plugins के लिए निर्देशों का उपयोग करके theme ऑब्जेक्ट को भरता है। फिर, यह tosass.format फ़ंक्शन का उपयोग करके theme और imports का उपयोग करके SCSS को फ़ॉर्मेट करता है। अंत में, यदि callback फ़ंक्शन प्रदान किया गया है, तो यह callback को SCSS देता है।"
  },
  {
    "id": "sample_49828",
    "language": "javascript",
    "length_bucket": "long",
    "code": "function uploadSliceComplete(params, callback) {\n    var Bucket = params.Bucket;\n    var Region = params.Region;\n    var Key = params.Key;\n    var UploadId = params.UploadId;\n    var SliceList = params.SliceList;\n    var self = this;\n    var ChunkRetryTimes = this.options.ChunkRetryTimes + 1;\n    var Parts = SliceList.map(function (item) {\n        return {\n            PartNumber: item.PartNumber,\n            ETag: item.ETag\n        };\n    });\n    // 完成上传的请求也做重试\n    Async.retry(ChunkRetryTimes, function (tryCallback) {\n        self.multipartComplete({\n            Bucket: Bucket,\n            Region: Region,\n            Key: Key,\n            UploadId: UploadId,\n            Parts: Parts\n        }, tryCallback);\n    }, function (err, data) {\n        callback(err, data);\n    });\n}",
    "docstring": "完成分块上传",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function uploadSliceComplete is designed to complete a multipart upload of a file. It takes two arguments: params, an object containing information about the upload (Bucket, Region, Key, UploadId, and SliceList), and callback, a function to be called upon completion. The function extracts relevant information from the params object and constructs a Parts array containing PartNumber and ETag for each slice. It then uses Async.retry to make a multipart complete request to the specified S3 bucket. Upon successful completion, the callback function is called with the error and data from the request.",
    "summary_chinese": "uploadSliceComplete 函数用于完成分片上传。它接受两个参数：params 和 callback。params 是一个对象，包含 Bucket、Region、Key、UploadId 和 SliceList 等信息。callback 是一个回调函数，用于处理上传结果。函数首先从 params 对象中提取相关信息，然后将 SliceList 转换为 Parts 数组，每个元素包含 PartNumber 和 ETag。接着，函数使用 Async.retry 函数对 multipartComplete 请求进行重试， multipartComplete 函数用于完成分片上传。最后，函数调用 callback 函数，传递上传结果。",
    "summary_french": "La fonction uploadSliceComplete permet de finaliser le téléchargement d'une tranche de données. Elle prend deux arguments : params, un objet contenant les informations de téléchargement (Bucket, Region, Key, UploadId, SliceList), et callback, une fonction de rappel. La fonction extrait les informations nécessaires de l'objet params et construit un tableau Parts contenant les numéros de partie et les ETags de chaque tranche. Elle utilise ensuite une fonction Async.retry pour effectuer une requête multipartComplete jusqu'à ChunkRetryTimes tentatives. La fonction de rappel callback est appelée avec l'erreur et les données de la requête multipartComplete.",
    "summary_spanish": "La función uploadSliceComplete finaliza la carga de una porción de un archivo en Amazon S3. Recibe dos argumentos: params, un objeto con información sobre el archivo y la carga, y callback, una función que se ejecutará al finalizar la operación. La función extrae información del objeto params como el nombre del bucket, la región, la clave del archivo, el ID de la carga y la lista de partes. Luego, crea un array de objetos con el número de parte y el ETag de cada parte. Finalmente, utiliza Async.retry para realizar una solicitud de finalización de carga con la información recopilada. Si la solicitud es exitosa, la función llama al callback con un error nulo y los datos de la respuesta. Si hay un error, se llama al callback con el error y datos nulos.",
    "summary_portuguese": "A função uploadSliceComplete finaliza o upload de um objeto em vários pedaços. Ela recebe como argumentos: params, um objeto contendo informações sobre o bucket, região, chave, ID de upload e lista de pedaços; e callback, uma função para ser chamada após a conclusão do upload. A função extrai as informações necessárias dos parâmetros, cria uma lista de partes com seus números e ETags, e usa a função Async.retry para realizar uma série de tentativas de completar o upload multipart. Após o upload ser concluído, a função chama a função callback com o erro (se houver) e os dados da resposta.",
    "summary_arabic": "function uploadSliceComplete  تُستخدم هذه الوظيفة لإكمال عملية تحميل جزء من ملف إلى سحابة AWS. \n\narguments: \nparams:  مجموعة من المعلمات تشمل سلة التخزين، المنطقة، المفتاح، معرف التحميل، قائمة الأجزاء.\ncallback: دالة تُدعى عند الانتهاء من العملية.\n\nlogic: \n1. استخراج قيم المعلمات من `params`.\n2. تحويل قائمة الأجزاء إلى قائمة من الكائنات، لكل منها رقم الجزء وعلامة التتبع.\n3. استخدام `Async.retry` لإعادة المحاولة `ChunkRetryTimes` مرات.\n4. في كل محاولة، يتم استدعاء `self.multipartComplete` لإكمال عملية التحميل.\n5. عند الانتهاء من العملية، يتم استدعاء `callback` مع أي خطأ أو بيانات.",
    "summary_hindi": "uploadSliceComplete नामक फ़ंक्शन एक ऑब्जेक्ट के भागों को अपलोड करने के बाद अंतिम अपलोड को पूरा करने के लिए जिम्मेदार है। यह दो मान्यताओं के साथ काम करता है:  params और callback।  params एक ऑब्जेक्ट है जिसमें Bucket, Region, Key, UploadId और SliceList जैसे गुण होते हैं। callback एक फ़ंक्शन है जो अपलोड की स्थिति के बारे में जानकारी देता है। \n\nफ़ंक्शन पहले SliceList से प्रत्येक भाग के लिए PartNumber और ETag को एक्स्ट्रैक्ट करता है और उन्हें एक नया ऑब्जेक्ट Parts में संग्रहीत करता है। फिर, यह multipartComplete फ़ंक्शन को कॉल करता है, जो Bucket, Region, Key, UploadId और Parts के साथ अपलोड को पूरा करने के लिए एक अनुरोध भेजता है।  multipartComplete फ़ंक्शन को  ChunkRetryTimes  बार retry करने के लिए कहा जाता है।  अंत में, फ़ंक्शन callback फ़ंक्शन को अपलोड की स्थिति के बारे में जानकारी देता है।"
  },
  {
    "id": "sample_49217",
    "language": "javascript",
    "length_bucket": "long",
    "code": "function FeedSummary(props) {\n  const { children, className, content, date, user } = props\n\n  const classes = cx('summary', className)\n  const rest = getUnhandledProps(FeedSummary, props)\n  const ElementType = getElementType(FeedSummary, props)\n\n  if (!childrenUtils.isNil(children)) {\n    return (\n      <ElementType {...rest} className={classes}>\n        {children}\n      </ElementType>\n    )\n  }\n\n  return (\n    <ElementType {...rest} className={classes}>\n      {createShorthand(FeedUser, val => ({ content: val }), user, { autoGenerateKey: false })}\n      {content}\n      {createShorthand(FeedDate, val => ({ content: val }), date, { autoGenerateKey: false })}\n    </ElementType>\n  )\n}",
    "docstring": "A feed can contain a summary.",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function FeedSummary is a component that generates a summary for a feed item. It takes props including children, className, content, date, and user. If children are provided, it renders them within an element determined by getElementType. Otherwise, it renders a shorthand component for the user, the content, and the date.",
    "summary_chinese": "FeedSummary 函数用于生成新闻摘要。它接受 props 参数，包括 children、className、content、date 和 user。如果 children 不为空，则直接渲染 children；否则，渲染包含用户、内容和日期信息的摘要。",
    "summary_french": "La fonction FeedSummary prend en entrée des propriétés (props) qui incluent des enfants, une classe, du contenu, une date et un utilisateur. Elle utilise les propriétés pour construire un élément HTML. Si des enfants sont fournis, la fonction les affiche directement dans l'élément. Sinon, elle affiche du contenu, une date et un utilisateur sous forme de composants FeedUser et FeedDate.",
    "summary_spanish": "La función FeedSummary toma como entrada un objeto props que contiene los siguientes argumentos: children (cualquier elemento JSX), className (una clase de estilo), content (el contenido del resumen), date (la fecha del resumen) y user (el usuario que creó el resumen). La función determina si se proporciona contenido dentro de los hijos. Si es así, devuelve el contenido dentro de un elemento con la clase especificada. Si no, crea un resumen utilizando los valores de content, date y user, y los renderiza dentro de un elemento con la clase especificada.",
    "summary_portuguese": "A função FeedSummary recebe propriedades para criar um resumo de postagem. Ela aceita propriedades como children, className, content, date e user. Se a propriedade children não for nula, a função retorna o elemento children dentro do elemento especificado pela propriedade ElementType, com as classes combinadas de 'summary' e className. Caso contrário, a função retorna um elemento com as classes combinadas de 'summary' e className, contendo um resumo com o conteúdo do usuário, o conteúdo da postagem e a data da postagem.",
    "summary_arabic": "دالة FeedSummary تستقبل props وتقوم بإنشاء ملخص لمدخلات التغذية. \n\nتستقبل الدالة props التالية: children (محتوى ديناميكي)، className (اسم الفئة لل CSS)، content (محتوى النص)، date (تاريخ المدخلات)، user (معلومات المستخدم).\n\nتستخدم الدالة  cx لتجميع الفئات CSS. \n\nإذا كان children غير فارغ، يتم عرض children مباشرة. \n\nإذا كان children فارغ، يتم عرض محتوى النص content، معلومات المستخدم user، و تاريخ المدخلات date.",
    "summary_hindi": "FeedSummary एक फ़ंक्शन है जो फ़ीड आइटम का सारांश प्रस्तुत करता है। यह `props` ऑब्जेक्ट को लेता है जिसमें `children`, `className`, `content`, `date` और `user` जैसे गुण होते हैं। \n\nयदि `children` गुण प्रदान किया जाता है, तो फ़ंक्शन उन्हें सीधे वापस करता है। अन्यथा, यह `FeedUser`, `content` और `FeedDate` घटकों का उपयोग करके एक सारांश बनाता है।"
  }
]
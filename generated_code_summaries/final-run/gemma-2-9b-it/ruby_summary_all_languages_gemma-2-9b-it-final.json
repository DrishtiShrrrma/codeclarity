[
  {
    "id": "sample_71154",
    "language": "ruby",
    "length_bucket": "short",
    "code": "def delete(key)\n      @lock.synchronize do\n        rkey = ref_key(key)\n        if rkey\n          @references_to_keys_map.delete(rkey)\n          @values.delete(rkey)\n        else\n          nil\n        end\n      end\n    end",
    "docstring": "Remove the value associated with the key from the map.",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `delete` removes a key-value pair from a data structure. It takes a `key` argument of any type. It first generates a reference key using the `ref_key` function. If a reference key exists, it removes the corresponding entry from both the `references_to_keys_map` and `values` data structures. If no reference key is found, it returns `nil`. The code uses a lock synchronization mechanism to ensure thread safety during the deletion process.",
    "summary_chinese": "该函数名为 delete，用于根据给定的 key 删除数据。它接受一个 key 作为参数，该参数的类型为任意。函数首先使用 ref_key 函数将 key 转换为引用 key，然后检查引用 key 是否存在。如果存在，则从 references_to_keys_map 和 values 中删除该引用 key。否则，返回 nil。整个操作在锁保护下进行，以确保线程安全。",
    "summary_french": "La fonction `delete` supprime une valeur associée à une clé donnée. Elle prend un argument `key` de type n'importe quel objet. La fonction utilise un verrou (`@lock`) pour garantir l'accès exclusif aux données. Elle convertit la clé en une référence (`rkey`) et vérifie si cette référence existe dans le map `@references_to_keys_map`. Si la référence existe, la fonction supprime la référence et la valeur correspondante du map `@references_to_keys_map` et de la liste `@values`. Sinon, elle retourne `nil`.",
    "summary_spanish": "La función delete elimina un elemento del mapa de referencias a claves y del mapa de valores. Recibe un argumento key de tipo cualquier.  Si la clave existe en el mapa de referencias a claves, se elimina la entrada correspondiente en ambos mapas. Si la clave no existe, devuelve nil.",
    "summary_portuguese": "A função delete remove um elemento do mapa de referências para chaves e do mapa de valores. Ela recebe uma chave como argumento (tipo String) e, utilizando um bloqueio sincronizado, procura a chave de referência correspondente. Se a chave de referência for encontrada, ela é removida de ambos os mapas. Caso contrário, a função retorna nil.",
    "summary_arabic": "delete هو دالة تقوم بحذف قيمة من خريطة القيم بناءً على مفتاح. يتقبل الدالة مفتاح واحد من نوع أي شيء. تقوم الدالة أولاً بتحويل المفتاح إلى مفتاح مرجعي باستخدام دالة ref_key. إذا وجد المفتاح المرجعي في خريطة المراجع إلى المفاتيح، يتم حذف المفتاح المرجعي من الخريطة وكذلك القيمة المقابلة في خريطة القيم. وإلا، يتم إرجاع nil.",
    "summary_hindi": "delete नामक फ़ंक्शन किसी दिए गए कुंजी को हटाने के लिए जिम्मेदार है। यह एक लॉक का उपयोग करके सिंक्रनाइज़ेशन सुनिश्चित करता है।  इस फ़ंक्शन में एक argument है: key, जो एक स्ट्रिंग है। यह फ़ंक्शन पहले ref_key फ़ंक्शन का उपयोग करके कुंजी को संदर्भ कुंजी में बदलता है। यदि संदर्भ कुंजी मौजूद है, तो यह references_to_keys_map और values से संबंधित कुंजी को हटा देता है। अन्यथा, यह nil देता है।"
  },
  {
    "id": "sample_71953",
    "language": "ruby",
    "length_bucket": "short",
    "code": "def process_curl_response(curl)\n      if curl.response_code == 200\n        response = parser_for_xml(curl.body_str)\n        response = mark_new_entries(response)\n        store_summary_to_backend(response, curl)\n        response\n      end\n    end",
    "docstring": "Processes the results by identifying which entries are new if the response\n is a 200.  Otherwise, returns the Curl::Easy object for the user to inspect.",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function process_curl_response takes a curl object as input. It checks if the curl response code is 200. If it is, it parses the response body as XML, marks new entries, stores the summary in a backend, and returns the processed response. \n\n\nArguments:\n\ncurl (Curl object) \n\n\nLogic:\n\n- Checks if the curl response code is 200.\n- If the code is 200, it parses the response body as XML using parser_for_xml.\n- It then marks new entries in the parsed response using mark_new_entries.\n- The processed response is stored in a backend using store_summary_to_backend along with the curl object.\n- Finally, it returns the processed response.",
    "summary_chinese": "该函数名为 process_curl_response，用于处理 cURL 请求的响应。它接受一个 cURL 对象作为参数，如果响应状态码为 200，则解析响应体，标记新条目，并将摘要存储到后端，最后返回解析后的响应。",
    "summary_french": "La fonction `process_curl_response` traite la réponse d'une requête cURL. Elle vérifie si le code de réponse est 200. Si c'est le cas, elle parse le corps de la réponse en XML, marque les nouvelles entrées et stocke un résumé dans le backend. La fonction retourne la réponse traitée. \n\nArguments: \ncurl: un objet représentant la réponse cURL.\n\nTypes: \ncurl: objet cURLResponse",
    "summary_spanish": "La función process_curl_response toma un objeto curl como argumento. Si el código de respuesta del curl es 200, parsea el cuerpo de la respuesta como XML, marca las nuevas entradas y almacena un resumen en el backend. Finalmente, devuelve la respuesta procesada.",
    "summary_portuguese": "A função process_curl_response recebe uma resposta de uma requisição cURL. Se o código de resposta for 200, ela analisa o corpo da resposta como XML, marca novas entradas e armazena um resumo no backend. A função então retorna a resposta processada.",
    "summary_arabic": "function process_curl_response  \n\nتُعالِج استجابة curl. إذا كان رمز الاستجابة هو 200، يتم تحليل محتوى الاستجابة باستخدام parser_for_xml، ثم يتم وضع علامة على الإدخالات الجديدة باستخدام mark_new_entries. بعد ذلك، يتم تخزين ملخص الاستجابة في الخادم باستخدام store_summary_to_backend مع الاستجابة و curl.  \n\narguments:\ncurl: object of type curl\n\nlogic:\n- check if curl.response_code is 200\n- if true:\n    - parse curl.body_str using parser_for_xml\n    - mark new entries in the parsed response\n    - store the response and curl in the backend\n    - return the response",
    "summary_hindi": "इस फ़ंक्शन का नाम `process_curl_response` है। यह एक CURL प्रतिक्रिया को संसाधित करता है। यह `curl` नामक एक एर्ग्यूमेंट लेता है जो एक CURL ऑब्जेक्ट है। अगर CURL प्रतिक्रिया कोड 200 है, तो यह CURL के शरीर को XML पार्सर का उपयोग करके पार्स करता है, नए प्रविष्टियों को चिह्नित करता है और परिणाम को बैकएंड में संग्रहीत करता है। अंत में, यह प्रतिक्रिया वापस देता है।"
  },
  {
    "id": "sample_71260",
    "language": "ruby",
    "length_bucket": "short",
    "code": "def register_animations!\n      self.class.animations.each do |animation|\n        animate animation.actor, animation.options, &animation.on_complete_block\n      end\n    end",
    "docstring": "Register all the animations that were defined for this scene.",
    "model_name": "gemma-2-9b-it",
    "summary_english": "register_animations! iterates through each animation in the class's animations collection. For each animation, it calls the animate function, passing the animation's actor, options, and on_complete_block.",
    "summary_chinese": "register_animations 函数用于注册动画。它接受一个 self.class.animations 数组作为参数，该数组包含多个动画对象。函数遍历数组中的每个动画对象，并使用动画对象的 actor、options 和 on_complete_block 属性分别调用动画的执行函数。",
    "summary_french": "La fonction `register_animations!` s'assure que toutes les animations définies dans la classe sont appliquées. Elle parcourt chaque animation dans la liste `animations` de la classe et exécute l'animation sur l'acteur associé (`animation.actor`) en utilisant les options spécifiées (`animation.options`).  Le bloc `on_complete_block` de l'animation est également exécuté une fois l'animation terminée.",
    "summary_spanish": "La función register_animations se encarga de registrar y ejecutar una serie de animaciones. Recibe como argumento el objeto self, que presumably pertenece a una clase que gestiona animaciones.  El método itera sobre un conjunto de animaciones almacenadas en la propiedad class.animations. Para cada animación, llama a la función animate, pasando como parámetros el actor al que se aplicará la animación, las opciones de la animación y un bloque de código que se ejecutará al finalizar la animación.",
    "summary_portuguese": "register_animations! é uma função que itera sobre um conjunto de animações e as executa. Ela recebe o objeto self como argumento, que provavelmente representa uma classe. Para cada animação na lista, a função chama o método animate, passando o ator, as opções e o bloco de código a ser executado após a conclusão da animação.",
    "summary_arabic": "register_animations!  \n\nهذه الدالة مسؤولة عن تسجيل جميع الرسوم المتحركة في الفئة. تقوم الدالة بفحص كل رسم متحرك في قائمة الرسوم المتحركة الخاصة بالفئة، ثم تقوم بتشغيله على الممثل المحدد في الرسوم المتحركة باستخدام الخيارات المحددة في الرسوم المتحركة. عند الانتهاء من تشغيل الرسوم المتحركة، يتم تنفيذ الكود المحدد في كتلة on_complete_block.\n\narguments: \n- self:  \n\ntypes: \n- self:",
    "summary_hindi": "register_animations नामक फ़ंक्शन सभी एनिमेशन को रजिस्टर करता है। यह  self.class.animations  में मौजूद प्रत्येक एनिमेशन को लेता है और  animate  फ़ंक्शन को उस एनिमेशन के साथ कॉल करता है। animate फ़ंक्शन एनिमेशन के  actor,  options और  on_complete_block  का उपयोग करके एनिमेशन को चलाता है।"
  },
  {
    "id": "sample_70517",
    "language": "ruby",
    "length_bucket": "short",
    "code": "def fetch(fn)\n      return fn unless fn.instance_of? Symbol\n      respond_to?(fn) ? method(fn) : store.fetch(fn)\n    rescue\n      raise FunctionNotFoundError.new(fn, self)\n    end",
    "docstring": "Gets the procedure for creating a transproc\n\n @param [#call, Symbol] fn\n   Either the procedure, or the name of the method of the current module,\n   or the registered key of imported procedure in a store.\n\n @return [#call]",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `fetch` retrieves a function based on a given identifier. It first checks if the identifier is a symbol. If it is, it returns the identifier directly. Otherwise, it checks if the current object responds to a method with the given name. If so, it returns the corresponding method. If not, it fetches the function from a `store` using the identifier. If any error occurs during the process, it raises a `FunctionNotFoundError`. \n\nThe function takes one argument:\n\n* `fn`:  The identifier of the function to retrieve (can be a symbol or a string).",
    "summary_chinese": "该函数名为 `fetch`，用于根据给定的函数名或符号获取对应的函数对象。 \n\n它接受一个参数 `fn`，类型为任意对象。\n\n如果 `fn` 是一个符号，则直接返回 `fn`。否则，如果当前对象支持 `fn` 函数，则返回该函数对象；否则，从 `store` 中获取 `fn` 对应的函数对象。如果获取失败，则抛出 `FunctionNotFoundError` 异常。",
    "summary_french": "La fonction `fetch` récupère une fonction en fonction de son nom. Elle prend un argument `fn` qui peut être une chaîne de caractères ou un symbole. Si `fn` est un symbole, la fonction est renvoyée directement. Sinon, elle vérifie si l'objet courant répond à l'appel de la fonction `fn`. Si oui, la fonction est renvoyée. Sinon, elle consulte un magasin (`store`) pour récupérer la fonction. En cas d'erreur, une exception `FunctionNotFoundError` est levée.",
    "summary_spanish": "La función fetch busca una función dada por su nombre. Si el nombre es un símbolo, lo devuelve directamente. Si no, verifica si el objeto actual responde al nombre de la función. Si sí, devuelve el método correspondiente. De lo contrario, consulta un almacén (store) para obtener la función. En caso de error, lanza una excepción FunctionNotFoundError. \n\n\nArguments:\n\nfn (String o Symbol)",
    "summary_portuguese": "A função `fetch` busca uma função ou método. Ela recebe um argumento `fn` que pode ser um símbolo ou um nome de função. Se `fn` for um símbolo, a função é retornada diretamente. Caso contrário, a função verifica se o objeto possui o método `fn`. Se sim, o método é retornado. Caso contrário, a função busca o método no armazenamento `store` e o retorna. Se a função não for encontrada, uma exceção `FunctionNotFoundError` é lançada.",
    "summary_arabic": "The function `fetch` retrieves a function based on its name. It first checks if the input `fn` is a symbol. If it is, it returns `fn` directly. Otherwise, it checks if the object has a method with the name `fn`. If it does, it returns the method. If not, it fetches the function from a storage mechanism called `store`. If any error occurs during the process, it raises a `FunctionNotFoundError`.",
    "summary_hindi": "fetch नामक फ़ंक्शन किसी फ़ंक्शन को प्राप्त करने के लिए डिज़ाइन किया गया है। यह फ़ंक्शन एक आर्गुमेंट लेता है, जो fn नामक एक सिंबल या फ़ंक्शन का प्रतिनिधित्व करता है। यदि fn एक सिंबल नहीं है, तो फ़ंक्शन को सीधे वापस कर दिया जाता है। यदि fn एक सिंबल है, तो यह जाँच करता है कि क्या फ़ंक्शन को कॉल करने वाला ऑब्जेक्ट उस फ़ंक्शन को जानता है। यदि हाँ, तो फ़ंक्शन को वापस कर दिया जाता है। यदि नहीं, तो फ़ंक्शन को स्टोर से फ़ेच किया जाता है। यदि फ़ंक्शन नहीं पाया जाता है, तो FunctionNotFoundError त्रुटि उत्पन्न होती है।"
  },
  {
    "id": "sample_70647",
    "language": "ruby",
    "length_bucket": "short",
    "code": "def exec\n      result = method_missing(:exec)\n      disable_threading()\n      self.dispose\n      Qt::Internal.application_terminated = true\n      result\n    end",
    "docstring": "Delete the underlying C++ instance after exec returns\n Otherwise, rb_gc_call_finalizer_at_exit() can delete\n stuff that Qt::Application still needs for its cleanup.",
    "model_name": "gemma-2-9b-it",
    "summary_english": "exec, This function executes a string as code. It takes no arguments. The function first calls a method named 'exec' using method_missing. Then, it disables threading, disposes of the current object, sets a flag indicating application termination, and finally returns the result of the initial 'exec' call.",
    "summary_chinese": "该函数名为 exec，用于执行代码并终止应用程序。它接受一个参数，类型为 Symbol，代表要调用的方法名。函数首先调用名为 method_missing 的方法，传入 Symbol 参数，执行相应的代码。然后，它禁用多线程，销毁自身对象，并设置 Qt::Internal.application_terminated 为 True，最后返回 method_missing 的返回值。",
    "summary_french": "La fonction `exec` exécute une commande système. Elle prend aucun argument. La fonction appelle d'abord `method_missing(:exec)` pour exécuter la commande. Ensuite, elle désactive le multithreading, libère les ressources de l'objet courant avec `self.dispose`, marque l'application comme terminée avec `Qt::Internal.application_terminated = true` et retourne le résultat de l'exécution de la commande.",
    "summary_spanish": "La función `exec` ejecuta un comando externo. Recibe ningún argumento. Deshabilita el multihilo, libera los recursos de la aplicación y marca la aplicación como terminada. Luego, devuelve el resultado de la ejecución del comando.",
    "summary_portuguese": "A função `exec` executa o método `:exec` e desabilita o multithreading. Em seguida, ela finaliza o objeto atual (`self.dispose`) e sinaliza que a aplicação Qt foi encerrada (`Qt::Internal.application_terminated = true`).  A função retorna o resultado da execução do método `:exec`.",
    "summary_arabic": "The function 'exec' executes a method named 'exec' and then disables threading. It then disposes of the current object and sets a flag indicating application termination. Finally, it returns the result of the 'exec' method.",
    "summary_hindi": "यह फ़ंक्शन 'exec' नाम का है और यह एक एप्लिकेशन को निष्पादित करने के लिए जिम्मेदार है। यह 'method_missing(:exec)' को कॉल करके एप्लिकेशन को निष्पादित करता है। इसके बाद, यह 'disable_threading()' कॉल करके थ्रेडिंग को अक्षम करता है, 'self.dispose()' कॉल करके संसाधनों को मुक्त करता है और 'Qt::Internal.application_terminated = true' सेट करके एप्लिकेशन को समाप्त करता है। अंत में, यह 'result' वापस करता है।"
  },
  {
    "id": "sample_71595",
    "language": "ruby",
    "length_bucket": "short",
    "code": "def namespace\n      return '#' if Tml.config.disabled?\n      @namespace || Tml.config.cache[:namespace] || Tml.config.application[:key][0..5]\n    end",
    "docstring": "namespace of each cache key",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `namespace` determines a namespace string. It first checks if the Tml configuration is disabled, returning '#' if so. Otherwise, it tries to retrieve the namespace from instance variable `@namespace`, then from the Tml configuration cache, and finally from the first six characters of the application key.",
    "summary_chinese": "该函数名为 `namespace`，用于获取命名空间。它接受没有参数。其逻辑首先检查 `Tml.config.disabled?` 是否为真，如果是则返回 `#`。否则，它尝试获取 `@namespace` 的值，如果没有则尝试获取 `Tml.config.cache[:namespace]` 的值，如果没有则获取 `Tml.config.application[:key]` 的前六个字符。最后返回获取到的命名空间。",
    "summary_french": "La fonction `namespace` retourne le nom d'espace de noms à utiliser. Si Tml.config.disabled? est vrai, elle retourne '#'. Sinon, elle retourne la valeur de @namespace si elle est définie, sinon elle retourne la valeur de Tml.config.cache[:namespace], sinon elle retourne les 6 premiers caractères de Tml.config.application[:key].",
    "summary_spanish": "La función namespace determina el nombre del espacio de nombres a utilizar. Si Tml.config.disabled? es verdadero, devuelve '#'. De lo contrario, devuelve el valor de @namespace, o el valor almacenado en Tml.config.cache[:namespace], o los primeros 6 caracteres de Tml.config.application[:key].",
    "summary_portuguese": "A função namespace determina o namespace a ser utilizado. Se o Tml.config.disabled? for verdadeiro, retorna '#'. Caso contrário, retorna o valor de @namespace, ou o valor armazenado em Tml.config.cache[:namespace], ou os primeiros 6 caracteres de Tml.config.application[:key].",
    "summary_arabic": "function name: namespace\n\ndescription: This function determines the namespace to use.\n\narguments: none\n\nlogic: It first checks if the namespace is disabled. If it is, it returns '#'. Otherwise, it checks for an existing namespace, then uses the cache, and finally falls back to the first six characters of the application key.",
    "summary_hindi": "इस फ़ंक्शन का नाम `namespace` है। यह एक नामस्थान उत्पन्न करता है। यह फ़ंक्शन `Tml.config.disabled?` का उपयोग करके जांच करता है कि क्या Tml कॉन्फ़िगरेशन अक्षम है। यदि हाँ, तो यह '#' वापस करता है। अन्यथा, यह `@namespace` चर की जाँच करता है। यदि यह उपलब्ध है, तो यह वापस करता है। यदि नहीं, तो यह `Tml.config.cache[:namespace]` की जाँच करता है। यदि यह उपलब्ध नहीं है, तो यह `Tml.config.application[:key]` के पहले 6 अक्षरों को वापस करता है।"
  },
  {
    "id": "sample_71917",
    "language": "ruby",
    "length_bucket": "short",
    "code": "def url?(string)\n      return false unless string.to_s =~ url_pattern\n      return false if     string.to_s =~ @@placeholder\n      true\n    end",
    "docstring": "Identifies a valid URL for this REST instance",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function url? checks if a given string is a valid URL. It first ensures the string is a valid string using to_s. Then, it uses a regular expression `url_pattern` to match against the string. If the string doesn't match the pattern, it returns false. It also checks if the string contains a placeholder `@@placeholder` and returns false if it does. If both checks pass, it returns true, indicating the string is a valid URL. \n\nThe function takes one argument:\n\nstring (String)",
    "summary_chinese": "该函数名为 url?，用于判断一个字符串是否是一个有效的URL。它接受一个字符串类型的参数 string。首先，它使用正则表达式 url_pattern 检查字符串是否匹配URL模式。如果匹配，则继续检查字符串是否包含 @@placeholder。如果包含，则返回 false，否则返回 true。",
    "summary_french": "La fonction url? vérifie si une chaîne de caractères est une URL valide. Elle prend une chaîne de caractères en argument. La fonction utilise une expression régulière url_pattern pour vérifier si la chaîne correspond au format d'une URL. Elle vérifie également si la chaîne contient un marqueur @@placeholder, auquel cas elle retourne false. Si la chaîne correspond au format d'une URL et ne contient pas le marqueur, la fonction retourne true.",
    "summary_spanish": "La función url? determina si una cadena es una URL válida. Recibe una cadena como argumento. Primero, verifica si la cadena coincide con un patrón de URL. Si no coincide, devuelve false. Luego, verifica si la cadena coincide con un marcador de posición. Si coincide, devuelve false. Si la cadena coincide con el patrón de URL y no con el marcador de posición, devuelve true.",
    "summary_portuguese": "A função url? verifica se uma string é uma URL válida. Ela recebe uma string como argumento e retorna true se a string corresponder ao padrão de URL e não conter um marcador de posição. Caso contrário, retorna false.",
    "summary_arabic": "function url?  \n\nThis function checks if a given string is a valid URL. \n\nargument: string (string)\n\nlogic: \n- It first checks if the string matches a predefined URL pattern.\n- If it matches, it then checks if the string contains a placeholder.\n- If both conditions are met, it returns true, indicating a valid URL. Otherwise, it returns false.",
    "summary_hindi": "यह फ़ंक्शन `url?` नामक है और यह जांचता है कि एक दिया गया स्ट्रिंग एक वैध URL है या नहीं। यह स्ट्रिंग को `url_pattern` नामक एक रेगुलर एक्सप्रेशन के साथ तुलना करता है। यदि स्ट्रिंग `@@placeholder` नामक एक अन्य रेगुलर एक्सप्रेशन से मेल खाता है, तो यह फ़ंक्शन `false` वापस करता है। यदि स्ट्रिंग दोनों रेगुलर एक्सप्रेशन से मेल खाता है, तो यह `true` वापस करता है। \n\nयह फ़ंक्शन एक स्ट्रिंग `string` लेता है।"
  },
  {
    "id": "sample_70083",
    "language": "ruby",
    "length_bucket": "short",
    "code": "def build_active_record_enumerator_on_batches(scope, cursor:, **args)\n      enum = build_active_record_enumerator(\n        scope,\n        cursor: cursor,\n        **args\n      ).batches\n      wrap(self, enum)\n    end",
    "docstring": "Builds Enumerator from Active Record Relation and enumerates on batches.\n Each Enumerator tick moves the cursor +batch_size+ rows forward.\n\n +batch_size:+ sets how many records will be fetched in one batch. Defaults to 100.\n\n For the rest of arguments, see documentation for #build_active_record_enumerator_on_records",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `build_active_record_enumerator_on_batches` builds an enumerator for an Active Record scope, using batches. It takes a `scope` argument, which is an Active Record scope object. It also takes a `cursor` argument, which is used for pagination. Additionally, it accepts any keyword arguments (`**args`) that can be passed to the `build_active_record_enumerator` function. The function calls `build_active_record_enumerator` with the provided arguments and then extracts the `batches` attribute from the returned enumerator. Finally, it wraps the enumerator using the `wrap` function.",
    "summary_chinese": "该函数名为 `build_active_record_enumerator_on_batches`，用于在批次中构建一个 Active Record 枚举器。它接受 `scope`、`cursor` 和任意数量的 `args` 作为参数，其中 `scope` 是一个 Active Record 查询范围，`cursor` 是一个游标，`args` 是其他可选参数。该函数首先使用 `build_active_record_enumerator` 函数构建一个 Active Record 枚举器，并将 `cursor` 和 `args` 传递给该函数。然后，它使用 `wrap` 函数包装枚举器的批次结果，并返回包装后的结果。",
    "summary_french": "La fonction `build_active_record_enumerator_on_batches` construit un énumérateur ActiveRecord en lots. Elle prend en argument `scope` qui représente la portée de la requête, `cursor:` qui est un curseur, et des arguments supplémentaires `**args`. La fonction appelle `build_active_record_enumerator` avec les arguments fournis et récupère les lots de l'énumérateur résultant. Enfin, elle encapsule l'énumérateur dans une fonction `wrap` avant de le retourner.",
    "summary_spanish": "La función build_active_record_enumerator_on_batches crea un enumerador basado en registros activos en lotes. Recibe como argumentos un alcance (scope), un cursor (cursor) y cualquier otro argumento (args).  Construye un enumerador de registros activos utilizando el alcance, el cursor y los argumentos adicionales. Luego, envuelve el enumerador resultante en un objeto wrap.",
    "summary_portuguese": "A função build_active_record_enumerator_on_batches cria um enumerador para um conjunto de registros ativos, dividindo-os em lotes. Ela recebe um escopo, um cursor e argumentos adicionais. O escopo define os registros a serem incluídos, o cursor controla a posição de leitura e os argumentos adicionais podem ser usados para personalizar a consulta. A função cria um enumerador de registros com base no escopo, cursor e argumentos, e então envolve esse enumerador em um wrapper.",
    "summary_arabic": "function build_active_record_enumerator_on_batches  \nيقوم بإنشاء مُحدد ل سلسلة من سجلات قاعدة البيانات  \narguments:\nscope:  مُحدد ل سلسلة من سجلات قاعدة البيانات\ncursor:  مُحدد ل سلسلة من سجلات قاعدة البيانات\nargs:  قائمة من المتغيرات الإضافية \nlogic:\n1. إنشاء مُحدد ل سلسلة من سجلات قاعدة البيانات باستخدام  build_active_record_enumerator  مع  scope  و  cursor  و  args.\n2. الحصول على  batches  من المُحدد.\n3. تغليف  self  و  enum  باستخدام  wrap.",
    "summary_hindi": "यह फ़ंक्शन `build_active_record_enumerator_on_batches` नामक एक एन्यूमेरेटर बनाता है जो बैचों में डेटा देता है। यह `scope` और `cursor` नामक दो आवश्यक तर्क लेता है। `scope` एक सक्रिय रिकॉर्ड स्कोप है और `cursor` एक क्यूरीर है। यह `**args` नामक एक वैधियतपूर्ण तर्क भी लेता है जो अतिरिक्त विकल्पों को पास करता है। यह फ़ंक्शन `build_active_record_enumerator` फ़ंक्शन को कॉल करता है जो एक एन्यूमेरेटर बनाता है और फिर `batches` विधि का उपयोग करके इसे बैचों में विभाजित करता है। अंत में, यह एन्यूमेरेटर को `wrap` फ़ंक्शन के साथ लपेटता है।"
  },
  {
    "id": "sample_71372",
    "language": "ruby",
    "length_bucket": "short",
    "code": "def map(path_to_directory_source, options={})\n      path, root_dir = path_to_directory_source.to_a.first\n      config = self.load(@site, root_dir, {:path_prefix => path})\n      @site.add_config(config)\n    end",
    "docstring": "INSTANCE METHODS\n\n\n accepts a file_path to a configuration file.\n\n\n map('/path' => '../othersite')",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `map` processes a directory path and loads configuration data. It takes two arguments: `path_to_directory_source` (a string representing the directory path) and `options` (a hash of optional parameters, defaulting to an empty hash). The function extracts the path and root directory from the input path. It then loads configuration data from the specified directory using the `load` method, passing in the site object, root directory, and path prefix. Finally, it adds the loaded configuration to the site using `@site.add_config`.",
    "summary_chinese": "该函数名为 `map`，用于加载配置并添加到 Jekyll 网站中。它接受两个参数：`path_to_directory_source` 类型为字符串，表示源目录路径；`options` 类型为字典，可选参数。函数首先从 `path_to_directory_source` 中提取路径和根目录，然后使用 `load` 方法加载配置，并将路径前缀添加到配置中。最后，使用 `add_config` 方法将加载的配置添加到 Jekyll 网站中。",
    "summary_french": "La fonction `map` charge les configurations d'un répertoire source. Elle prend en argument `path_to_directory_source` (une chaîne de caractères représentant le chemin vers le répertoire source) et `options` (un dictionnaire optionnel). La fonction extrait le chemin et le répertoire racine du chemin source. Ensuite, elle charge les configurations à partir du répertoire racine en utilisant le fichier `@site` et les options spécifiées. Enfin, elle ajoute les configurations chargées à l'objet `@site`.",
    "summary_spanish": "La función map toma un directorio de origen y una colección de opciones como argumentos. Extrae el camino y el directorio raíz del directorio de origen. Carga una configuración desde el sitio web, utilizando el directorio raíz y un prefijo de ruta. Agrega la configuración cargada al sitio web.",
    "summary_portuguese": "A função `map` processa um diretório de origem e adiciona suas configurações ao site. Ela recebe o caminho para o diretório de origem como argumento `path_to_directory_source` e um dicionário opcional `options`. A função extrai o caminho e o diretório raiz do caminho fornecido, carrega as configurações do diretório usando o objeto `@site` e o diretório raiz, e adiciona essas configurações ao objeto `@site`.",
    "summary_arabic": "map هو دالة تقوم بتحميل وتطبيق ملفات الإعدادات من مجلد المصدر إلى موقع الموقع. \n\nتستقبل الدالة `path_to_directory_source` وهو سلسلة نصية تمثل مسار المجلد المصدر، و `options` وهو خريطة من القيم الإعدادية. \n\nتُحصل من `path_to_directory_source` على مسار الملف الأول واسم المجلد الجذر. ثم يتم تحميل ملف الإعدادات باستخدام `load` مع موقع الموقع، مسار المجلد الجذر، وخيارات الإعدادات. أخيرًا، يتم إضافة ملف الإعدادات إلى موقع الموقع باستخدام `add_config`.",
    "summary_hindi": "यह फ़ंक्शन `map` नाम का है और इसका उद्देश्य एक निर्देशिका से कॉन्फ़िगरेशन लोड करना और साइट में जोड़ना है। यह दो आर्गुमेंट्स लेता है: `path_to_directory_source` जो एक स्ट्रिंग है और `options` जो एक डिक्शनरी है। यह फ़ंक्शन निर्देशिका के पथ से कॉन्फ़िगरेशन लोड करता है और उसे साइट में जोड़ता है।"
  },
  {
    "id": "sample_70597",
    "language": "ruby",
    "length_bucket": "short",
    "code": "def is_in_map(v)\n      v.x >= 0 && v.y >= 0 && v.x < @size.x && v.y < @size.y\n    end",
    "docstring": "Verifies whether a tile is inside the map.\n\n Parameters:\n [v] A Vector representing the tile, with x as the horizontal index and\n     y as the vertical index.",
    "model_name": "gemma-2-9b-it",
    "summary_english": "is_in_map checks if a point is within the bounds of a map. It takes a single argument, v, which is a struct with x and y coordinates. The function returns true if both x and y coordinates are non-negative and less than the map's size in both dimensions.",
    "summary_chinese": "is_in_map 函数用于判断一个点是否在地图范围内。 \n\n参数：v (一个包含 x 和 y 坐标的结构体)\n\n逻辑：检查点的 x 和 y 坐标是否都在地图边界内。",
    "summary_french": "La fonction `is_in_map` vérifie si un point est situé dans une carte. Elle prend un argument `v` de type objet ayant des attributs `x` et `y` représentant les coordonnées du point. La fonction renvoie `true` si les coordonnées sont comprises dans les limites de la carte définies par `@size.x` et `@size.y`, et `false` sinon.",
    "summary_spanish": "La función is_in_map determina si un punto está dentro de un mapa. Recibe un argumento v de tipo objeto con atributos x e y. La lógica principal verifica si las coordenadas x e y del punto están dentro de los límites del mapa, especificados por los atributos @size.x y @size.y.",
    "summary_portuguese": "is_in_map verifica se um ponto está dentro de um mapa. \n\nRecebe um argumento: v, que é um objeto com atributos x e y.\n\nA lógica verifica se as coordenadas x e y do ponto estão dentro dos limites do mapa, definidos pelas variáveis @size.x e @size.y.",
    "summary_arabic": "function is_in_map takes a variable v as input. The function checks if the coordinates (x, y) of the variable v are within the boundaries of a map. It returns true if the coordinates are within the map's boundaries, and false otherwise. The variable v is assumed to have x and y attributes representing its coordinates. @size.x and @size.y represent the width and height of the map, respectively.",
    "summary_hindi": "इस फ़ंक्शन का नाम `is_in_map` है। यह यह जांचने के लिए उपयोग किया जाता है कि एक बिंदु एक मानचित्र के भीतर है या नहीं। यह एक `v` नामक एक ऑब्जेक्ट लेता है जिसमें `x` और `y` गुण होते हैं। यह जांच करता है कि `v.x` और `v.y` मान `@size.x` और `@size.y` के बीच हैं, जो मानचित्र के आकार को दर्शाते हैं। यदि दोनों स्थितियां सत्य हैं, तो फ़ंक्शन `true` वापस करता है, अन्यथा `false`।"
  },
  {
    "id": "sample_70296",
    "language": "ruby",
    "length_bucket": "short",
    "code": "def asin(input, name: nil)\n      check_allowed_types(input, FLOATING_POINT_TYPES)\n      _op(:asin, input, name: name)\n    end",
    "docstring": "Computes asin of input element-wise",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `asin` calculates the arcsine of a floating-point number. It takes an `input` of type FLOATING_POINT_TYPES and an optional `name` argument of type nil. The function first checks if the input type is valid using `check_allowed_types`. Then, it calls the internal function `_op` with the `:asin` operation, the input value, and the optional name.",
    "summary_chinese": "该函数名为 asin，用于计算输入值的反正弦。它接受两个参数：input 类型为浮点数，name 类型为 nil。函数首先检查输入类型是否为浮点数，然后调用 _op 函数，传入 asin 操作符和输入值，并可选地传入 name 参数。",
    "summary_french": "La fonction `asin` calcule l'arcsinus d'un nombre. Elle prend en argument `input` qui doit être un nombre à virgule flottante et un argument optionnel `name` de type nil. La fonction vérifie que le type de `input` est un type de nombre à virgule flottante. Ensuite, elle appelle une opération interne `:asin` avec `input` et le nom `name`.",
    "summary_spanish": "La función asin calcula el seno inverso de un valor. Recibe un argumento llamado input de tipo flotante y un argumento opcional llamado name de tipo nil. Primero, verifica que el tipo de input sea un tipo de punto flotante. Luego, llama a la operación asin con el input y el nombre opcional.",
    "summary_portuguese": "A função asin calcula o seno inverso de um valor. Ela recebe um argumento input do tipo ponto flutuante e um argumento opcional name do tipo nil. A função verifica se o tipo de input é um tipo de ponto flutuante permitido e então chama a operação :asin com o input e o nome opcional.",
    "summary_arabic": "The function asin calculates the arcsine of a floating-point number. It takes two arguments: input, which is a floating-point number, and name, which is optional and of type nil. The function first checks if the input is of a valid floating-point type. Then, it calls an internal function _op with the asin operation, the input value, and the optional name.",
    "summary_hindi": "इस फ़ंक्शन का नाम `asin` है। यह एक त्रिकोणमितीय फ़ंक्शन है जो किसी कोण के साइन इनवर्स (arcsine) की गणना करता है। यह फ़ंक्शन एक मान्य मान के रूप में `input` लेता है जो फ्लोटिंग पॉइंट प्रकार का होना चाहिए। यह एक वैकल्पिक `name` मान भी ले सकता है जो `nil` प्रकार का हो सकता है। फ़ंक्शन `check_allowed_types` फ़ंक्शन का उपयोग करके `input` मान को फ्लोटिंग पॉइंट प्रकार के रूप में सत्यापित करता है। फिर, यह `_op` फ़ंक्शन को बुलाता है, जिसमें `asin` ऑपरेशन, `input` मान और `name` मान पारित किए जाते हैं।"
  },
  {
    "id": "sample_70474",
    "language": "ruby",
    "length_bucket": "short",
    "code": "def execution(reload=false)\n\n      exid = @values[:exid]; return nil unless exid\n\n      @flor_model_cache_execution = nil if reload\n\n      @flor_model_cache_execution ||= unit.executions[exid: exid]\n    end",
    "docstring": "Return a Flor::Execution instance linked to this model",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `execution` retrieves execution details from a cache. It takes an optional boolean argument `reload` which, if true, clears the cache. The function first checks if an `exid` value is present in the `@values` array. If not, it returns `nil`. It then checks if the `@flor_model_cache_execution` variable is set and clears it if `reload` is true. If not set, it fetches execution details from the `unit.executions` hash using the `exid` as the key and stores it in `@flor_model_cache_execution`.",
    "summary_chinese": "该函数名为 execution，用于根据指定的 exid 获取执行信息。它接受一个可选参数 reload，类型为布尔值，默认为 False。如果 exid 不存在，则返回 nil。如果 reload 为 True，则清空 @flor_model_cache_execution 缓存。否则，从 unit.executions 中根据 exid 获取执行信息并缓存到 @flor_model_cache_execution 中。",
    "summary_french": "La fonction `execution` vérifie si un identifiant d'exécution (`exid`) est fourni. Si non, elle retourne `nil`. Elle vérifie ensuite si le cache d'exécution du modèle `flor` doit être rechargé. Si oui, elle le vide. Sinon, elle récupère l'exécution correspondante à l'identifiant `exid` du cache. \n\n\nArguments:\n\nreload (boolean): Indique si le cache doit être rechargé.\n\n\nLogique:\n\n- Vérifie la présence de l'identifiant d'exécution.\n- Vide le cache si `reload` est vrai.\n- Récupère l'exécution du cache si `reload` est faux.",
    "summary_spanish": "La función `execution` verifica si existe un identificador de ejecución (`exid`) y, si lo hace, recupera la ejecución correspondiente del caché. Si `reload` es verdadero, borra el caché. De lo contrario, utiliza el caché si está disponible. \n\n\nArguments:\n\nreload: boolean\n\n\nLogic:\n\nComprueba si `exid` está presente en `@values`. Si no está presente, devuelve `nil`. Si `reload` es verdadero, borra el caché `@flor_model_cache_execution`. Si `reload` es falso y el caché no está vacío, devuelve el valor del caché. De lo contrario, recupera la ejecución del identificador `exid` del objeto `unit.executions` y la almacena en el caché.",
    "summary_portuguese": "A função `execution` verifica se um identificador de execução (`exid`) foi fornecido. Se não, retorna `nil`. Se `reload` for `true`, a cache de execução do modelo `flor` é limpa. Caso contrário, a função busca a execução correspondente ao `exid` na cache. \n\n\nArguments:\n\nreload: boolean\n\n\nLogic:\n\n- Verifica se `exid` está presente.\n- Se `reload` for `true`, limpa a cache de execução.\n- Caso contrário, busca a execução na cache.",
    "summary_arabic": "function execution takes a boolean argument reload. It retrieves the execution with the id specified in the exid variable from the unit.executions array. If reload is true, it clears the cached execution. Otherwise, it retrieves the cached execution if it exists. If no execution id is found, it returns nil.",
    "summary_hindi": "execution नामक फ़ंक्शन एक्सिक्यूशन के डेटा को लोड करता है। यह reload  परमिटर लेता है जो एक बूलियन प्रकार का होता है।  यदि exid मान्य है तो यह  @flor_model_cache_execution  में exid के साथ मेल खाने वाले एक्सिक्यूशन डेटा को स्टोर करता है। यदि reload सत्य है तो  @flor_model_cache_execution  को रीसेट कर दिया जाता है।"
  },
  {
    "id": "sample_70437",
    "language": "ruby",
    "length_bucket": "short",
    "code": "def logger\n      @logger ||= begin\n        logger      = SemanticLogger::Processor.logger.clone\n        logger.name = self.class.name\n        logger\n      end\n    end",
    "docstring": "Give each appender its own logger for logging.\n For example trace messages sent to services or errors when something fails.",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `logger` establishes a logger instance for the current class. It uses a lazy initialization technique, creating the logger only when it's first accessed. The logger is a clone of the default SemanticLogger::Processor logger, with its name set to the name of the current class.",
    "summary_chinese": "该函数名为 logger，用于获取或创建日志记录器。它接受一个参数 self，类型为对象。该函数首先检查是否存在一个名为 logger 的实例变量，如果存在则直接返回该实例变量。否则，它创建一个新的日志记录器实例，将该实例的名称设置为当前类的名称，并将其赋值给 logger 实例变量，最后返回该实例变量。",
    "summary_french": "La fonction `logger` initialise et retourne un logger SemanticLogger. Elle utilise un logger existant (`SemanticLogger::Processor.logger`) et le clone. Le nom du logger cloné est défini comme le nom de la classe de l'objet qui appelle la fonction.",
    "summary_spanish": "La función logger establece un registro de SemanticLogger para la clase actual. Si ya existe un registro, lo devuelve. De lo contrario, crea un nuevo registro a partir del registro predeterminado de SemanticLogger, establece su nombre como el nombre de la clase actual y lo devuelve.  \n\nEl argumento de la función es self, que representa la instancia actual de la clase.",
    "summary_portuguese": "A função logger define um logger personalizado para a classe atual. Ela cria um logger a partir do logger padrão do SemanticLogger, clona-o e define o nome do logger como o nome da classe atual. O logger é armazenado em uma variável de classe chamada logger e é retornado.",
    "summary_arabic": "The function logger creates or retrieves a logger instance. It initializes a new logger object by cloning the default SemanticLogger::Processor.logger and sets its name to the class name of the current object. If a logger instance already exists, it returns the existing one.",
    "summary_hindi": "यह फ़ंक्शन `logger` नाम का है और इसका उद्देश्य एक SemanticLogger प्रोसेसर का एक क्लाउन बनाना और उसे वर्तमान क्लास के नाम से नामित करना है। यह फ़ंक्शन `logger ||= begin ... end` का उपयोग करके एक लेजर बनाता है जो पहले से ही मौजूद है या नहीं, यह जांचता है। यदि लेजर पहले से मौजूद नहीं है, तो यह एक नया लेजर बनाता है, इसे क्लास के नाम से नामित करता है और इसे लौटाता है।"
  },
  {
    "id": "sample_71294",
    "language": "ruby",
    "length_bucket": "short",
    "code": "def parameter(*names)\n      names.each do |name|\n        define_singleton_method(name) do |*values|\n          if (value = values.first)\n            instance_variable_set(\"@#{name}\", value)\n          else\n            instance_variable_get(\"@#{name}\")\n          end\n        end\n      end\n    end",
    "docstring": "Creates simple configuration parameters which may be set by the user\n @param names [Array<Symbol>] the names of the parameters to create",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function parameter allows a class to dynamically define methods for accessing and setting instance variables. It takes a variable number of arguments, each representing a name for a new method. For each name provided, it creates a singleton method within the class. This method accepts an optional argument. If an argument is provided, it sets the corresponding instance variable to that value. If no argument is provided, it returns the value of the corresponding instance variable.",
    "summary_chinese": "该函数名为 `parameter`，用于动态添加实例方法，这些方法用于设置和获取实例变量。它接受一个可变参数 `*names`，其中包含字符串，代表要添加的方法名称。 对于每个传入的 `name`，函数都会定义一个单例方法，该方法接受一个可变参数 `*values`。 如果 `values` 包含至少一个值，则该值会被赋值给对应名称的实例变量；否则，会返回对应名称的实例变量的值。",
    "summary_french": "La fonction `parameter` permet de définir des méthodes d'instance dynamiques pour un objet. Elle prend un nombre variable d'arguments `names` qui sont des chaînes de caractères représentant les noms des paramètres. Pour chaque nom de paramètre, elle définit une méthode d'instance qui permet de lire ou d'écrire la valeur associée à ce paramètre. Si un seul argument est fourni à la méthode, il est utilisé pour définir la valeur du paramètre. Sinon, la méthode retourne la valeur actuelle du paramètre.",
    "summary_spanish": "La función parameter permite definir métodos de instancia dinámicos para un objeto. Recibe un número variable de argumentos, cada uno de los cuales representa el nombre de un método. Para cada nombre proporcionado, crea un método de instancia que puede aceptar un valor como argumento. Si se proporciona un valor, se asigna como un atributo de instancia con el nombre correspondiente. Si no se proporciona un valor, el método devuelve el valor del atributo de instancia con ese nombre.",
    "summary_portuguese": "A função `parameter` permite definir métodos de acesso a atributos dinâmicos em um objeto. Ela recebe um número variável de nomes de atributos como argumento (`*names`). Para cada nome fornecido, a função define um método de acesso em singleton no objeto. Esse método aceita um valor opcional como argumento. Se um valor for fornecido, ele é atribuído ao atributo correspondente no objeto. Caso contrário, o método retorna o valor do atributo.",
    "summary_arabic": "The function parameter allows you to define named parameters for an object. It takes a variable number of string arguments representing parameter names. For each name, it creates a method on the object that can be used to set or get the value associated with that parameter. If a value is provided as an argument to the method, it sets the corresponding instance variable. Otherwise, it returns the value of the instance variable.",
    "summary_hindi": "यह फ़ंक्शन `parameter` नाम से जाना जाता है और यह किसी ऑब्जेक्ट में कई नामित पॅरमिटर जोड़ने के लिए इस्तेमाल किया जाता है। यह एक स्टार पैरामीटर `*names` लेता है जो स्ट्रिंग्स का एक एरे है।  प्रत्येक स्ट्रिंग को एक सिंगलटन मेथड के रूप में परिभाषित किया जाता है जो दो प्रकार के आर्गुमेंट्स ले सकता है: एक वैल्यू जो `@#{name}` नामक एक इंस्टेंस वेरिएबल में सेट की जाती है, या कोई वैल्यू नहीं, जिस स्थिति में `@#{name}` इंस्टेंस वेरिएबल का मान वापस किया जाता है।"
  },
  {
    "id": "sample_70433",
    "language": "ruby",
    "length_bucket": "short",
    "code": "def box(message)\n      nonce = generate_nonce\n      cipher_text = @box.box(nonce, message)\n      nonce + cipher_text\n    end",
    "docstring": "Encrypts the message with a random nonce\n\n Encrypts the message with a random nonce, then returns the ciphertext with\n the nonce prepended.  Optionally encodes the message using an encoder.\n\n @param message [String] The message to encrypt\n\n @return [String] The enciphered message",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `box` encrypts a message using a symmetric encryption scheme. It takes a single argument, `message`, which is a string. The function generates a random nonce, encrypts the message using the nonce and a secret key stored in the `@box` object, and then concatenates the nonce and the ciphertext.",
    "summary_chinese": "函数名为 box，用于对消息进行加密。 \n\n参数：message (字符串)\n\n逻辑：生成一个随机数 nonce，使用 @box.box 函数对 nonce 和消息进行加密，并将 nonce 和密文拼接在一起返回。",
    "summary_french": "La fonction `box` crypte un message. Elle prend un argument `message` de type chaîne de caractères. Elle génère un nonce aléatoire, chiffre le message en utilisant la fonction `@box.box` avec le nonce et renvoie la concaténation du nonce et du texte chiffré.",
    "summary_spanish": "La función `box` cifra un mensaje. Recibe un argumento llamado `message` de tipo cadena. Genera un nonce usando la función `generate_nonce`. Luego, cifra el mensaje usando la función `@box.box` con el nonce generado. Finalmente, concatena el nonce y el texto cifrado y lo devuelve.",
    "summary_portuguese": "A função `box` cifra uma mensagem usando um algoritmo de cifra simétrica. Ela recebe uma mensagem como argumento e retorna a mensagem cifrada concatenada com um nonce. O nonce é gerado internamente pela função. A cifra em si é realizada pela chamada a um método `box` dentro da própria classe, que recebe o nonce e a mensagem como argumentos.",
    "summary_arabic": "function box  encrypt a message using a nonce. \n\narguments:\nmessage: string\n\nlogic:\ngenerates a nonce, encrypts the message using the nonce, and concatenates the nonce and the ciphertext.",
    "summary_hindi": "यह फ़ंक्शन 'box' नामक एक एन्क्रिप्शन फ़ंक्शन है। यह एक संदेश को एन्क्रिप्ट करने के लिए एक नॉनस और बॉक्स एल्गोरिथ्म का उपयोग करता है। यह फ़ंक्शन एक 'message' नामक एक स्ट्रिंग मान लेता है। यह एक नॉनस उत्पन्न करता है, फिर बॉक्स एल्गोरिथ्म का उपयोग करके नॉनस और संदेश को एन्क्रिप्ट करता है। अंत में, यह नॉनस और एन्क्रिप्टेड संदेश को वापस देता है।"
  },
  {
    "id": "sample_71494",
    "language": "ruby",
    "length_bucket": "short",
    "code": "def to_lon format, dp\n      return lon if !format\n      GeoUnits::Converter.to_lon lon, format, dp\n    end",
    "docstring": "Returns the longitude of this point; signed numeric degrees if no format, otherwise format & dp\n as per Geo.toLon()\n\n @param   [String} [format]: Return value as 'd', 'dm', 'dms'\n @param   [Number} [dp=0|2|4]: No of decimal places to display\n @return [Number|String} Numeric degrees if no format specified, otherwise deg/min/sec\n\n @requires Geo",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `to_lon` converts a longitude value to a specified format with a given number of decimal places. It takes three arguments: `format` (a string), `dp` (an integer), and `lon` (a number). If `format` is not provided, it returns the original `lon` value. Otherwise, it uses the `GeoUnits::Converter.to_lon` function to perform the conversion, passing `lon`, `format`, and `dp` as arguments.",
    "summary_chinese": "该函数名为 to_lon，用于将经度值转换为指定格式。它接受三个参数：format（字符串，指定经度格式），dp（整数，指定小数点后位数）。如果 format 为空，则直接返回原始经度值；否则，调用 GeoUnits::Converter.to_lon 函数进行转换，并将转换后的经度值返回。",
    "summary_french": "La fonction `to_lon` convertit une valeur de longitude. Elle prend trois arguments : `format`, qui spécifie le format de sortie souhaité, `dp`, qui indique le nombre de décimales à afficher, et `lon`, qui est la valeur de longitude à convertir. Si `format` est absent, la fonction retourne la valeur de `lon` sans modification. Sinon, elle utilise la classe `GeoUnits::Converter` pour convertir `lon` dans le format spécifié avec le nombre de décimales désiré.",
    "summary_spanish": "La función to_lon convierte un valor de longitud a un formato específico. Recibe tres argumentos: format, un símbolo que indica el formato de salida, dp, un número que especifica la cantidad de decimales, y lon, el valor de longitud a convertir. Si el argumento format es falso, devuelve el valor lon sin cambios. De lo contrario, utiliza la clase GeoUnits::Converter para convertir lon al formato especificado con la cantidad de decimales indicada.",
    "summary_portuguese": "A função to_lon converte um valor de longitude para um formato especificado. Ela recebe três argumentos: format, um símbolo indicando o formato desejado; dp, um número inteiro representando a precisão decimal; e lon, o valor de longitude a ser convertido. Se o argumento format for falso, a função retorna o valor lon diretamente. Caso contrário, ela utiliza a função to_lon da classe GeoUnits::Converter para converter lon para o formato especificado com a precisão dp.",
    "summary_arabic": "The function `to_lon` converts a longitude value to a specified format with a given number of decimal places. It takes three arguments: `format`, a string indicating the desired format, `dp`, an integer representing the number of decimal places, and `lon`, a numeric longitude value. If `format` is not provided, it returns the original `lon` value. Otherwise, it uses the `GeoUnits::Converter.to_lon` method to perform the conversion.",
    "summary_hindi": "इस फ़ंक्शन का नाम `to_lon` है। यह एक मान को दिए गए प्रारूप और दशमलव स्थानों के साथ लंबी अक्षांश में परिवर्तित करता है। यह दो मानों को लेता है: `format` जो एक स्ट्रिंग है और `dp` जो एक इंटीजर है। यदि `format` खाली है, तो यह मान को बिना किसी परिवर्तन के लौटा देता है। अन्यथा, यह `GeoUnits::Converter.to_lon` फ़ंक्शन को `lon`, `format` और `dp` मानों के साथ कॉल करता है और परिणाम लौटाता है।"
  },
  {
    "id": "sample_71627",
    "language": "ruby",
    "length_bucket": "short",
    "code": "def add_node(node)\n      if node.respond_to?(:to_sym)\n        node = Woodhouse::Layout::Node.new(node.to_sym)  \n      end\n      expect_arg :node, Woodhouse::Layout::Node, node\n      @nodes << node\n      node\n    end",
    "docstring": "Adds a Node to this layout. If +node+ is a Symbol, a Node will be\n automatically created with that name.\n\n   # Example:\n\n   layout.add_node Woodhouse::Layout::Node.new(:isis)\n\n   # Is equivalent to\n\n   layout.add_node :isis",
    "model_name": "gemma-2-9b-it",
    "summary_english": "add_node takes a node argument. If the argument responds to :to_sym, it converts it to a Woodhouse::Layout::Node. It then expects the argument to be a Woodhouse::Layout::Node and appends it to the @nodes array. Finally, it returns the node.",
    "summary_chinese": "add_node 函数用于向节点列表中添加一个新的节点。它接受一个名为 node 的参数，其类型为任何对象。如果参数 node 能够被转换为符号，则将其转换为 Woodhouse::Layout::Node 对象。然后，函数检查参数 node 的类型是否为 Woodhouse::Layout::Node，并将其添加到 @nodes 列表中。最后，函数返回添加的节点。",
    "summary_french": "La fonction `add_node` ajoute un nœud à une collection de nœuds. Elle prend un argument `node` de type quelconque. Si l'argument `node` répond à la méthode `to_sym`, il est converti en un objet `Woodhouse::Layout::Node`. Ensuite, l'argument `node` est vérifié et ajouté à la collection `@nodes`. La fonction retourne le nœud ajouté.",
    "summary_spanish": "La función add_node agrega un nuevo nodo a una colección de nodos. Recibe un argumento llamado node que puede ser un símbolo o un objeto Woodhouse::Layout::Node. Si el argumento es un símbolo, se crea un nuevo objeto Woodhouse::Layout::Node a partir de él. Luego, se verifica que el argumento sea un objeto Woodhouse::Layout::Node y se agrega al conjunto de nodos @nodes. Finalmente, se devuelve el nodo agregado.",
    "summary_portuguese": "add_node adiciona um nó a uma coleção de nós. \n\nArgumentos:\nnode: Woodhouse::Layout::Node\n\nLógica:\nSe o argumento 'node' responder ao método :to_sym, ele é convertido para um novo objeto Woodhouse::Layout::Node. \nO argumento 'node' é então verificado e adicionado à coleção de nós (@nodes). \nO método retorna o nó adicionado.",
    "summary_arabic": "add_node  يضيف عقدة جديدة إلى مجموعة العقد. يتقبل  arg واحد وهو node من نوع Woodhouse::Layout::Node.  إذا كان المدخل  node  يرد على  :to_sym ، يتم تحويله إلى  Woodhouse::Layout::Node.  ثم يتم انتظار  arg  node  من نوع  Woodhouse::Layout::Node  وإضافته إلى  @nodes.  يعود  node  المضاف.",
    "summary_hindi": "add_node नामक फ़ंक्शन एक नया नोड जोड़ता है। यह एक नोड argument लेता है जो Woodhouse::Layout::Node या इसके सिंबल रूपांतरण हो सकता है। यदि argument सिंबल रूप में है, तो इसे Woodhouse::Layout::Node में परिवर्तित किया जाता है। फिर यह argument को @nodes नामक एक संग्रह में जोड़ता है और वापस आता है।"
  },
  {
    "id": "sample_70850",
    "language": "ruby",
    "length_bucket": "medium",
    "code": "def pre_render\n      if options[:collapse]\n        content_tag :div, class: join_classes(\"collapse\", show), id: options[:collapse], \"data-parent\": \"##{ options[:parent_collapse] }\" do\n          content_tag :div, @items.join.html_safe, html_options\n        end\n      else\n        content_tag :div, @items.join.html_safe, html_options\n      end\n    end",
    "docstring": "See UiBibz::Ui::Core::Component.initialize\n Render html tag",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `pre_render` generates HTML code for a collapsible div element. It takes an options hash as input. If the `:collapse` key in the options hash is present, it creates a collapsible div with the specified ID and parent collapse ID. The content of the div is generated by joining the `@items` array using `html_safe` and wrapping it in a div tag with the specified HTML options. Otherwise, it simply joins the `@items` array using `html_safe` and wraps it in a div tag with the specified HTML options.",
    "summary_chinese": "该函数名为 `pre_render`，用于根据 `options[:collapse]` 参数决定是否将内容折叠。如果 `options[:collapse]` 为真，则将内容包裹在 `div` 元素中，并添加 `collapse` 和 `show` 类，以及 `id` 和 `data-parent` 属性，用于折叠效果。否则，将内容直接包裹在 `div` 元素中。 \n\n参数：\n\n* `options`：一个哈希，包含 `collapse` 和 `parent_collapse` 键。\n* `@items`：一个字符串或数组，包含要渲染的内容。\n* `html_options`：一个哈希，包含额外的 HTML 属性。",
    "summary_french": "La fonction `pre_render` gère l'affichage de contenu en fonction de l'option `collapse`. Si `collapse` est défini, le contenu est encapsulé dans un élément `div` avec la classe \"collapse\" et d'autres attributs. Le contenu est ensuite affiché à l'intérieur d'un autre élément `div`. Sinon, le contenu est simplement encapsulé dans un élément `div`. \n\nArguments:\n\n* `options`: Un hash contenant les options de rendu, notamment `collapse` et `parent_collapse`.\n* `@items`: Une collection d'éléments à afficher.\n* `html_options`: Un hash contenant les options HTML pour l'élément `div`. \n\n\nLa fonction utilise la méthode `join` pour concaténer les éléments de `@items` en une chaîne HTML.",
    "summary_spanish": "La función pre_render determina si un elemento debe ser renderizado como colapsable o no. Si la opción :collapse es verdadera, el contenido se envuelve en un div con la clase \"collapse\" y un id que coincide con la opción :collapse. Además, se establece un atributo \"data-parent\" que apunta al id del elemento padre que contiene el collapse. Si la opción :collapse es falsa, el contenido se envuelve simplemente en un div.  El argumento `options` es un hash que contiene las opciones de renderizado, incluyendo :collapse y :parent_collapse. El argumento `@items` es una colección de elementos que se unirán y renderizarán. El argumento `html_options` es un hash que contiene opciones HTML adicionales para el div.",
    "summary_portuguese": "A função pre_render verifica se a opção :collapse está definida. Se estiver, cria um elemento div com a classe 'collapse' e o ID definido em :collapse. O conteúdo é gerado a partir da concatenação dos elementos @items e inserido dentro de outro div. Caso contrário, cria um elemento div com o conteúdo gerado a partir da concatenação dos elementos @items.  \n\n\nArguments:\n\noptions: um hash com as opções de renderização, incluindo :collapse e :parent_collapse.\n@items: uma coleção de elementos a serem renderizados.\nhtml_options: um hash com opções HTML para o elemento div.",
    "summary_arabic": "الوظيفة اسمها pre_render وتستخدم لعرض محتوى. يأخذ الوظيفة خيارين: collapse و parent_collapse. إذا كان خيار collapse صحيحًا، يتم لف المحتوى داخل عنصر div مع فئة collapse و id و data-parent. وإلا، يتم عرض المحتوى مباشرةً داخل عنصر div.",
    "summary_hindi": "यह फ़ंक्शन `pre_render` नाम का है और यह HTML कोड उत्पन्न करता है। यह फ़ंक्शन `options` नामक एक हैशमैप और `@items` नामक एक एर्रे को लेता है। यदि `options[:collapse]` सत्य है, तो यह एक \"collapse\" क्लास वाला एक डिव टैग उत्पन्न करता है जो `@items` एर्रे के तत्वों को जोड़ता है। अन्यथा, यह केवल `@items` एर्रे के तत्वों को जोड़ने वाला एक डिव टैग उत्पन्न करता है।"
  },
  {
    "id": "sample_70934",
    "language": "ruby",
    "length_bucket": "medium",
    "code": "def build_slug\n      if localized?\n        begin\n          orig_locale = I18n.locale\n          all_locales.each do |target_locale|\n            I18n.locale = target_locale\n            apply_slug\n          end\n        ensure\n          I18n.locale = orig_locale\n        end\n      else\n        apply_slug\n      end\n      true\n    end",
    "docstring": "Builds a new slug.\n\n @return [true]",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function build_slug determines and sets a slug for a given object. It first checks if the object is localized. If it is, it iterates through all target locales, sets the locale for each iteration, and applies a slug generation function called apply_slug. After processing all locales, it restores the original locale. If the object is not localized, it directly calls apply_slug.  The function returns true. \n\n\nThe function takes no arguments.",
    "summary_chinese": "该函数名为 `build_slug`，用于生成 URL 标识符。 \n\n如果 `localized?` 为真，则会遍历所有目标语言，分别设置语言环境，并调用 `apply_slug` 函数生成标识符。最后恢复到原始语言环境。 \n\n如果 `localized?` 为假，则直接调用 `apply_slug` 函数生成标识符。",
    "summary_french": "La fonction build_slug construit un slug pour un élément. Si la localisation est activée, elle applique le slug pour chaque locale cible. Sinon, elle applique le slug directement. \n\n\nElle prend en argument un élément. \n\n\nLa fonction utilise un bloc `begin...ensure` pour gérer la localisation. Elle sauvegarde la locale initiale, puis parcourt chaque locale cible, change la locale et applique le slug. Enfin, elle restaure la locale initiale.",
    "summary_spanish": "La función build_slug se encarga de generar un slug para un recurso. Si el recurso está localizado, la función itera sobre todos los locales disponibles, establece el locale actual para cada uno y aplica la función apply_slug. Luego, restaura el locale original. Si el recurso no está localizado, simplemente aplica la función apply_slug. \n\nArgumentos: \n\n- localized: booleano que indica si el recurso está localizado.\n\nLogica clave:\n\n- Si el recurso está localizado, itera sobre todos los locales disponibles, aplica la función apply_slug para cada locale y restaura el locale original.\n- Si el recurso no está localizado, aplica directamente la función apply_slug.",
    "summary_portuguese": "A função build_slug gera um slug para um recurso. Se o recurso for localizado, ela itera sobre todos os locais e aplica o slug em cada um deles. Caso contrário, ela aplica o slug apenas no local atual.  \n\nArguments:\n\n- localized: boolean\n\nKey logic:\n\n- Se o recurso for localizado, a função define o locale atual, itera sobre todos os locais e aplica o slug em cada um deles. \n- Após a iteração, o locale é restaurado para o valor original.\n- Se o recurso não for localizado, a função aplica o slug diretamente no locale atual.",
    "summary_arabic": "function build_slug:  This function builds a slug for a given object. If the application is using localization, it builds the slug for each supported locale. Otherwise, it builds the slug for the default locale. \n\narguments: none\n\nlogic:  If the application is using localization, it iterates through all supported locales, sets the locale for each iteration, and calls the apply_slug function. After processing all locales, it restores the original locale. If the application is not using localization, it directly calls the apply_slug function.",
    "summary_hindi": "यह फ़ंक्शन `build_slug` नाम का है और इसका उद्देश्य किसी ऑब्जेक्ट के लिए एक स्लैग बनाना है। \n\nयह फ़ंक्शन `localized?` नामक एक बूलियन मान लेता है। \n\nयदि `localized?` सत्य है, तो यह सभी लक्षित लोकेल में स्लैग लागू करता है और फिर मूल लोकेल पर वापस आ जाता है। \n\nयदि `localized?` असत्य है, तो यह केवल एक बार स्लैग लागू करता है।"
  },
  {
    "id": "sample_71240",
    "language": "ruby",
    "length_bucket": "medium",
    "code": "def add(model)\n      all_models_for(model).each do |model|\n        models_hash[model.to_s] = model.to_s\n        name_with_slashes = model.model_name\n        models_hash[name_with_slashes] = model.to_s\n        name_with_colons  = name_with_slashes.gsub('/','::')\n        models_hash[name_with_colons] = model.to_s\n      end\n    end",
    "docstring": "Add a model, and all it's subclasses, to the list of available models.\n\n A model has several names added so that it accessible in many ways:\n\n * Model Class Name\n * Model Name\n * Model Name with slashes replaced with `::` separator",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function add takes a model as input. It iterates through all models related to the input model. For each related model, it adds the model's string representation to a hash called models_hash using three different keys: the model's string representation, its model name, and its model name with forward slashes replaced by colons.",
    "summary_chinese": "该函数名为 add，用于将模型及其不同名称形式存储到一个哈希表中。 \n\n该函数接受一个模型作为参数，模型类型为 Model。\n\n函数首先遍历所有与传入模型相关的模型，然后将每个模型及其名称形式（包括带斜杠、带冒号的名称）存储到哈希表 models_hash 中。",
    "summary_french": "La fonction `add` prend un modèle en argument. Elle parcourt tous les modèles associés au modèle fourni. Pour chaque modèle, elle ajoute son nom (sous différentes formes : avec des barres obliques, des deux-points et sans séparateurs) dans un hash appelé `models_hash`.",
    "summary_spanish": "La función add toma un modelo como argumento. Recorre todos los modelos relacionados con el modelo proporcionado y crea un hash llamado models_hash. En este hash, se almacenan tres versiones del nombre del modelo: el nombre original, el nombre con barras invertidas y el nombre con dos puntos en lugar de barras.  Cada versión del nombre se asocia con el modelo original en el hash.",
    "summary_portuguese": "A função add recebe um modelo como argumento. Ela itera sobre todos os modelos relacionados ao modelo fornecido e adiciona cada nome do modelo, em diferentes formatos (com barras, colons e sem caracteres especiais), a um hash chamado models_hash.  O valor associado a cada chave no hash é o próprio nome do modelo.",
    "summary_arabic": "function add  تضيف نماذج إلى قاموس models_hash.  \n  \n  argument: model (نوع غير محدد)\n\n  الوظيفة تقوم بتكرار جميع النماذج ذات الصلة بـ model.  \n  لنموذج كل واحد، يتم إضافة اسمه إلى قاموس models_hash  \n  بأشكال مختلفة: الاسم الأصلي، الاسم مع \"/\"،  \n  و الاسم مع \":\" بدلاً من \"/\".",
    "summary_hindi": "add नामक फ़ंक्शन दिया गया है जो एक मॉडल को लेता है और इसे models_hash नामक एक हैश में विभिन्न रूपों में संग्रहीत करता है। यह फ़ंक्शन सभी संबंधित मॉडल लेता है और उनके नामों के साथ-साथ उनके नामों के विभिन्न रूपों (स्लैश और कॉलन के साथ) को हैश में जोड़ता है।"
  },
  {
    "id": "sample_70257",
    "language": "ruby",
    "length_bucket": "medium",
    "code": "def retrieve_commits(repo, sha, user, pages = -1)\n\n      url = if sha.nil?\n              ghurl \"repos/#{user}/#{repo}/commits\"\n            else\n              ghurl \"repos/#{user}/#{repo}/commits?sha=#{sha}\"\n            end\n\n      commits = restricted_page_request(url, pages)\n\n      commits.map do |c|\n        retrieve_commit(repo, c['sha'], user)\n      end.select{|x| not x.nil?}\n    end",
    "docstring": "Retrieve commits starting from the provided +sha+",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function retrieve_commits retrieves commits from a GitHub repository. It takes four arguments: repo (string), sha (string, optional), user (string), and pages (integer, default -1). \n\nIt constructs a URL to fetch commits from the specified repository, optionally filtering by a specific commit SHA. It then makes a request to the GitHub API, retrieving a paginated list of commits. \n\nFor each commit in the response, it calls the retrieve_commit function to get detailed information about the commit. Finally, it filters out any nil results and returns a list of commit objects.",
    "summary_chinese": "该函数名为 `retrieve_commits`，用于从 GitHub 仓库中获取提交记录。它接受四个参数：`repo` (仓库名，字符串类型)、`sha` (提交哈希值，可选，字符串类型)、`user` (仓库所有者用户名，字符串类型) 和 `pages` (页码数，可选，整数类型，默认值为 -1)。 \n\n函数首先根据 `sha` 是否为空构建 API 请求 URL，如果为空则获取仓库所有提交，否则获取指定 `sha` 提交及其之前的提交。然后使用 `restricted_page_request` 函数发送请求获取提交列表。最后，对获取到的提交列表进行迭代，使用 `retrieve_commit` 函数获取每个提交的详细信息，并过滤掉空值。",
    "summary_french": "La fonction `retrieve_commits` récupère les commits d'un dépôt GitHub. Elle prend en argument le nom du dépôt (`repo`), un commit SHA (optionnel) (`sha`), le nom de l'utilisateur (`user`) et le nombre de pages à récupérer (`pages`, par défaut -1 pour toutes les pages). Elle construit l'URL de la requête en fonction de la présence du SHA. Elle utilise ensuite `restricted_page_request` pour récupérer les commits et les mappe en utilisant `retrieve_commit` pour obtenir des informations détaillées sur chaque commit. Enfin, elle filtre les résultats pour supprimer les commits nuls.",
    "summary_spanish": "La función retrieve_commits busca commits de un repositorio. Recibe como argumentos repo (nombre del repositorio), sha (hash de un commit específico, opcional), user (nombre del usuario del repositorio) y pages (número de páginas a solicitar, -1 para todas). Construye una URL para la API de GitHub, utilizando el hash sha si se proporciona, de lo contrario, busca todos los commits. Realiza una solicitud a la API para obtener los commits y los procesa individualmente, llamando a la función retrieve_commit para cada uno. Finalmente, devuelve una lista de commits procesados, eliminando los que sean nulos.",
    "summary_portuguese": "A função retrieve_commits busca commits de um repositório. Ela recebe como argumentos o nome do repositório (repo), um commit SHA (sha), o nome do usuário (user) e o número de páginas a serem consultadas (pages, com valor padrão -1).  Se sha for nulo, a função busca todos os commits do repositório. Caso contrário, busca commits a partir do SHA especificado. A função utiliza a função restricted_page_request para obter os commits de cada página e, em seguida, mapeia cada commit para uma chamada à função retrieve_commit, que retorna informações detalhadas sobre o commit. A função filtra os resultados para remover commits nulos.",
    "summary_arabic": "retrieve_commits هي دالة تسترجع التغييرات في repository.  تقبل الدالة repository و sha (خيار) و user و pages (خيار).  \n\nتحدد الدالة URL للطلب بناءً على وجود sha.  \n\nتقوم بعد ذلك بإجراء طلب محدود الصفحات إلى URL.  \n\nثم تقوم بتحويل كل تغيير إلى commit باستخدام retrieve_commit وتختار فقط التغييرات التي لا تكون nil.",
    "summary_hindi": "इस फ़ंक्शन का नाम `retrieve_commits` है। यह एक रिपॉजिटरी से कमिट्स को पुनर्प्राप्त करने के लिए उपयोग किया जाता है। यह `repo` (रिपॉजिटरी का नाम), `sha` (एक विशिष्ट कमिट का SHA), `user` (रिपॉजिटरी के मालिक का उपयोगकर्ता नाम) और `pages` (प्राप्त करने वाले पृष्ठों की संख्या, -1 से सभी पृष्ठों को इंगित करता है) नामक चार मानों को लेता है। यह पहले एक URL बनाता है, जो SHA प्रदान किया जाता है या नहीं, उसके आधार पर। फिर, यह `restricted_page_request` फ़ंक्शन का उपयोग करके URL से कमिट्स प्राप्त करता है। अंत में, यह प्रत्येक कमिट के लिए `retrieve_commit` फ़ंक्शन को कॉल करता है और केवल गैर-निरर्थक परिणामों को वापस करता है।"
  },
  {
    "id": "sample_70754",
    "language": "ruby",
    "length_bucket": "medium",
    "code": "def unzip(source, destination)\n      Zip::File.open(source) do |zip|\n        zip.each do |f|\n          path = File.join(destination, f.name)\n          FileUtils.mkdir_p(File.dirname(path))\n          zip.extract(f, path) { true }\n        end\n      end\n    end",
    "docstring": "Internal: Unzips source to destination.",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function unzip takes two arguments: source, a string representing the path to a zip file, and destination, a string representing the path to the directory where the contents of the zip file should be extracted. It opens the zip file specified by source using the Zip::File class. It then iterates through each file f in the zip file. For each file, it constructs a path to the destination directory by joining the destination path with the file's name. It creates any necessary parent directories using FileUtils.mkdir_p. Finally, it extracts the file f to the constructed path using zip.extract, ensuring that the extraction process continues even if errors occur.",
    "summary_chinese": "unzip函数用于解压压缩文件。它接受两个参数：source，表示压缩文件路径，destination，表示解压文件目标路径。函数首先打开压缩文件，然后遍历压缩文件中的每个文件，为每个文件创建一个目标路径，并使用FileUtils.mkdir_p函数创建目标路径的父目录。最后，使用zip.extract函数将文件解压到目标路径。",
    "summary_french": "La fonction unzip décompresse un fichier zip. Elle prend deux arguments : source, le chemin du fichier zip à décompresser, et destination, le chemin du répertoire où décompresser les fichiers. La fonction ouvre le fichier zip en lecture, puis parcourt chaque fichier à l'intérieur du zip. Pour chaque fichier, elle construit le chemin complet du fichier décompressé en utilisant le chemin de destination et le nom du fichier du zip. Elle crée les répertoires nécessaires si nécessaire, puis extrait le fichier du zip au chemin construit.",
    "summary_spanish": "La función unzip extrae los archivos de un archivo zip. Recibe dos argumentos: source, que es la ruta al archivo zip, y destination, que es la ruta donde se extraerán los archivos.  El código abre el archivo zip, itera sobre cada archivo dentro del zip y extrae cada archivo a la ruta especificada, creando las carpetas necesarias si no existen.",
    "summary_portuguese": "A função unzip extrai os arquivos de um arquivo zip para um diretório especificado. Ela recebe dois argumentos: source, que é o caminho para o arquivo zip, e destination, que é o caminho para o diretório de destino. A função abre o arquivo zip, itera sobre cada arquivo dentro dele e extrai cada arquivo para o diretório de destino, criando diretórios intermediários se necessário.",
    "summary_arabic": "The function unzip takes two arguments: source, which is the path to a zip file, and destination, which is the path to the directory where the files should be extracted. It opens the zip file using the Zip::File class and iterates through each file within the zip. For each file, it constructs the full path to the destination file and creates any necessary parent directories. Then, it extracts the file to the destination path, allowing for overwrite.",
    "summary_hindi": "unzip नामक फ़ंक्शन एक ज़िप फ़ाइल को अनज़िप करने के लिए डिज़ाइन किया गया है। यह दो आर्गुमेंट्स लेता है: source जो ज़िप फ़ाइल का पथ है और destination जो अनज़िप किए गए फ़ाइलों को सहेजने के लिए पथ है। फ़ंक्शन ज़िप फ़ाइल को खोलता है और प्रत्येक फ़ाइल को अनज़िप करता है। प्रत्येक फ़ाइल को अनज़िप करने से पहले, फ़ाइल के नाम के आधार पर अनज़िप किए गए फ़ाइलों के लिए निर्देशिका बनाई जाती है।"
  },
  {
    "id": "sample_70593",
    "language": "ruby",
    "length_bucket": "medium",
    "code": "def check_can_collide(m)\n      y = get_y(m) + m.h\n      @can_collide = m.x + m.w > @x && @x + @w > m.x && m.y < y && m.y + m.h > y\n    end",
    "docstring": ":nodoc:",
    "model_name": "gemma-2-9b-it",
    "summary_english": "check_can_collide is a function that determines if two objects can collide. It takes a single argument, m, which is an object representing the other object. The function calculates the y-coordinate of the bottom of the other object and then checks if there is overlap between the x and y coordinates of the two objects.  It sets a boolean variable @can_collide to true if there is overlap and false otherwise.",
    "summary_chinese": "check_can_collide 函数用于判断两个矩形是否发生碰撞。 \n\n参数：\n\nm: 一个矩形对象\n\n逻辑：\n\n1. 获取传入矩形 m 的底部 y 坐标。\n2. 判断两个矩形的 x 和 y 坐标以及宽高是否满足碰撞条件。 \n3. 将碰撞结果存储在 @can_collide 变量中。",
    "summary_french": "La fonction `check_can_collide` vérifie si deux objets peuvent entrer en collision. Elle prend un argument `m` de type objet représentant le deuxième objet. La fonction calcule la position et les dimensions de l'objet `m` et compare ces valeurs avec les positions et les dimensions de l'objet courant (`@x`, `@w`, `@y`). Si les coordonnées des objets se chevauchent, la variable `@can_collide` est définie sur `true`, sinon elle est définie sur `false`.",
    "summary_spanish": "La función check_can_collide determina si dos objetos pueden colisionar. Recibe un objeto 'm' como argumento. Calcula la coordenada y del final del objeto 'm' y compara las coordenadas x e y de ambos objetos para verificar si hay solapamiento.",
    "summary_portuguese": "A função check_can_collide verifica se dois objetos podem colidir. Ela recebe um objeto 'm' como argumento. A lógica da função calcula as coordenadas dos cantos dos objetos e compara-as para determinar se há sobreposição.",
    "summary_arabic": "function check_can_collide takes an argument 'm' of type object. It calculates the y coordinate of the bottom of object 'm' and then checks if there is an overlap between the x and y coordinates of object 'm' and the current object (@x, @y, @w, @h). The result, a boolean value, is stored in the variable @can_collide.",
    "summary_hindi": "check_can_collide नामक फ़ंक्शन दो वस्तुओं के बीच टकराव की जांच करता है। यह फ़ंक्शन एक मापदंड m लेता है जो एक वस्तु का प्रतिनिधित्व करता है। यह फ़ंक्शन m वस्तु के y निर्देशांक को प्राप्त करता है और उसमें उसकी ऊँचाई जोड़ता है। फिर, यह जांचता है कि क्या m वस्तु की x और y निर्देशांक @x और @y निर्देशांक के साथ संरेखित हैं। यदि वे संरेखित हैं, तो यह @can_collide चर को true पर सेट करता है, अन्यथा false पर।"
  },
  {
    "id": "sample_71976",
    "language": "ruby",
    "length_bucket": "medium",
    "code": "def put_octect(uri, data, manage_errors)\n      headers = build_headers(@token)\n      headers[\"Content-Type\"] = 'application/octet-stream'\t\n      req = Net::HTTP::Put.new(uri.request_uri, initheader = headers)\n      req.body = data\n      return do_request(uri, req, manage_errors, 0)\n    end",
    "docstring": "Special rest call for sending a file stream using an octet-stream\n main change is just custom headers.\n Still implemented using do_request function.",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `put_octect` sends a PUT request to a given URI with octet stream data. It takes three arguments: `uri` (a URI object), `data` (the data to send as a byte stream), and `manage_errors` (a boolean indicating whether to handle errors). It builds headers including a Content-Type header set to 'application/octet-stream', creates a PUT request object with the URI and headers, sets the request body to the provided data, and then calls the `do_request` function to execute the request, handling errors based on the `manage_errors` flag.",
    "summary_chinese": "该函数名为 put_octect，用于向指定 URI 上传二进制数据。 \n\n参数：uri (URI 对象)，data (二进制数据)，manage_errors (布尔值)\n\n逻辑：构建包含令牌的 HTTP 头部，设置 Content-Type 为 application/octet-stream，创建 PUT 请求对象，将数据作为请求体，并调用 do_request 函数处理请求并管理错误。",
    "summary_french": "La fonction `put_octect` envoie des données au serveur en utilisant la méthode PUT. Elle prend en argument `uri` (une URL), `data` (les données à envoyer) et `manage_errors` (un booléen indiquant si les erreurs doivent être gérées). Elle construit les en-têtes HTTP, spécifie le type de contenu comme 'application/octet-stream' et crée une requête PUT. La requête est ensuite envoyée au serveur en utilisant la fonction `do_request` et le résultat est retourné.",
    "summary_spanish": "La función put_octect envía datos como un flujo de octetos a una URI específica. Recibe tres argumentos: uri (una URI), data (los datos a enviar) y manage_errors (un booleano que indica si se deben manejar los errores).  Construye encabezados HTTP, incluyendo el tipo de contenido como 'application/octet-stream'. Crea una solicitud PUT con la URI y los encabezados, establece el cuerpo de la solicitud con los datos y finalmente llama a la función do_request para realizar la solicitud y manejar los errores.",
    "summary_portuguese": "A função put_octect envia dados como um stream de octetos para um URI específico. Ela recebe como argumentos: uri (um objeto URI), data (os dados a serem enviados), e manage_errors (um booleano que indica se erros devem ser gerenciados). A função constrói cabeçalhos HTTP, incluindo o tipo de conteúdo como 'application/octet-stream', cria uma requisição PUT com o URI e os cabeçalhos, define o corpo da requisição como os dados fornecidos, e finalmente chama a função do_request para executar a requisição e lidar com possíveis erros.",
    "summary_arabic": "function put_octect  تُستخدم هذه الوظيفة لإرسال بيانات بصيغة octet-stream إلى URI معين. \n\narguments:\nuri: URI \ndata: بيانات من نوع octet-stream\nmanage_errors: boolean\n\nlogic:\n1. بناء رأس HTTP باستخدام token.\n2. تعيين نوع المحتوى إلى application/octet-stream.\n3. إنشاء طلب PUT باستخدام URI و رؤوس HTTP.\n4. تعيين بيانات الطلب.\n5. إجراء الطلب وإدارة الأخطاء باستخدام دالة do_request.",
    "summary_hindi": "यह फ़ंक्शन `put_octect` नाम का है और इसका उद्देश्य एक URI पर octet स्ट्रीम डेटा को PUT अनुरोध भेजना है। यह फ़ंक्शन `uri` (URI ऑब्जेक्ट), `data` (octet स्ट्रीम डेटा) और `manage_errors` (बूलियन, त्रुटियों को कैसे प्रबंधित करना है) नामक तीन मान्यताओं को लेता है। यह पहले एक HTTP PUT अनुरोध बनाता है और उसे `data` के साथ सेट करता है। फिर, यह `do_request` फ़ंक्शन को कॉल करता है जो अनुरोध को भेजता है और त्रुटियों को प्रबंधित करता है।"
  },
  {
    "id": "sample_70469",
    "language": "ruby",
    "length_bucket": "medium",
    "code": "def message_match?(msg_s, ountil)\n\n      return false unless ountil\n\n      ms = msg_s; ms = [ ms ] if ms.is_a?(Hash)\n\n      nid, point = ountil.split(' ')\n\n      ms.find { |m| m['nid'] == nid && m['point'] == point }\n    end",
    "docstring": "TODO eventually merge with Waiter.parse_serie",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function message_match? checks if a message matches a given identifier and point. It takes two arguments: msg_s, which is a string or a hash representing a message, and ountil, which is a string specifying the identifier and point to match.  If ountil is empty, it returns false. It converts msg_s to an array if it's a hash. It then splits ountil into nid and point. Finally, it searches for a message in the array that has both the matching nid and point.",
    "summary_chinese": "该函数名为 message_match?，用于检查消息是否与给定的条件匹配。它接受两个参数：msg_s，类型为字符串或哈希，代表消息内容；ountil，类型为字符串，代表匹配条件，格式为 \"nid point\"。函数首先检查 ountil 是否为空，如果为空则返回 false。然后，它将 msg_s 转换为数组，以便遍历消息内容。接着，它将 ountil 分割成 nid 和 point 两个部分。最后，它遍历 msg_s 数组，查找 nid 和 point 匹配的消息，如果找到则返回该消息，否则返回 nil。",
    "summary_french": "La fonction `message_match?` vérifie si un message correspond à un identifiant et à un point spécifiques. Elle prend deux arguments : `msg_s`, qui est une chaîne de caractères ou un hash contenant les messages, et `ountil`, qui est une chaîne de caractères représentant l'identifiant et le point à rechercher. La fonction retourne `false` si `ountil` est absent. Elle convertit `msg_s` en un tableau si c'est un hash. Ensuite, elle divise `ountil` en identifiant et point. Enfin, elle recherche dans le tableau de messages un message dont l'identifiant et le point correspondent à ceux spécifiés dans `ountil`.",
    "summary_spanish": "La función message_match? busca un mensaje en una lista de mensajes que coincida con un identificador (nid) y un punto específicos. \n\nRecibe dos argumentos: msg_s, que es una cadena o un hash de mensajes, y ountil, que es una cadena que contiene el nid y el punto separados por un espacio.\n\nPrimero, verifica si ountil está definido. Si no lo está, devuelve false. Luego, convierte msg_s en una lista si es un hash.  \n\nFinalmente, busca en la lista de mensajes un mensaje cuyo campo 'nid' coincida con el nid de ountil y cuyo campo 'point' coincida con el punto de ountil. Si encuentra un mensaje que coincida, devuelve ese mensaje; de lo contrario, devuelve nil.",
    "summary_portuguese": "A função message_match? verifica se uma mensagem corresponde a um identificador e um ponto específicos. Ela recebe dois argumentos: msg_s, que é uma string ou um hash contendo a mensagem, e ountil, que é uma string no formato \"nid ponto\". A função primeiro verifica se ountil é válido. Se for, ela converte msg_s em um array se for um hash. Em seguida, ela extrai o nid e o ponto de ountil. Finalmente, ela procura uma mensagem no array msg_s que tenha o nid e o ponto correspondentes. Se uma mensagem for encontrada, a função retorna true; caso contrário, retorna false.",
    "summary_arabic": "function message_match?  تسعى هذه الدالة إلى العثور على رسالة مطابقة في مجموعة رسائل.  \narguments: msg_s:  سلسلة أو خريطة تحتوي على رسائل. ountil: سلسلة تتكون من \"nid point\" مفصولة بمسافة. \nlogic:  تتحقق الدالة من وجود  'ountil'  ثم تحول  msg_s  إلى قائمة إذا كان من نوع خريطة.  تقوم بتقسيم  'ountil'  إلى  'nid'  و  'point'.  ثم تقوم بالبحث عن رسالة في  msg_s  حيث  'nid'  و  'point'  متطابقين مع القيم في  'ountil'.  ترجع  true  إذا وجدت رسالة مطابقة وإلا  false.",
    "summary_hindi": "यह फ़ंक्शन `message_match?` नामक है और यह यह जांचने के लिए डिज़ाइन किया गया है कि एक संदेश एक दिए गए `ountil` मान से मेल खाता है या नहीं। यह फ़ंक्शन `msg_s` और `ountil` दो मानों को लेता है। `msg_s` एक संदेश है जो एक स्ट्रिंग या एक हैश मान हो सकता है। `ountil` एक स्ट्रिंग है जो `nid` और `point` से विभाजित होता है। फ़ंक्शन `ountil` मान की जांच करता है और यदि यह खाली नहीं है तो `nid` और `point` मानों को अलग करता है। फिर यह `msg_s` मान को एक एरे में बदलता है और `nid` और `point` मानों के साथ मेल खाने वाले संदेश को ढूंढता है। यदि कोई मेल खाने वाला संदेश मिलता है तो फ़ंक्शन `true` वापस करता है, अन्यथा `false` वापस करता है।"
  },
  {
    "id": "sample_72129",
    "language": "ruby",
    "length_bucket": "medium",
    "code": "def point_mul(s, pa)\n      pq = [0, 1, 1, 0]  # Neutral element\n      while s > 0 do\n        pq = point_add(pq, pa) unless (s & 1).equal? 0\n        pa = point_add(pa, pa)\n        s >>= 1\n      end\n      return pq\n    end",
    "docstring": "Computes pointQ = s * pointA",
    "model_name": "gemma-2-9b-it",
    "summary_english": "point_mul multiplies a point on an elliptic curve by a scalar. It takes two arguments: s, an integer representing the scalar, and pa, a point on the elliptic curve. The function iteratively doubles the point pa and adds it to the result pq based on the bits of the scalar s.  If a bit of s is 1, pa is added to pq.  The process continues until s becomes 0.  The final value of pq is the result of the multiplication.",
    "summary_chinese": "point_mul 函数计算点乘结果。它接受两个参数：s 是一个整数，pa 是一个点。函数首先定义一个中性元素 pq，然后通过循环迭代 s 的二进制表示，在每个位为 1 时将 pa 加到 pq 中。在每次迭代中，pa 会被自乘，s 会右移一位。最后，函数返回计算结果 pq。",
    "summary_french": "La fonction `point_mul` multiplie un point par un entier. Elle prend deux arguments : `s`, un entier représentant le multiplicateur, et `pa`, un point représenté par une liste de quatre entiers. La fonction utilise une boucle `while` pour effectuer la multiplication. À chaque itération, elle ajoute le point `pa` au résultat `pq` si le bit le moins significatif de `s` est égal à 1. Ensuite, elle double le point `pa` et déplace `s` d'un bit à droite. La fonction retourne le point résultant `pq`.",
    "summary_spanish": "La función point_mul multiplica un punto por un entero. Toma dos argumentos: s, un entero que representa el multiplicador, y pa, un punto representado como una lista de cuatro enteros. La función utiliza un algoritmo similar a la multiplicación binaria para calcular el producto punto.  Si el bit menos significativo de s es 1, se suma el punto pa al resultado actual pq. Luego, el punto pa se duplica y s se desplaza a la derecha. El proceso se repite hasta que s se convierte en 0. Finalmente, la función devuelve el punto resultante pq.",
    "summary_portuguese": "A função point_mul calcula o produto de um ponto por um inteiro. Ela recebe dois argumentos: s, um inteiro, e pa, um ponto representado como uma lista de quatro inteiros. A função utiliza um algoritmo iterativo para calcular o produto, multiplicando o ponto pa por si mesmo em cada iteração e adicionando o ponto pa ao resultado se o bit atual de s for 1.  A função retorna o ponto resultante da multiplicação.",
    "summary_arabic": "function point_mul takes two arguments: s which is an integer and pa which is a list of four integers. The function calculates the product of a point pa by a scalar s. It achieves this by repeatedly adding pa to itself and then adding the result to a neutral element pq if the current bit of s is 1. The process continues until s becomes zero. Finally, the function returns the resulting point pq.",
    "summary_hindi": "point_mul फ़ंक्शन एक बिंदु को एक पूर्णांक से गुणा करने के लिए उपयोग किया जाता है। यह दो बिंदुओं, s और pa, को लेता है।  s एक पूर्णांक है जो गुणा करने वाला मान है, और pa एक बिंदु है। फ़ंक्शन एक तर्क pq का उपयोग करता है जो एक बिंदु का प्रतिनिधित्व करता है और इसे एक न्यूट्रल तत्व [0, 1, 1, 0] से शुरू करता है।  जब तक s शून्य से बड़ा होता है, तब तक यह pq और pa को point_add फ़ंक्शन का उपयोग करके जोड़ता है।  यदि s का सबसे कम महत्वपूर्ण बिट 1 है, तो pq को pa के साथ जोड़ा जाता है। pa को अपने आप से जोड़ा जाता है और s को दाईं ओर शिफ्ट किया जाता है। अंत में, फ़ंक्शन pq को वापस करता है जो गुणा किए गए बिंदु का प्रतिनिधित्व करता है।"
  },
  {
    "id": "sample_72134",
    "language": "ruby",
    "length_bucket": "medium",
    "code": "def secret_expand(secret)\n      raise \"Bad size of private key\" unless secret.length.equal? 32\n\n      h = hash512(secret)\n      a = int_form_bytes(h[0,32])\n      a &= (1 << 254) - 8\n      a |= (1 << 254)\n      return [a, h[32,32]]\n    end",
    "docstring": "region key manipulation \n hash512(secret)\n => HASH(512bit)\n => [LH(256bit)] / [RH(256bit)]\n => LH -> (set some bits) -> a\n return ( a , RH )",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function secret_expand takes a secret as input. It first checks if the length of the secret is 32. If not, it raises an error. Then, it calculates the hash of the secret using hash512. It extracts the first 32 bytes of the hash and converts them to an integer. This integer is then modified by setting the 254th bit to 1 and masking the rest of the bits. Finally, the function returns a list containing the modified integer and the remaining 32 bytes of the hash.",
    "summary_chinese": "secret_expand 函数用于扩展秘密密钥。它接受一个名为 secret 的字符串参数，该字符串的长度必须为 32。函数首先计算 secret 的哈希值，然后将哈希值的前 32 个字节转换为整数，并进行一些位操作。最后，函数返回一个包含两个元素的数组，第一个元素是经过处理的整数，第二个元素是哈希值的剩余部分。",
    "summary_french": "La fonction `secret_expand` prend un secret en argument. Elle vérifie que la taille du secret est de 32 octets. Si ce n'est pas le cas, elle lève une erreur. Ensuite, elle calcule le hachage SHA-512 du secret et extrait les 64 premiers octets. Le premier octet du hachage est converti en entier et modifié pour respecter une certaine condition. Enfin, la fonction retourne un tableau contenant l'entier modifié et les 32 derniers octets du hachage.",
    "summary_spanish": "La función secret_expand toma un secreto como argumento. Si la longitud del secreto no es 32, lanza un error. Calcula el hash de 512 bits del secreto y lo divide en dos partes. La primera parte se convierte a un entero y se modifica para establecer un bit específico. La segunda parte se devuelve junto con el entero modificado. \n\n\nsecret (bytes)",
    "summary_portuguese": "A função secret_expand recebe um segredo como argumento. Ela verifica se o tamanho do segredo é de 32 bytes. Se não for, lança uma exceção. Caso contrário, calcula o hash SHA-512 do segredo, extrai os primeiros 32 bytes e os converte para um inteiro.  O inteiro é então modificado para ter o bit 254 definido e os bits restantes zerados. A função retorna uma lista contendo o inteiro modificado e os 32 bytes restantes do hash.",
    "summary_arabic": "The function secret_expand takes a secret as input. It checks if the length of the secret is 32 bytes. If not, it raises an error. It then calculates the hash of the secret using hash512. It extracts the first 32 bytes of the hash and converts them to an integer. It performs bitwise operations on the integer to set specific bits. Finally, it returns a list containing the modified integer and the remaining 32 bytes of the hash.",
    "summary_hindi": "secret_expand नामक फ़ंक्शन एक गुप्त कुंजी का विस्तार करता है। यह कुंजी की लंबाई 32 होना चाहिए।  यह कुंजी का हैश बनाता है, पहले 32 बाइट्स को एक पूर्णांक में परिवर्तित करता है, कुछ बिट्स को सेट करता है और अंत में एक सूची लौटाता है जिसमें एक पूर्णांक और शेष हैश शामिल हैं।"
  },
  {
    "id": "sample_71613",
    "language": "ruby",
    "length_bucket": "medium",
    "code": "def update(event, target)\n      case event\n      when :user_deleted\n        @users = @users.delete_if { |element| element == target }\n        target.delete_observer(self)\n      else\n        raise ArgumentError.new(event)\n      end\n    end",
    "docstring": "observer callback",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function update handles events related to user deletion. It takes two arguments: event, which is a symbol representing the type of event, and target, which is the object affected by the event. If the event is :user_deleted, it removes the target user from the @users collection and removes the observer relationship between the target and the calling object. For any other event type, it raises an ArgumentError.",
    "summary_chinese": "update 函数用于更新用户列表，根据事件类型执行不同的操作。它接受两个参数：event（事件类型，字符串）和 target（要操作的用户对象）。如果事件类型为 :user_deleted，则从用户列表中删除 target 用户，并取消 target 用户对自身对象的观察。否则，会抛出 ArgumentError 异常。",
    "summary_french": "La fonction `update` gère la mise à jour des utilisateurs en fonction d'un événement. Elle prend deux arguments : `event` (un symbole représentant l'événement) et `target` (l'utilisateur concerné). Si l'événement est `:user_deleted`, la fonction supprime l'utilisateur `target` de la liste `@users` et désinscrit l'observateur `self` de l'utilisateur `target`. Dans tous les autres cas, elle déclenche une erreur `ArgumentError`.",
    "summary_spanish": "La función update se encarga de actualizar el estado de un objeto en función del tipo de evento recibido. Recibe dos argumentos: event, que es un símbolo representando el tipo de evento, y target, que es el objeto sobre el cual se aplicará la actualización. Si el evento es :user_deleted, la función elimina el objeto target de la lista @users y elimina el observador de target. En caso de cualquier otro evento, la función lanza un error ArgumentError.",
    "summary_portuguese": "A função update recebe dois argumentos: event e target. O evento determina a ação a ser tomada, enquanto o target é o objeto afetado. Se o evento for :user_deleted, a função remove o target da lista de usuários @users e desassocia o observador atual do target. Caso contrário, a função lança um erro ArgumentError.",
    "summary_arabic": "The function update handles events related to user deletion. It takes two arguments: event, which is a symbol representing the type of event, and target, which is the user object involved in the event. If the event is :user_deleted, it removes the target user from the @users collection and removes the observer relationship between the target user and the current object. For any other event type, it raises an ArgumentError.",
    "summary_hindi": "update नामक फ़ंक्शन किसी घटना के आधार पर एक लक्ष्य को अपडेट करता है। यह दो मान लेता है: event जो एक सिंबल है और target जो किसी ऑब्जेक्ट का प्रतिनिधित्व करता है। यदि घटना :user_deleted है, तो यह target को @users से हटा देता है और target से अपने आप को observer के रूप में हटा देता है। अन्यथा, यह ArgumentError उत्पन्न करता है।"
  },
  {
    "id": "sample_71111",
    "language": "ruby",
    "length_bucket": "medium",
    "code": "def string(opts = {})\n      length, any, value = (opts[:length] || 8), opts[:any], opts[:value]\n      if value\n        string = value.to_s\n        Proc.new { string }\n      elsif any\n        Proc.new { self.any(any) }\n      else\n        Proc.new { Array.new(length){@chars[rand(@chars.size-1)]}.join }\n      end\n    end",
    "docstring": "belows are data types\n @return Proc object which returns a random generated value, or [formatted_value, raw_value]",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `string` generates a string based on provided options. It accepts a hash `opts` with optional keys: `length`, `any`, and `value`. If `value` is provided, it returns a string representation of the value. If `any` is provided, it returns a proc that calls the `any` method on the object. Otherwise, it generates a random string of the specified `length` using characters from the object's `@chars` array.",
    "summary_chinese": "该函数名为 string，用于生成一个字符串。它接受一个可选参数 opts，该参数是一个哈希表。如果 opts 中包含 :length 参数，则生成的字符串长度为该参数的值，否则默认为 8。如果 opts 中包含 :any 参数，则生成的字符串为调用 self.any(any) 方法的结果。如果 opts 中包含 :value 参数，则生成的字符串为该参数的值的字符串表示形式。否则，生成的字符串为长度为 length 的随机字符数组的连接。",
    "summary_french": "La fonction `string` génère une chaîne de caractères. Elle prend un argument optionnel `opts`, un hash contenant les options `length`, `any` et `value`. Si `value` est défini, la fonction retourne une procédure qui renvoie la chaîne de caractères `value`. Si `any` est défini, la fonction retourne une procédure qui appelle la méthode `any` sur l'objet courant avec l'argument `any`. Sinon, la fonction retourne une procédure qui génère une chaîne de caractères aléatoire de longueur `length` en utilisant les caractères de l'objet courant.",
    "summary_spanish": "La función `string` genera una cadena de caracteres. Recibe un argumento opcional `opts`, que es un hash.  Si `opts` contiene la clave `:value`, la función devuelve una cadena con el valor especificado. Si `opts` contiene la clave `:any`, la función devuelve una cadena generada llamando a un método `any` con el valor especificado en `any`. De lo contrario, la función devuelve una cadena de longitud especificada en `:length` (o 8 por defecto), compuesta por caracteres aleatorios seleccionados de un conjunto de caracteres.",
    "summary_portuguese": "A função `string` gera uma string de acordo com as opções fornecidas. Ela aceita um argumento opcional `opts`, um hash que pode conter as chaves `length`, `any` e `value`. Se `value` estiver presente, a função retorna uma proc que retorna a string convertida para `to_s`. Se `any` estiver presente, a função retorna uma proc que chama o método `any` com o valor de `any`. Caso contrário, a função retorna uma proc que gera uma string aleatória de comprimento `length` usando os caracteres da variável `@chars`.",
    "summary_arabic": "الوظيفة اسمها string وتستخدم لإنشاء سلسلة نصية. \n\nتستقبل الوظيفة خيارات اختيارية (opts) كمعجم. \n\nالخيارات هي:\n\n* length: طول السلسلة (افتراضيًا 8) من نوع عدد صحيح.\n* any:  محدد لإنشاء سلسلة عشوائية من نوع أي.\n* value: قيمة ثابتة للسلسلة من نوع أي.\n\nإذا تم إعطاء قيمة (value) ، فسيتم استخدامها كسلسلة. \n\nإذا تم إعطاء any ، فسيتم إنشاء سلسلة عشوائية باستخدام أي. \n\nفي غير ذلك ، يتم إنشاء سلسلة عشوائية من طول (length) باستخدام أحرف عشوائية من مجموعة الأحرف (@chars).",
    "summary_hindi": "string नामक फ़ंक्शन एक स्ट्रिंग उत्पन्न करता है। यह तीन आर्गुमेंट्स लेता है: opts, जो एक हैशमैप है।  opts में length, any और value जैसे कीवर्ड्स हो सकते हैं।  यदि value दिया गया है, तो यह स्ट्रिंग वापस करता है। यदि any दिया गया है, तो यह self.any(any) को वापस करता है। अन्यथा, यह length की लंबाई वाली एक नई स्ट्रिंग बनाता है, जिसमें @chars से यादृच्छिक वर्ण शामिल हैं।"
  },
  {
    "id": "sample_70112",
    "language": "ruby",
    "length_bucket": "medium",
    "code": "def arrange_serializable options={}, nodes=nil, &block\n      nodes = arrange(options) if nodes.nil?\n      nodes.map do |parent, children|\n        if block_given?\n          yield parent, arrange_serializable(options, children, &block)\n        else\n          parent.serializable_hash.merge 'children' => arrange_serializable(options, children)\n        end\n      end\n    end",
    "docstring": "Arrangement to nested array",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `arrange_serializable` recursively arranges a tree-like structure into a serializable format. It takes an optional `options` hash, a `nodes` array (which can be nil), and a block. If `nodes` is nil, it calls the `arrange` function with the `options` to generate the nodes. It then iterates through each parent-child pair in the `nodes` array. If a block is provided, it yields the parent node and the recursively arranged children. Otherwise, it merges a 'children' key containing the recursively arranged children into the parent's serializable hash.",
    "summary_chinese": "该函数名为 `arrange_serializable`，用于将树状结构转换为可序列化格式。它接受三个参数：`options`（一个哈希表，用于配置序列化过程），`nodes`（一个树状结构，可以是nil），以及一个可选的块。如果`nodes`为nil，则使用默认配置生成一个空的树状结构。然后，它遍历每个父节点和子节点，如果提供了块，则调用块并将子节点递归地序列化；否则，将父节点序列化为哈希表，并将子节点序列化为子项。",
    "summary_french": "La fonction `arrange_serializable` organise un arbre de données en un format serialisable. Elle prend en argument un hash d'options, une liste de noeuds (optionnelle) et un bloc de code. Si la liste de noeuds est vide, elle utilise la fonction `arrange` pour la générer à partir des options. Elle parcourt ensuite chaque noeud parent et ses enfants, appliquant le bloc de code s'il est fourni, ou en construisant un hash serialisable avec les informations du noeud parent et ses enfants organisés de manière récursive.",
    "summary_spanish": "La función arrange_serializable organiza un árbol de nodos de forma serializable. Recibe un hash de opciones, un arreglo de nodos (opcional) y un bloque. Si no se proporcionan nodos, utiliza la función arrange para generar un árbol. Itera sobre cada nodo padre y sus hijos, aplicando el bloque si se proporciona, o creando un hash serializable con los datos del nodo padre y los hijos organizados recursivamente.",
    "summary_portuguese": "A função `arrange_serializable` organiza um conjunto de nós em uma estrutura serializável. Ela aceita um hash de opções, um array de nós ou `nil` e um bloco opcional. Se `nodes` for `nil`, a função usa as opções para gerar uma estrutura de nós. Em seguida, ela percorre cada nó pai e seus filhos, aplicando o bloco fornecido se disponível, ou criando um hash serializável com o nó pai e seus filhos organizados recursivamente.",
    "summary_arabic": "The function `arrange_serializable` organizes a tree-like structure into a serializable format. It takes an optional `options` hash, a `nodes` array representing the tree structure (which can be nil), and a block. If `nodes` is nil, it uses the `arrange` function to generate a default structure. It iterates through each parent-child pair in the `nodes` array. If a block is provided, it applies the block to the parent and recursively calls `arrange_serializable` for the children. Otherwise, it creates a hash representing the parent node, including a 'children' key containing the serialized representation of the children.",
    "summary_hindi": "यह फ़ंक्शन `arrange_serializable` नामक एक फ़ंक्शन है जो एक डेटा संरचना को क्रमबद्ध रूप से एक सैरियलाइज़ेबल हास में परिवर्तित करता है। यह दो मान्यताओं को लेता है: `options` एक हैश है जो विकल्पों को संग्रहीत करता है और `nodes` एक एरे है जो डेटा संरचना को दर्शाता है। यदि `nodes` खाली है, तो यह एक डिफ़ॉल्ट संरचना का उपयोग करता है। यह प्रत्येक `parent` और उसके `children` के लिए दो चरणों में काम करता है। यदि एक ब्लॉक प्रदान किया गया है, तो यह ब्लॉक को कॉल करता है और `children` को पुनरावर्ती रूप से क्रमबद्ध करता है। यदि कोई ब्लॉक नहीं दिया गया है, तो यह `parent` को एक हास में परिवर्तित करता है और `children` को पुनरावर्ती रूप से क्रमबद्ध करता है और इसे `children` कुंजी के साथ जोड़ता है।"
  },
  {
    "id": "sample_70264",
    "language": "ruby",
    "length_bucket": "medium",
    "code": "def get_repo_events(owner, repo)\n      url = ghurl(\"repos/#{owner}/#{repo}/events\")\n      r = paged_api_request(url)\n\n      r.each do |e|\n        unless get_event(e['id']).empty?\n          debug \"Repository event #{owner}/#{repo} -> #{e['type']}-#{e['id']} already exists\"\n        else\n          persister.store(:events, e)\n          info \"Added event for repository #{owner}/#{repo} -> #{e['type']}-#{e['id']}\"\n        end\n      end\n\n      persister.find(:events, {'repo.name' => \"#{owner}/#{repo}\"})\n\n    end",
    "docstring": "Get all events for the specified repo.\n GitHub will only return 90 days of events",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `get_repo_events` retrieves events from a GitHub repository and stores them. It takes two arguments: `owner` (string) and `repo` (string), representing the repository owner and name. \n\nThe function constructs a URL to the repository's events endpoint using the provided owner and repo. It then makes a paginated API request to retrieve the events. \n\nFor each event, it checks if an event with the same ID already exists. If not, it stores the event using a `persister` object and logs a message indicating the event was added. Finally, it retrieves all events associated with the specified repository from the `persister` and returns them.",
    "summary_chinese": "该函数名为 `get_repo_events`，用于获取指定仓库的事件。它接受两个参数：`owner`（仓库所有者）和 `repo`（仓库名称），类型分别为字符串。 \n\n函数首先构建 API 请求 URL，然后使用 `paged_api_request` 函数获取事件列表。 \n\n接着，它遍历每个事件，检查该事件是否已经存在。如果存在，则打印一条信息；否则，将事件存储到数据库中并打印一条添加成功的信息。最后，函数返回该仓库的所有事件。",
    "summary_french": "La fonction `get_repo_events` récupère les événements d'un dépôt GitHub. Elle prend en argument `owner` (le nom du propriétaire du dépôt) et `repo` (le nom du dépôt). Elle construit une URL pour accéder aux événements du dépôt et utilise la fonction `paged_api_request` pour les récupérer. Ensuite, elle parcourt chaque événement et vérifie s'il existe déjà dans la base de données. Si l'événement n'existe pas, elle l'enregistre dans la base de données et affiche un message d'information. Enfin, elle retourne tous les événements enregistrés pour le dépôt spécifié.",
    "summary_spanish": "La función get_repo_events obtiene eventos de un repositorio de GitHub. Recibe dos argumentos: owner (string) y repo (string), que representan el nombre del propietario y el nombre del repositorio. \n\nPrimero, construye una URL para obtener los eventos del repositorio. Luego, realiza una solicitud a la API de GitHub para obtener los eventos. \n\nPara cada evento, verifica si ya existe en la base de datos. Si no existe, lo almacena en la base de datos y registra un mensaje informativo. Finalmente, devuelve todos los eventos almacenados para el repositorio especificado.",
    "summary_portuguese": "A função `get_repo_events` recupera eventos de um repositório do GitHub. Ela recebe dois argumentos: `owner` (string) e `repo` (string), que representam o nome do proprietário e o nome do repositório, respectivamente. A função constrói uma URL para a API do GitHub e faz uma solicitação para obter os eventos do repositório. Para cada evento recebido, ela verifica se já existe um registro do evento. Se não existir, o evento é armazenado em um persistente e uma mensagem informativa é exibida. Finalmente, a função retorna todos os eventos armazenados para o repositório especificado.",
    "summary_arabic": "function get_repo_events  تستخرج جميع أحداث الـ repository من GitHub. \n\narguments:\nowner: string, اسم مالك repository.\nrepo: string, اسم repository.\n\nlogic:\n1. build the API URL for the repository events.\n2. make a request to the API to retrieve all events.\n3. iterate over each event.\n4. check if the event already exists in the database.\n5. if the event doesn't exist, store it in the database.\n6. return all events for the repository from the database.",
    "summary_hindi": "यह फ़ंक्शन `get_repo_events` नाम का है और इसका उद्देश्य किसी दिए गए GitHub रिपॉजिटरी के लिए सभी इवेंट्स को प्राप्त करना और उन्हें एक डेटाबेस में संग्रहीत करना है। यह दो मान्यताओं के साथ काम करता है: `owner` (रिपॉजिटरी के मालिक का नाम) और `repo` (रिपॉजिटरी का नाम)। यह GitHub API का उपयोग करके रिपॉजिटरी के सभी इवेंट्स को प्राप्त करता है और प्रत्येक इवेंट को `get_event` फ़ंक्शन का उपयोग करके पहले से मौजूद होने की जांच करता है। यदि इवेंट पहले से मौजूद नहीं है, तो इसे `persister` नामक एक डेटाबेस इंटरफ़ेस का उपयोग करके संग्रहीत किया जाता है। अंत में, यह `persister` का उपयोग करके रिपॉजिटरी के सभी इवेंट्स को वापस करता है।"
  },
  {
    "id": "sample_70814",
    "language": "ruby",
    "length_bucket": "medium",
    "code": "def add name, content = nil, attributes: {}, activator: menu_activator, &block\n      tag = Navigator::Tag.new name, content, attributes: attributes, activator: activator\n      return items << tag.render unless block_given?\n\n      items << tag.prefix\n      items << tag.content\n      instance_eval(&block)\n      items << tag.suffix\n    end",
    "docstring": "rubocop:enable Metrics/LineLength",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `add` creates a new tag object and appends it to a collection of items. It takes arguments for the tag name, optional content, attributes, an activator, and a block. If a block is provided, it renders the tag's prefix, content, executes the block, and then renders the tag's suffix. Otherwise, it simply renders the tag and appends it to the items collection.",
    "summary_chinese": "这个函数名为 `add`，用于在导航菜单中添加一个新的标签。它接受四个参数：`name` (字符串)，标签名称；`content` (可选，nil)，标签内容；`attributes` (哈希)，标签属性；`activator` (对象)，激活器；以及一个可选的块。函数首先创建一个新的标签对象，然后根据是否提供块，将标签渲染到 `items` 数组中，或者将标签的前缀、内容和后缀分别添加到 `items` 数组中，并执行块中的代码。",
    "summary_french": "La fonction `add` permet de créer un élément de navigation et de l'ajouter à une collection d'éléments. Elle prend en arguments `name` (une chaîne de caractères), `content` (une valeur optionnelle, par défaut `nil`), `attributes` (un hash), `activator` (une méthode), et un bloc de code. La fonction crée un nouvel objet `Navigator::Tag` avec les informations fournies et l'ajoute à la collection `items`. Si un bloc est fourni, la fonction exécute le bloc et ajoute le préfixe, le contenu et le suffixe du tag à la collection `items`.",
    "summary_spanish": "La función `add` crea un nuevo elemento de navegación. Recibe como argumentos `name` (string), `content` (opcional, nil por defecto), `attributes` (hash), `activator` (objeto), y un bloque opcional.  Si no se proporciona un bloque, agrega el elemento renderizado a una colección llamada `items`. Si se proporciona un bloque, agrega el prefijo del elemento, su contenido, ejecuta el bloque proporcionado y finalmente agrega el sufijo del elemento a `items`.",
    "summary_portuguese": "A função `add` cria um novo elemento de navegação. Ela recebe o nome do elemento, o conteúdo, um hash de atributos, um ativador de menu e um bloco opcional. Se um bloco não for fornecido, a função adiciona o elemento renderizado à lista `items`. Caso contrário, ela adiciona o prefixo, o conteúdo e o sufixo do elemento à lista `items`, executando o bloco fornecido no meio.",
    "summary_arabic": "function add  \nThis function creates a new tag object and adds it to a collection of items. \n\narguments:\nname: string\ncontent: string (optional, defaults to nil)\nattributes: hash\nactivator: object\nblock: block\n\nlogic:\n- Creates a new tag object using the provided name, content, attributes, and activator.\n- If a block is not given, it adds the rendered tag to the items collection and returns.\n- If a block is given, it adds the tag's prefix, then its content, executes the block, and finally adds the tag's suffix to the items collection.",
    "summary_hindi": "यह फ़ंक्शन 'add' नाम से एक नैविगेटर टैग जोड़ता है। यह टैग का नाम, सामग्री, विशेषताएं, एक्टिवेटर और एक ब्लॉक लेता है।  यदि ब्लॉक नहीं दिया गया है, तो यह टैग को रेंडर करके इसे 'items' में जोड़ देता है। यदि ब्लॉक दिया गया है, तो यह टैग के प्रीफिक्स, सामग्री, ब्लॉक को निष्पादित करता है और टैग के सफ़िक्स को 'items' में जोड़ता है।"
  },
  {
    "id": "sample_72060",
    "language": "ruby",
    "length_bucket": "medium",
    "code": "def deal(id, options = {})\n      options = update_by_expire_time options\n      if deal_not_latest?(id)\n        @rsqoot_deal = get(\"deals/#{id}\", options, SqootDeal)\n        @rsqoot_deal = @rsqoot_deal.deal if @rsqoot_deal\n      end\n      logger(uri: sqoot_query_uri, records: [@rsqoot_deal], type: 'deal', opts: options)\n      @rsqoot_deal\n    end",
    "docstring": "Retrieve a deal by id",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function 'deal' retrieves a deal from an API. It takes an 'id' argument, which is a unique identifier for the deal, and an optional 'options' argument, which is a hash of parameters. The function updates the 'options' hash based on expiration time. It then checks if the deal is the latest version. If not, it fetches the deal from the API using the provided 'id' and 'options'. The function logs the API request details and returns the retrieved deal object.",
    "summary_chinese": "该函数名为 `deal`，用于处理交易信息。它接受两个参数：`id`（类型为整数）和 `options`（类型为字典）。函数首先更新 `options` 字典，然后检查交易是否是最新的。如果不是，则从服务器获取交易信息并将其存储在 `@rsqoot_deal` 变量中。最后，函数记录请求信息并返回 `@rsqoot_deal` 变量的值。",
    "summary_french": "La fonction `deal` récupère un accord à partir de l'API Sqoot. Elle prend un identifiant d'accord (`id`) et un dictionnaire d'options (`options`) comme arguments.  Elle met à jour les options en fonction de la date d'expiration. Si l'accord n'est pas le plus récent, elle le récupère depuis l'API Sqoot. Ensuite, elle enregistre l'opération dans le journal et retourne l'accord.",
    "summary_spanish": "La función `deal` obtiene información sobre una oferta específica. Recibe el identificador de la oferta (`id`) como argumento obligatorio y un diccionario opcional (`options`) con parámetros adicionales.  Actualiza las opciones con información sobre la fecha de caducidad. Luego verifica si la oferta es la más reciente. Si no lo es, consulta la API de Sqoot para obtener los detalles de la oferta y los almacena en la variable `@rsqoot_deal`. Finalmente, registra la consulta en el registro y devuelve la información de la oferta.",
    "summary_portuguese": "A função `deal` busca um acordo pelo seu ID. Ela recebe o ID do acordo como argumento obrigatório e um dicionário opcional `options`. A função atualiza as opções com base no tempo de expiração e verifica se o acordo é o mais recente. Se não for, ela busca o acordo no servidor usando o ID e as opções fornecidas. Em seguida, ela registra a requisição e retorna o acordo encontrado.",
    "summary_arabic": "The function `deal` retrieves a deal from the Sqoot API. It takes an `id` representing the deal's identifier and an optional `options` hash. The function updates the `options` hash based on expiration time. It checks if the deal is the latest version and fetches it from the API if necessary. Finally, it logs the request details and returns the retrieved deal object.",
    "summary_hindi": "'deal' नामक फ़ंक्शन एक डील प्राप्त करने के लिए डिज़ाइन किया गया है। यह 'id' और वैकल्पिक रूप से 'options' (एक डिक्शनरी) के रूप में दो मान लेता है। यह 'options' को 'update_by_expire_time' फ़ंक्शन द्वारा अपडेट करता है। यदि डील नवीनतम नहीं है, तो यह 'deals/#{id}' URI से डील प्राप्त करता है और इसे 'SqootDeal' ऑब्जेक्ट में परिवर्तित करता है। फिर, यह 'logger' फ़ंक्शन को कॉल करता है, जो URI, डील रिकॉर्ड और अन्य विकल्पों को लॉग करता है। अंत में, यह प्राप्त डील वापस करता है।"
  },
  {
    "id": "sample_70707",
    "language": "ruby",
    "length_bucket": "medium",
    "code": "def nper(rate, pmt, pv, fv = 0, end_or_beginning = 0)\n      z = pmt * (1 + rate * end_or_beginning) / rate\n      temp = Math.log((-fv + z) / (pv + z))\n\n      temp / Math.log(1 + rate)\n    end",
    "docstring": "Calculates the number of payment periods for an investment based on\n constant-amount periodic payments and a constant interest rate.\n\n @param rate [Float] The interest rate as decimal (not per cent) per period\n @param pmt [Float] The payment amount made each period\n @param pv [Float] The present value of the payments\n @param fv [Float] The future value remaining after the final payment has been made\n @param end_or_begining [Integer] Whether payments are due at the end (0) or\n   beggining (1) of each period\n\n @return [Float]\n\n @example\n   Exonio.nper(0.07 / 12, -150, 8000) # ==> 64.07334877066185",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `nper` calculates the number of periods (n) in a loan or investment. It takes the interest rate, payment amount, present value, future value (optional, defaults to 0), and whether payments are made at the beginning or end of the period (optional, defaults to 0 for end) as arguments. The function first calculates a value `z` based on the payment amount, interest rate, and payment timing. Then, it uses logarithms to determine `temp`. Finally, it divides `temp` by the natural logarithm of (1 + interest rate) to obtain the number of periods.",
    "summary_chinese": "该函数名为nper，用于计算贷款或投资的期数。 \n\n参数包括：rate（利率），pmt（每期还款金额），pv（本金），fv（未来价值，可选，默认值为0），end_or_beginning（还款方式，0表示期末还款，1表示期初还款，可选，默认值为0）。\n\n函数的逻辑是：首先计算一个中间变量z，然后使用对数公式计算出期数。",
    "summary_french": "La fonction `nper` calcule le nombre de périodes (n) pour un paiement constant (PMT) donné. Elle prend en entrée le taux d'intérêt (rate), le paiement (pmt), le présent valeur (pv), la valeur future (fv) et un indicateur (end_or_beginning) pour déterminer si les paiements sont effectués au début ou à la fin de chaque période. La fonction utilise une formule mathématique impliquant la logarithme pour calculer le nombre de périodes.",
    "summary_spanish": "La función nper calcula el número de períodos de un préstamo o inversión. Recibe como argumentos: rate (tasa de interés), pmt (pago periódico), pv (valor presente), fv (valor futuro, opcional, con valor predeterminado 0) y end_or_beginning (indicador de si el pago se realiza al principio o al final del período, opcional, con valor predeterminado 0).  La lógica principal calcula primero una variable z y luego utiliza el logaritmo para determinar el número de períodos.",
    "summary_portuguese": "A função nper calcula o número de períodos de um investimento. Ela recebe os argumentos rate (taxa de juros), pmt (pagamento periódico), pv (valor presente), fv (valor futuro, opcional, com valor padrão 0) e end_or_beginning (indicador se o pagamento é no início ou no fim do período, opcional, com valor padrão 0). A lógica principal calcula primeiro um valor z e depois usa o logaritmo para determinar o número de períodos.",
    "summary_arabic": "function nper  يحسب عدد الفترات الزمنية اللازمة لضمان وصول قيمة الحاضر إلى قيمة المستقبل المحددة.  \narguments: rate (معدل الفائدة) - float, pmt (دفعة دورية) - float, pv (القيمة الحالية) - float, fv (القيمة المستقبلية) - float (optional, defaults to 0), end_or_beginning (0 for beginning of period, 1 for end of period) - int. \nlogic:  يتم حساب عدد الفترات الزمنية باستخدام معادلة رياضية تتضمن معدل الفائدة، دفعة دورية، القيمة الحالية، والقيمة المستقبلية.",
    "summary_hindi": "यह फ़ंक्शन 'nper' किसी निश्चित ब्याज दर, भुगतान राशि, वर्तमान मूल्य और भविष्य मूल्य के लिए आवश्यक भुगतान की संख्या की गणना करता है। यह फ़ंक्शन 'rate' (ब्याज दर), 'pmt' (भुगतान राशि), 'pv' (वर्तमान मूल्य), 'fv' (भविष्य मूल्य, मानक 0) और 'end_or_beginning' (भुगतान का समय, 0 = शुरुआत में, 1 = अंत में) इन पांच मानों को लेता है। यह पहले 'z' की गणना करता है, जो भुगतान राशि और ब्याज दर के आधार पर एक व्युत्पन्न मान है। फिर, यह 'temp' की गणना करता है, जो लघुगणक फ़ंक्शन का उपयोग करके 'z' और अन्य मानों पर निर्भर करता है। अंत में, यह 'temp' को लघुगणक (1 + ब्याज दर) से विभाजित करके भुगतान की संख्या की गणना करता है।"
  },
  {
    "id": "sample_70240",
    "language": "ruby",
    "length_bucket": "long",
    "code": "def ensure_issue_labels(owner, repo, issue_id)\n\n      issue = ensure_issue(owner, repo, issue_id, false, false, false)\n\n      if issue.nil?\n        warn \"Could not find issue #{owner}/#{repo} -> #{issue_id} for retrieving labels\"\n        return\n      end\n\n      issue_labels = db.from(:issue_labels, :repo_labels)\\\n                        .where(Sequel.qualify('issue_labels', 'label_id') => Sequel.qualify('repo_labels', 'id'))\\\n                        .where(Sequel.qualify('issue_labels', 'issue_id') => issue[:id])\\\n                        .select(Sequel.qualify('repo_labels', 'name')).all\n\n      retrieve_issue_labels(owner, repo, issue_id).reduce([]) do |acc, x|\n        if issue_labels.find {|y| y[:name] == x['name']}.nil?\n          acc << x\n        else\n          acc\n        end\n      end.map { |x| save{ensure_issue_label(owner, repo, issue[:issue_id], x['name']) }}.select{|x| !x.nil?}\n\n    end",
    "docstring": "Ensure that all labels have been assigned to the issue",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `ensure_issue_labels` retrieves and ensures the presence of specific labels on a given GitHub issue. It takes three arguments: `owner` (string), `repo` (string), and `issue_id` (integer). \n\nFirst, it retrieves the issue using the `ensure_issue` function. If the issue is not found, it logs a warning and returns. \n\nThen, it queries the database to find existing labels associated with the issue. It compares these labels with a list of labels retrieved from an external source using the `retrieve_issue_labels` function. \n\nFor each label in the retrieved list that is not found in the database, it calls the `ensure_issue_label` function to create a new label association in the database. Finally, it returns a list of successfully created label associations.",
    "summary_chinese": "该函数名为 ensure_issue_labels，用于确保问题标签的存在。它接受三个参数：owner（仓库所有者）、repo（仓库名称）、issue_id（问题ID）。 \n\n该函数首先尝试获取问题信息，如果问题不存在则发出警告并返回。 然后，它从数据库中查询问题对应的标签，并与已存在的标签进行比较。如果发现缺少的标签，则将其添加到数据库中。",
    "summary_french": "La fonction `ensure_issue_labels` récupère les étiquettes d'un problème GitHub. Elle prend en argument le nom du propriétaire du dépôt, le nom du dépôt et l'ID du problème. \n\nElle d'abord vérifie si le problème existe. Si oui, elle récupère les étiquettes du problème à partir de la base de données. Ensuite, elle compare les étiquettes récupérées avec les étiquettes présentes dans le problème. Si une étiquette n'est pas présente dans la base de données, elle est ajoutée. \n\n\nArguments:\n\nowner (string)\nrepo (string)\nissue_id (integer)",
    "summary_spanish": "La función `ensure_issue_labels` busca etiquetas para un problema específico en un repositorio. Recibe como argumentos `owner` (el nombre del propietario del repositorio), `repo` (el nombre del repositorio) e `issue_id` (el ID del problema). Primero, verifica si el problema existe. Si existe, consulta las etiquetas del problema en la base de datos. Luego, compara las etiquetas del problema con las etiquetas existentes en el repositorio y agrega las etiquetas que faltan a la base de datos.",
    "summary_portuguese": "The function `ensure_issue_labels` retrieves and ensures the presence of specific labels on a given issue. It takes three arguments: `owner` (string), `repo` (string), and `issue_id` (integer). \n\nFirst, it retrieves the issue using the `ensure_issue` function. If the issue is not found, it logs a warning and returns. \n\nThen, it queries the database to fetch the existing labels associated with the issue. It compares these labels with a list of labels retrieved using the `retrieve_issue_labels` function. \n\nFor each label in the retrieved list that is not found in the database, it calls the `ensure_issue_label` function to create a new label association in the database. Finally, it returns a list of successfully created label associations.",
    "summary_arabic": "The function `ensure_issue_labels` aims to ensure that a given issue has the necessary labels. It takes three arguments: `owner` (string), `repo` (string), and `issue_id` (integer). \n\nFirst, it retrieves the issue using the `ensure_issue` function. If the issue is not found, it logs a warning and returns. \n\nThen, it queries the database to fetch the existing labels associated with the issue. It compares these labels with the labels retrieved from another source (likely an external API) using the `retrieve_issue_labels` function. \n\nFor each label retrieved from the external source that is not found in the database, it calls the `ensure_issue_label` function to create a new label entry in the database. Finally, it returns a list of successfully created labels.",
    "summary_hindi": "यह फ़ंक्शन `ensure_issue_labels` नामक है और इसका उद्देश्य एक GitHub इश्यू के लिए लेबल सुनिश्चित करना है। यह तीन आर्गुमेंट्स लेता है: `owner` (GitHub उपयोगकर्ता का नाम), `repo` (GitHub रिपॉजिटरी का नाम) और `issue_id` (इश्यू का आईडी)। \n\nयह पहले `ensure_issue` फ़ंक्शन का उपयोग करके इश्यू की पुष्टि करता है। यदि इश्यू नहीं मिलता है, तो यह एक चेतावनी प्रदर्शित करता है और फ़ंक्शन समाप्त हो जाता है। \n\nअगर इश्यू मिलता है, तो यह डेटाबेस से मौजूदा लेबल प्राप्त करता है और उन्हें `retrieve_issue_labels` फ़ंक्शन का उपयोग करके प्राप्त लेबल के साथ तुलना करता है। \n\nअगर कोई लेबल मौजूद नहीं है, तो यह `ensure_issue_label` फ़ंक्शन का उपयोग करके लेबल को डेटाबेस में जोड़ता है।"
  },
  {
    "id": "sample_70974",
    "language": "ruby",
    "length_bucket": "long",
    "code": "def value_transform value, type\n      return nil if value.nil? || value.to_s.size == 0\n      case type\n      when :integer then value.to_i\n      when :autoincrement then value.to_i\n      when :string then value.to_s\n      when :float then value.to_f\n      when :bool then value.to_s\n      when :symbol then value.to_s\n      when :marshal then Marshal.dump(value)\n      when :array then Yajl::Encoder.encode(value)\n      when :hash then Yajl::Encoder.encode(value)\n      when :time then Time.parse(value.to_s).strftime(\"%Y.%m.%d %H:%M:%S\")\n      when :date then Date.parse(value.to_s).strftime(\"%Y-%m-%d\")\n      else value\n      end\n    end",
    "docstring": "convert value for valid format which can be saved in redis",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `value_transform` converts a given value to a specified data type. It takes two arguments: `value` of any type and `type` which is a symbol representing the desired data type. The function first checks if the value is nil or empty. If so, it returns nil. Otherwise, it uses a case statement to determine the appropriate conversion based on the specified type.  It converts the value to an integer, string, float, boolean, symbol, marshalled data, array, hash, time, or date as needed. If the type is not recognized, it returns the original value.",
    "summary_chinese": "该函数名为 `value_transform`，用于根据指定的类型转换输入值。它接受两个参数：`value`（需要转换的值）和 `type`（目标类型）。如果输入值为空或为空字符串，则返回 `nil`。 然后根据 `type` 的值进行转换：如果是整数，则转换为整数；如果是自动递增类型，也转换为整数；如果是字符串，则保持不变；如果是浮点数，则转换为浮点数；如果是布尔值，则转换为字符串；如果是符号，则转换为字符串；如果是 `marshal` 类型，则使用 `Marshal.dump` 序列化值；如果是数组或哈希，则使用 `Yajl::Encoder.encode` 序列化值；如果是时间，则转换为指定格式的字符串；如果是日期，则转换为指定格式的字符串；否则，保持原值。",
    "summary_french": "La fonction `value_transform` transforme une valeur en un type spécifique. Elle prend deux arguments : `value` (la valeur à transformer) et `type` (le type cible). La fonction renvoie `nil` si la valeur est nulle ou vide. Sinon, elle utilise une structure `case` pour convertir la valeur en fonction du type spécifié. Les types pris en charge sont : entier, auto-incrément, chaîne de caractères, flottant, booléen, symbole, marshal, tableau, hash, heure et date.  Si le type n'est pas reconnu, la fonction renvoie la valeur d'origine.",
    "summary_spanish": "La función `value_transform` transforma un valor a un tipo específico. Recibe dos argumentos: `value` de cualquier tipo y `type` que indica el tipo de destino. Si `value` es nulo o vacío, devuelve `nil`. De lo contrario, convierte `value` al tipo especificado: entero, autoincremento, cadena, flotante, booleano, símbolo, marshal, array, hash, tiempo o fecha. Si el tipo no es válido, devuelve el valor original.",
    "summary_portuguese": "A função `value_transform` transforma um valor em um tipo específico. Ela recebe dois argumentos: `value`, que é o valor a ser transformado, e `type`, que é o tipo desejado para o valor transformado. A função retorna `nil` se o valor for nulo ou vazio. Caso contrário, ela realiza a transformação de acordo com o tipo especificado.  Os tipos suportados são: inteiro, autoincremento, string, float, booleano, símbolo, marshal, array, hash, time e date. Para cada tipo, a função aplica a transformação apropriada. Se o tipo não for reconhecido, a função retorna o valor original.",
    "summary_arabic": "function value_transform takes two arguments: value of any type and type which is a symbol. the function returns nil if the value is nil or an empty string. otherwise, it converts the value to the specified type. if the type is :integer, :autoincrement, :float, or :bool, it converts the value to the corresponding type. if the type is :string, it converts the value to a string. if the type is :symbol, it converts the value to a string. if the type is :marshal, it serializes the value using Marshal.dump. if the type is :array or :hash, it serializes the value using Yajl::Encoder.encode. if the type is :time, it parses the value as a time and formats it as a string. if the type is :date, it parses the value as a date and formats it as a string. otherwise, it returns the value unchanged.",
    "summary_hindi": "यह फ़ंक्शन `value_transform` नाम का है और इसका उद्देश्य किसी दिए गए मान को विभिन्न प्रकारों में परिवर्तित करना है। यह दो मानों को लेता है: `value` जो परिवर्तित किया जाना चाहिए और `type` जो वांछित परिणाम का प्रकार निर्धारित करता है। \n\nयदि `value`  `nil` या खाली स्ट्रिंग है, तो यह `nil` वापस देता है। अन्यथा, यह `type` के आधार पर `value` को परिवर्तित करता है। \n\nउदाहरण के लिए, यदि `type` `:integer` है, तो यह `value` को एक पूर्णांक में परिवर्तित करेगा। यदि `type` `:string` है, तो यह `value` को एक स्ट्रिंग में परिवर्तित करेगा। \n\nयह विभिन्न प्रकारों के लिए अलग-अलग परिवर्तन लागू करता है, जैसे कि `:float`, `:bool`, `:symbol`, `:marshal`, `:array`, `:hash`, `:time` और `:date`."
  },
  {
    "id": "sample_70539",
    "language": "ruby",
    "length_bucket": "long",
    "code": "def parse_row(result_code)\n      field_count = @data_buffer.read_int16(18)\n      op_count = @data_buffer.read_int16(20)\n\n      if op_count > 0\n        raise Aerospike::Exceptions::Parse.new('Received bins that were not requested!')\n      end\n\n      key = parse_key(field_count)\n      item = key_map[key.digest]\n\n      if item\n        index = item.index\n        results[index] = (result_code == 0)\n      else\n        Aerospike::logger.debug(\"Unexpected batch key returned: #{key.namespace}, #{key.digest}\")\n      end\n    end",
    "docstring": ":nodoc:\n Parse all results in the batch.  Add records to shared list.\n If the record was not found, the bins will be nil.",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `parse_row` processes a row of data from an Aerospike result. It reads the number of fields and operation count from the data buffer. If there are operations, it raises an exception. It then parses the key from the data and looks up the corresponding item in a `key_map`. If the item is found, it sets the result in an array `results` based on the result code. If the item is not found, it logs a debug message. \n\n\nThe function takes one argument:\n\n* `result_code`: An integer representing the result code.",
    "summary_chinese": "parse_row 函数解析数据行。它接受一个 result_code 参数，类型为整数。首先，它从数据缓冲区读取字段数量和操作数量。如果操作数量大于0，则抛出异常。然后，它解析键并根据键的哈希值查找对应的项。如果找到项，则将结果存储到结果数组中；否则，记录一条调试日志。",
    "summary_french": "La fonction `parse_row` analyse une ligne de résultats. Elle prend en argument `result_code` qui représente le code de résultat. La fonction lit le nombre de champs et le nombre d'opérations à partir du tampon de données. Si le nombre d'opérations est supérieur à zéro, elle lève une exception. Ensuite, elle extrait la clé à partir du nombre de champs et recherche l'élément correspondant dans le map `key_map`. Si l'élément est trouvé, elle met à jour le résultat en fonction du code de résultat. Sinon, elle enregistre un message de debug.",
    "summary_spanish": "La función parse_row analiza una fila de resultados. Recibe un argumento llamado result_code de tipo entero. Lee el número de campos y el número de operaciones de un búfer de datos. Si hay operaciones, lanza una excepción. Luego, parsea una clave a partir del número de campos y busca un elemento en un mapa de claves. Si se encuentra el elemento, se establece un valor en un arreglo de resultados según el valor de result_code. Si no se encuentra el elemento, se registra un mensaje de depuración.",
    "summary_portuguese": "A função `parse_row` processa uma linha de resultado de uma operação no Aerospike. Ela recebe um código de resultado (`result_code`) como argumento. A função lê o número de campos e o número de operações da linha de resultado. Se houver operações, lança uma exceção pois isso indica que os bins não foram solicitados. A função então extrai a chave (`key`) da linha de resultado e verifica se ela existe no mapa `key_map`. Se a chave existir, a função atualiza o valor correspondente no array `results` com base no código de resultado. Caso contrário, registra um aviso no log.",
    "summary_arabic": "function parse_row  تحلل صف من البيانات. \n\narguments:\nresult_code  عدد صحيح \n\nlogic:\n1.  يحصل على عدد الحقول و عدد العمليات من buffer.\n2.  يُقيّم عدد العمليات، وإذا كان أكبر من 0، يُلقي خطأ.\n3.  يحلل المفتاح من عدد الحقول.\n4.  يُحصل على العنصر من خريطة المفتاح.\n5.  إذا وجد العنصر، يتم تحديث النتيجة في القائمة.\n6.  إذا لم يُوجد العنصر، يتم تسجيل رسالة debug.",
    "summary_hindi": "parse_row नामक फ़ंक्शन एक पंक्ति को पार्स करने के लिए जिम्मेदार है। यह result_code, field_count और op_count जैसे मानों को लेता है। यह  @data_buffer से field_count और op_count को पढ़ता है। यदि op_count 0 से अधिक है तो यह एक त्रुटि उत्पन्न करता है। फिर यह key को पार्स करता है और key_map में उस key के लिए संग्रहीत item को ढूंढता है। यदि item मिलता है तो यह results में संग्रहीत होता है। यदि item नहीं मिलता है तो यह एक डबग लॉग रिकॉर्ड करता है।"
  },
  {
    "id": "sample_72011",
    "language": "ruby",
    "length_bucket": "long",
    "code": "def action(id, act, *args) \n      data = case act\n        when \"reboot\" then {'reboot' =>{\"type\" => args[0]}}\t\n        when \"vnc\" then {'os-getVNCConsole' => { \"type\" => \"novnc\" }} \n        when \"stop\" then {'os-stop' => 'null'}\n        when \"start\" then {'os-start' => 'null'}\n        when \"pause\" then {'pause' => 'null'}\n        when \"unpause\" then {'unpause' => 'null'}\n        when \"suspend\" then {'suspend' => 'null'}\n        when \"resume\" then {'resume' => 'null'}\n        when \"create_image\" then {'createImage' => {'name' => args[0], 'metadata' => args[1]}} \n        else raise \"Invalid Action\"\n        end\n      return post_request(address(\"/servers/\" + id + \"/action\"), data, @token)\n    end",
    "docstring": "Perform an action on a server on Openstack, by passing an id,\n and an action, some actions require more data.\n\n E.g. action(id, \"reboot\", \"hard\")",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `action` takes an `id` (string), an `act` (string), and an arbitrary number of arguments (`*args`). It constructs a data dictionary based on the `act` value, which determines the type of server action to perform.  The dictionary is then used in a `post_request` to the server API endpoint.  If the `act` is invalid, it raises an \"Invalid Action\" error.",
    "summary_chinese": "该函数名为 action，用于根据指定的 action 类型，构造请求数据并发送到服务器进行操作。 \n\n该函数接受三个参数：id（字符串，服务器ID）、act（字符串，操作类型）和 *args（可变参数，操作类型需要的额外参数）。\n\n函数内部根据 act 的值，使用 case 语句选择相应的操作类型，并构造相应的请求数据。 然后，函数调用 post_request 函数发送请求到服务器，地址为 /servers/{id}/action，并携带请求数据和 token。",
    "summary_french": "La fonction `action` permet d'exécuter une action sur un serveur donné. Elle prend en argument l'identifiant du serveur (`id`), le type d'action (`act`) et des arguments optionnels (`*args`). \n\nEn fonction de la valeur de `act`, la fonction construit un dictionnaire de données représentant l'action à effectuer.  \n\nElle utilise ensuite la fonction `post_request` pour envoyer ces données à l'API du serveur.",
    "summary_spanish": "La función action recibe un id, un acto y argumentos opcionales.  Su propósito es ejecutar una acción en un servidor con el id proporcionado.  \n\nEl id es un entero, act es una cadena que indica la acción a realizar y *args son argumentos adicionales que dependen de la acción. \n\nLa función determina la acción a realizar mediante una sentencia case y construye un diccionario de datos con la acción y sus argumentos. Luego, realiza una solicitud POST a la API del servidor con los datos y un token de autenticación. Si la acción no es válida, se lanza un error.",
    "summary_portuguese": "A função action executa ações em um servidor com base em um ID e um tipo de ação. Ela recebe o ID do servidor como argumento inteiro, o tipo de ação como string e pode receber argumentos adicionais variáveis.  A função usa uma estrutura case para determinar a ação a ser executada e constrói um dicionário de dados com os parâmetros necessários. Em seguida, faz uma requisição POST para a API do servidor com os dados e um token de autenticação.  Se o tipo de ação for inválido, a função lança uma exceção.",
    "summary_arabic": "The function action takes an id, an action string, and an arbitrary number of arguments. It constructs a data dictionary based on the action, mapping it to a specific API request.  The function then makes a POST request to the specified API endpoint using the constructed data and a token.  If the action is invalid, it raises an error.",
    "summary_hindi": "इस फ़ंक्शन का नाम `action` है। यह एक सर्वर के लिए एक्शन को निष्पादित करने के लिए डिज़ाइन किया गया है। यह `id` (सर्वर का आईडी), `act` (निष्पादित करने वाला एक्शन) और `*args` (एक्शन के लिए अतिरिक्त आर्गुमेंट) लेता है। यह `act` के आधार पर एक डेटा डिक्शनरी बनाता है और फिर `post_request` फ़ंक्शन का उपयोग करके सर्वर के `/action` एंडपॉइंट पर यह डेटा भेजता है। यदि `act` मान्य नहीं है, तो यह \"Invalid Action\" त्रुटि उत्पन्न करता है।"
  },
  {
    "id": "sample_70988",
    "language": "ruby",
    "length_bucket": "long",
    "code": "def parse_field(e)\r\n      name, min, max, type, required, validation = parse_attributes(e)\r\n\r\n      # FIXME - for compatibility with d12 - constants are stored in attribute 'type' and are enclosed in\r\n      # double quotes\r\n      const_field =  e.attributes[\"const\"]\r\n      if(const_field)\r\n        type = \"\\\"#{const_field}\\\"\"\r\n      end\r\n\r\n      Field.new(name, type, required, min, max, validation)\r\n    end",
    "docstring": "parse_attributes",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function parse_field takes an element e as input and creates a new Field object. It first extracts attributes like name, min, max, type, required, and validation from the element using the parse_attributes function. It then checks if the element has a \"const\" attribute and if so, updates the type attribute with the value of the \"const\" attribute enclosed in double quotes. Finally, it creates a new Field object using the extracted attributes and returns it.",
    "summary_chinese": "parse_field 函数解析字段信息。它接受一个 e 参数，类型为元素对象。该函数首先使用 parse_attributes 函数解析元素对象的属性，获取字段名、最小值、最大值、类型、是否必填以及验证规则。然后，它检查元素对象是否存在名为 \"const\" 的属性，如果存在，则将该属性值作为类型。最后，它创建一个新的 Field 对象，并将解析出的信息作为参数传递给构造函数。",
    "summary_french": "La fonction `parse_field` prend un élément `e` en argument et crée un nouvel objet `Field`. Elle extrait les attributs `name`, `min`, `max`, `type`, `required` et `validation` de l'élément `e` en utilisant la fonction `parse_attributes`. Si l'élément `e` possède l'attribut `const`, la valeur de cet attribut est utilisée pour définir le type du champ. Enfin, la fonction crée un nouvel objet `Field` avec les valeurs extraites et les retourne.",
    "summary_spanish": "La función parse_field toma un elemento como argumento y crea un nuevo objeto Field.  El elemento se analiza para obtener el nombre, los valores mínimo y máximo, el tipo, la obligatoriedad y la validación. Si el elemento tiene un atributo \"const\", el tipo se actualiza con el valor de ese atributo entre comillas dobles. Finalmente, se crea un nuevo objeto Field con los valores extraídos. \n\n\nEl argumento de la función es 'e' de tipo elemento.",
    "summary_portuguese": "A função parse_field recebe um objeto e o converte em um objeto Field. Ela extrai atributos como nome, limites (min e max), tipo, obrigatoriedade e validação do objeto. Se o atributo 'const' existir, o tipo é atualizado com o valor do atributo 'const' entre aspas duplas. Finalmente, cria um novo objeto Field com os valores extraídos. \n\n\nArguments:\ne (objeto) \n\nLogic:\nExtrai atributos de um objeto e cria um novo objeto Field com esses atributos.",
    "summary_arabic": "parse_field هو دالة تحلل خصائص حقل. يتلقى الحقل كمدخل (e) ويقوم بتحليل خصائص مثل الاسم، الحد الأدنى، الحد الأقصى، نوع الحقل، الإلزامية، وتحقق صحة الحقل. يقوم الدالة بتحويل خصائص الحقل إلى  Field.new.  يُستخدم  parse_attributes(e) لتحليل الخصائص.  إذا وجد  \"const\" في خصائص الحقل، يتم تحديث نوع الحقل.  في النهاية، يتم إنشاء  Field.new  باستخدام البيانات المحللة.",
    "summary_hindi": "parse_field नामक फ़ंक्शन एक फ़ील्ड का ऑब्जेक्ट बनाता है। यह फ़ंक्शन एक एलिमेंट (e) लेता है और उसमें मौजूद विशेषताओं को उपयोग करके एक नया फ़ील्ड ऑब्जेक्ट बनाता है।  एलिमेंट में नाम, न्यूनतम मान, अधिकतम मान, प्रकार, अनिवार्यता और सत्यापन जैसे गुण होते हैं।  यदि एलिमेंट में \"const\" नामक एक विशेषता होती है, तो फ़ील्ड का प्रकार उस विशेषता के मान से लिया जाता है। अंत में, फ़ंक्शन एक नया Field ऑब्जेक्ट बनाता है और उसे वापस करता है।"
  },
  {
    "id": "sample_70994",
    "language": "ruby",
    "length_bucket": "long",
    "code": "def method_missing(meth, *args, &block)\r\n      str = meth.id2name\r\n      str = str[1..str.length] if str =~ /^_\\d+$/ # to avoid pure number names like 270, 997, etc.\r\n      #puts \"Missing #{str}\"\r\n      if str =~ /=$/\r\n        # Assignment\r\n        str.chop!\r\n        #puts str\r\n        case self\r\n        when X12::Segment\r\n          res = find_field(str)\r\n          throw Exception.new(\"No field '#{str}' in segment '#{self.name}'\") if EMPTY == res\r\n          res.content = args[0].to_s\r\n          #puts res.inspect\r\n        else\r\n          throw Exception.new(\"Illegal assignment to #{meth} of #{self.class}\")\r\n        end # case\r\n      else\r\n        # Retrieval\r\n        res = find(str)\r\n        yield res if block_given?\r\n        res\r\n      end # if assignment\r\n    end",
    "docstring": "The main method implementing Ruby-like access methods for nested elements",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `method_missing` handles calls to undefined methods. It takes the missing method name (`meth`), any arguments (`*args`), and an optional block (`&block`). \n\nIt first extracts the method name from `meth.id2name`, removing any leading underscore and number prefixes. \n\nIf the method name ends with '=', it assumes an assignment operation. It removes the '=' sign and, depending on the object's type, either sets the value of a field in an X12::Segment object or throws an exception for other object types.\n\nIf the method name doesn't end with '=', it assumes a retrieval operation. It finds the corresponding object and yields it to the block if provided, otherwise returning the object itself.",
    "summary_chinese": "这个函数名为 `method_missing`，用于处理未定义的方法调用。它接受一个方法名 `meth`，以及任意数量的参数 `*args` 和一个可选的代码块 `&block`。 \n\n如果方法名以 `=` 结尾，则认为是赋值操作，函数会截取方法名，并根据对象类型进行相应的赋值操作。如果对象是 `X12::Segment`，则会查找对应的字段并赋值；否则，会抛出异常。\n\n如果方法名不以 `=` 结尾，则认为是获取操作，函数会查找对应的对象属性，并可选地执行代码块，最后返回该属性的值。",
    "summary_french": "La fonction `method_missing` gère les appels de méthodes non définis. Elle prend en argument `meth` (le nom de la méthode manquante), `*args` (arguments supplémentaires) et `&block` (un bloc de code). \n\nSi le nom de la méthode se termine par `=`, la fonction traite l'appel comme une affectation. Elle extrait le nom du champ à modifier, le recherche dans l'objet courant et assigne la valeur fournie dans `args[0]`. Si le nom de la méthode ne se termine pas par `=`, la fonction traite l'appel comme une récupération. Elle recherche le champ correspondant et l'exécute dans le bloc fourni si un bloc est présent.",
    "summary_spanish": "La función `method_missing` maneja llamadas a métodos no definidos. Toma un nombre de método (`meth`), argumentos variables (`*args`) y un bloque opcional (`&block`). Si el nombre de método termina en `=`, se trata de una asignación. En ese caso, se extrae el nombre del campo, se busca en el objeto actual y se asigna el valor del primer argumento. Si no termina en `=`, se trata de una consulta. Se busca el campo en el objeto actual y se devuelve, ejecutando el bloque si se proporciona. Si el campo no se encuentra, se lanza una excepción.",
    "summary_portuguese": "The function `method_missing` handles calls to undefined methods. It takes the method name (`meth`), any arguments (`*args`), and a block (`&block`). \n\nIt first extracts the method name from `meth.id2name`, removing any leading underscore and digits. \n\nIf the method name ends with `=`, it assumes an assignment and tries to find the corresponding field in the object. If found, it sets the field's content to the first argument. Otherwise, it raises an exception.\n\nIf the method name doesn't end with `=`, it assumes a retrieval and tries to find the corresponding field. If found, it yields the field to the block (if provided) and returns the field. Otherwise, it raises an exception.",
    "summary_arabic": "This function, named method_missing, handles calls to undefined methods. It takes the method name (meth), any arguments (args), and an optional block (block). \n\nIt first extracts the method name from meth.id2name, removing any leading underscore and digits. \n\nIf the method name ends with '=', it assumes it's an assignment. It removes the '=' and finds the corresponding field in the object. If found, it sets the field's content to the first argument. Otherwise, it raises an exception.\n\nIf the method name doesn't end with '=', it assumes it's a retrieval. It finds the corresponding field and yields it to the block if provided. Otherwise, it returns the field.",
    "summary_hindi": "यह फ़ंक्शन `method_missing` नामक एक फ़ंक्शन है जो किसी ऑब्जेक्ट पर मौजूद लेकिन परिभाषित नहीं किए गए तरीके को संभालता है। यह फ़ंक्शन दिए गए तरीके के नाम को प्राप्त करता है और यह निर्धारित करता है कि क्या यह एक असाइनमेंट या पुनर्प्राप्ति अनुरोध है। यदि यह असाइनमेंट है, तो यह ऑब्जेक्ट के अंदर संबंधित फ़ील्ड को खोजता है और उसका मान दिए गए मान से अपडेट करता है। यदि यह पुनर्प्राप्ति अनुरोध है, तो यह ऑब्जेक्ट के अंदर संबंधित फ़ील्ड को खोजता है और उसे वापस देता है। \n\n\nइस फ़ंक्शन को `meth`, `*args` और `&block` नामक तीन आर्गुमेंट्स दिए जाते हैं। `meth`  मौजूद लेकिन परिभाषित नहीं किए गए तरीके का प्रतिनिधित्व करता है। `*args`  अन्य किसी भी आर्गुमेंट्स को रखता है जो तरीके को कॉल करते समय दिए गए हैं। `&block`  किसी भी ब्लॉक को रखता है जो तरीके को कॉल करते समय दिए गए हैं।"
  },
  {
    "id": "sample_70261",
    "language": "ruby",
    "length_bucket": "long",
    "code": "def retrieve_commit_comment(owner, repo, sha, id)\n\n      comment = persister.find(:commit_comments, {'commit_id' => sha,\n                                                  'id' => id}).first\n      if comment.nil?\n        r = api_request(ghurl \"repos/#{owner}/#{repo}/comments/#{id}\")\n\n        if r.nil? or r.empty?\n          warn \"Could not find commit_comment #{id}. Deleted?\"\n          return\n        end\n\n        persister.store(:commit_comments, r)\n        info \"Added commit_comment #{r['commit_id']} -> #{r['id']}\"\n        persister.find(:commit_comments, {'commit_id' => sha, 'id' => id}).first\n      else\n        debug \"Commit comment #{comment['commit_id']} -> #{comment['id']} exists\"\n        comment\n      end\n    end",
    "docstring": "Retrieve a single comment",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function retrieve_commit_comment retrieves a commit comment from either a local database or a GitHub API request. It takes four arguments: owner (string), repo (string), sha (string), and id (integer). \n\nFirst, it checks if the comment exists in the local database based on the provided sha and id. If found, it returns the comment. Otherwise, it makes an API request to GitHub to fetch the comment. If the API request is successful, it stores the comment in the local database and returns it. If the API request fails or returns an empty response, it logs a warning and returns.",
    "summary_chinese": "该函数名为 `retrieve_commit_comment`，用于获取指定仓库中特定提交的评论。 \n\n它接受四个参数：`owner`（仓库所有者）、`repo`（仓库名称）、`sha`（提交哈希值）、`id`（评论ID）。\n\n该函数首先尝试从本地数据库中查找指定提交和评论的记录。如果找不到，则向 GitHub API 发送请求获取评论信息。如果 API 请求成功，则将评论信息存储到本地数据库并返回评论信息。否则，将发出警告信息并返回。如果本地数据库中找到记录，则直接返回记录。",
    "summary_french": "La fonction `retrieve_commit_comment` récupère un commentaire de commit à partir d'un dépôt GitHub. Elle prend en argument le nom du propriétaire du dépôt (`owner`), le nom du dépôt (`repo`), l'identifiant du commit (`sha`) et l'identifiant du commentaire (`id`). \n\nLa fonction vérifie d'abord si le commentaire existe déjà dans une base de données locale (`persister`). Si oui, elle le retourne. Sinon, elle effectue une requête à l'API GitHub pour récupérer le commentaire. Si la requête réussit, elle stocke le commentaire dans la base de données locale et le retourne. Sinon, elle affiche un message d'avertissement et retourne `nil`.",
    "summary_spanish": "La función retrieve_commit_comment busca un comentario de un commit en un repositorio de GitHub. Recibe como argumentos owner (nombre del propietario del repositorio), repo (nombre del repositorio), sha (identificador del commit) e id (identificador del comentario). Primero, busca el comentario en una base de datos local. Si no lo encuentra, realiza una solicitud a la API de GitHub para obtener el comentario. Si la solicitud es exitosa, guarda el comentario en la base de datos local e informa sobre la acción. Finalmente, devuelve el comentario encontrado, ya sea de la base de datos local o de la API de GitHub.",
    "summary_portuguese": "A função retrieve_commit_comment busca um comentário de commit no repositório. Ela recebe os argumentos owner (nome do dono do repositório), repo (nome do repositório), sha (hash do commit) e id (identificador do comentário). \n\nA função primeiro verifica se o comentário já existe na base de dados. Se existir, retorna o comentário. Caso contrário, faz uma requisição à API do GitHub para buscar o comentário. Se a requisição for bem-sucedida, o comentário é armazenado na base de dados e retornado. Caso contrário, um aviso é exibido e a função retorna.",
    "summary_arabic": "retrieve_commit_comment هي دالة تسترجع تعليق من ملف commit.  تقبل الدالة أربعة أرجومينت: owner (اسم مالك repository) و repo (اسم repository) و sha (hash من commit) و id (رقم التعليق). \n\nتبحث الدالة أولاً في قاعدة البيانات عن التعليق باستخدام commit_id و id. \n\nإذا وجد التعليق في قاعدة البيانات، يتم إرجاعه. \n\nإذا لم يتم العثور على التعليق في قاعدة البيانات، يتم استدعاء API من GitHub لاسترجاع التعليق. \n\nإذا تم العثور على التعليق على API، يتم تخزينه في قاعدة البيانات ثم يتم إرجاعه. \n\nإذا لم يتم العثور على التعليق على API، يتم إصدار تحذير وتوقف الدالة.",
    "summary_hindi": "इस फ़ंक्शन का नाम `retrieve_commit_comment` है। यह फ़ंक्शन किसी दिए गए रिपॉजिटरी में एक विशिष्ट कमीट पर एक कमेंट प्राप्त करता है। \n\nयह फ़ंक्शन `owner`, `repo`, `sha` और `id` नामक चार मानों को लेता है। `owner` और `repo` रिपॉजिटरी के मालिक और नाम हैं, `sha` कमीट का SHA है और `id` कमेंट का ID है।\n\nफ़ंक्शन पहले एक डेटाबेस में कमेंट की तलाश करता है। यदि कमेंट डेटाबेस में मौजूद है, तो यह कमेंट वापस करता है। यदि कमेंट डेटाबेस में नहीं है, तो यह GitHub API से कमेंट प्राप्त करता है, इसे डेटाबेस में स्टोर करता है और फिर कमेंट वापस करता है।"
  },
  {
    "id": "sample_71661",
    "language": "ruby",
    "length_bucket": "long",
    "code": "def imap_find(imap)\n      options = Clacks.config[:find_options]\n      delete_after_find = options[:delete_after_find]\n      begin\n        break if stopping?\n        uids = imap.uid_search(options[:keys] || 'ALL')\n        uids.reverse! if options[:what].to_sym == :last\n        uids = uids.first(options[:count]) if options[:count].is_a?(Integer)\n        uids.reverse! if (options[:what].to_sym == :last && options[:order].to_sym == :asc) ||\n                         (options[:what].to_sym != :last && options[:order].to_sym == :desc)\n        processed = 0\n        expunge = false\n        uids.each do |uid|\n          break if stopping?\n          source = imap.uid_fetch(uid, ['RFC822']).first.attr['RFC822']\n          mail = nil\n          begin\n            mail = Mail.new(source)\n            mail.mark_for_delete = true if delete_after_find\n            Clacks.config[:on_mail].call(mail)\n          rescue StandardError => e\n            Clacks.logger.error(e.message)\n            Clacks.logger.error(e.backtrace)\n          end\n          begin\n            imap.uid_copy(uid, options[:archivebox]) if options[:archivebox]\n            if delete_after_find && (mail.nil? || mail.is_marked_for_delete?)\n              expunge = true\n              imap.uid_store(uid, \"+FLAGS\", [Net::IMAP::DELETED])\n            end\n          rescue StandardError => e\n            Clacks.logger.error(e.message)\n          end\n          processed += 1\n        end\n        imap.expunge if expunge\n      end while uids.any? && processed == uids.length\n    end",
    "docstring": "Keep processing emails until nothing is found anymore,\n or until a QUIT signal is received to stop the process.",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `imap_find` processes emails from an IMAP server. It retrieves emails based on specified search criteria defined in `Clacks.config[:find_options]`.  The function iterates through the retrieved emails, calls a configured callback function `Clacks.config[:on_mail]` for each email, and optionally archives or deletes emails based on configuration settings. \n\nArguments:\n\nimap: An IMAP connection object\n\nKey Logic:\n\n1. Retrieves email UIDs based on search criteria.\n2. Orders the UIDs based on configuration options.\n3. Iterates through the UIDs, fetching email content and processing each email.\n4. Calls the configured callback function for each email.\n5. Archives or deletes emails based on configuration settings.\n6. Expunges deleted emails from the server.",
    "summary_chinese": "imap_find 函数用于从 IMAP 服务器中查找邮件。它接受一个 imap 对象作为参数。函数首先从配置文件中获取查找选项，然后使用这些选项在 IMAP 服务器上搜索邮件。根据选项，函数可以按时间顺序或倒序排列邮件，并限制返回的邮件数量。函数遍历搜索到的邮件，并为每个邮件执行以下操作：解析邮件内容，调用配置的 on_mail 回调函数处理邮件，并将邮件标记为已删除（如果配置为删除）。最后，函数如果配置为删除邮件，则从 IMAP 服务器上删除已标记为已删除的邮件。",
    "summary_french": "La fonction `imap_find` recherche des messages dans un serveur IMAP en fonction des options de configuration. Elle prend en argument un objet `imap` représentant la connexion IMAP. La fonction parcourt les identifiants de message (`uids`) trouvés, traite chaque message en l'appelant à la fonction `on_mail` définie dans la configuration et effectue des opérations d'archivage ou de suppression en fonction des options. Elle utilise également des mécanismes de gestion des erreurs et de suppression des messages supprimés.",
    "summary_spanish": "La función imap_find recibe un objeto imap como argumento. Busca mensajes de correo electrónico en el servidor IMAP utilizando las opciones de búsqueda configuradas en Clacks.config[:find_options].  Las opciones incluyen claves de búsqueda, el número máximo de mensajes a devolver, el orden de los mensajes y si se deben eliminar los mensajes después de la búsqueda. La función itera sobre los mensajes encontrados, los procesa llamando a la función Clacks.config[:on_mail] para cada uno y, opcionalmente, los copia a una carpeta de archivo y los elimina del servidor.  Si se configura la eliminación después de la búsqueda, los mensajes marcados para eliminación se eliminan del servidor después de que se hayan procesado todos los mensajes.",
    "summary_portuguese": "A função `imap_find` busca mensagens de email em uma caixa de entrada IMAP. Ela recebe uma conexão IMAP como argumento e processa as mensagens de acordo com as configurações definidas em `Clacks.config[:find_options]`. A função busca mensagens com base nos critérios especificados em `options[:keys]`, ordena-as de acordo com `options[:order]` e `options[:what]`, e processa cada mensagem chamando a função `Clacks.config[:on_mail]`. Após o processamento, a função pode mover as mensagens para uma caixa de arquivo (`options[:archivebox]`) e exclui-las se configurado (`delete_after_find`). \n\n\nimap: conexão IMAP\noptions: hash contendo configurações de busca\ndelete_after_find: boolean indicando se as mensagens devem ser excluídas após o processamento\nkeys: string ou array de strings com critérios de busca\nwhat: símbolo indicando se a busca deve retornar as últimas ou primeiras mensagens\ncount: inteiro indicando o número máximo de mensagens a serem processadas\norder: símbolo indicando a ordem de ordenação das mensagens\narchivebox: string com o nome da caixa de arquivo\n\n\nA função itera sobre as mensagens encontradas, processa cada uma delas e, se configurado, as move para a caixa de arquivo e as exclui.  Após o processamento de todas as mensagens, a função exclui as mensagens excluídas da caixa de entrada.",
    "summary_arabic": "The function `imap_find` processes emails from an IMAP server. It takes an IMAP connection object as input. It retrieves emails based on specified search criteria defined in the `Clacks.config[:find_options]` configuration. The function iterates through the retrieved emails, calls a callback function `Clacks.config[:on_mail]` for each email, and optionally archives or deletes emails based on configuration settings. \n\n\nThe function arguments are:\n\n* `imap`: An IMAP connection object.\n\nThe function's key logic involves:\n\n1. Retrieving email UIDs based on search criteria.\n2. Sorting the UIDs based on the specified order.\n3. Iterating through the UIDs and fetching email content.\n4. Calling the callback function for each email.\n5. Archiving or deleting emails based on configuration.\n6. Expunging deleted emails from the server.",
    "summary_hindi": "imap_find फ़ंक्शन IMAP सर्वर से ईमेल खोजने और उन्हें संसाधित करने के लिए जिम्मेदार है। यह एक IMAP ऑब्जेक्ट और कुछ कॉन्फ़िगरेशन विकल्पों को लेता है। यह ईमेल की सूची प्राप्त करता है, उन्हें क्रमबद्ध करता है और प्रत्येक ईमेल को संसाधित करता है। प्रत्येक ईमेल को संसाधित करने के लिए, यह ईमेल को प्राप्त करता है, इसे एक Mail ऑब्जेक्ट में परिवर्तित करता है, और एक कॉलबैक फ़ंक्शन को ईमेल पास करता है। यदि कॉन्फ़िगरेशन में निर्दिष्ट है, तो यह ईमेल को आर्काइव बॉक्स में कॉपी करता है और इसे हटा देता है। अंत में, यह IMAP सर्वर से हटाए गए ईमेल को हटा देता है।"
  },
  {
    "id": "sample_69975",
    "language": "ruby",
    "length_bucket": "long",
    "code": "def project_file\n      if fetcher && fetcher.is_a?(NetFetcher)\n        log.deprecated(log_key) do\n          \"project_file (DSL). This is a property of the NetFetcher and will \" \\\n          \"not be publically exposed in the next major release. In general, \" \\\n          \"you should not be using this method in your software definitions \" \\\n          \"as it is an internal implementation detail of the NetFetcher. If \" \\\n          \"you disagree with this statement, you should open an issue on the \" \\\n          \"Omnibus repository on GitHub an explain your use case. For now, \" \\\n          \"I will return the path to the downloaded file on disk, but please \" \\\n          \"rethink the problem you are trying to solve :).\"\n        end\n\n        fetcher.downloaded_file\n      else\n        log.warn(log_key) do\n          \"Cannot retrieve a `project_file' for software `#{name}'. This \" \\\n          \"attribute is actually an internal representation that is unique \" \\\n          \"to the NetFetcher class and requires the use of a `source' \" \\\n          \"attribute that is declared using a `:url' key. For backwards-\" \\\n          \"compatability, I will return `nil', but this is most likely not \" \\\n          \"your desired behavior.\"\n        end\n\n        nil\n      end\n    end",
    "docstring": "The path to the downloaded file from a NetFetcher.\n\n @deprecated There is no replacement for this DSL method",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `project_file` determines the path to a downloaded file associated with a software package. It takes no arguments. \n\nIf the input `fetcher` is an instance of `NetFetcher`, the function logs a deprecation warning and returns the path to the downloaded file using `fetcher.downloaded_file`. Otherwise, it logs a warning message explaining that the `project_file` attribute is internal to `NetFetcher` and should be accessed using a `source` attribute with a `:url` key. In this case, it returns `nil`.",
    "summary_chinese": "该函数名为 `project_file`，用于获取软件下载文件的路径。它接受一个参数 `fetcher`，类型为 `NetFetcher`。如果 `fetcher` 是 `NetFetcher` 的实例，则返回 `fetcher.downloaded_file`，并发出警告，说明该方法将在未来版本中不再公开。否则，发出警告，说明该方法需要使用 `source` 属性，并返回 `nil`。",
    "summary_french": "La fonction `project_file` détermine le chemin du fichier téléchargé pour un logiciel. Elle prend en argument `fetcher` qui est un objet de type `NetFetcher`. Si `fetcher` est un objet `NetFetcher`, la fonction retourne le chemin du fichier téléchargé (`fetcher.downloaded_file`). Sinon, elle affiche un message d'avertissement et retourne `nil`.",
    "summary_spanish": "La función `project_file` determina la ruta del archivo descargado para un software. Recibe un objeto `fetcher` como argumento. Si `fetcher` es una instancia de `NetFetcher`, devuelve la ruta del archivo descargado. De lo contrario, emite una advertencia y devuelve `nil`.",
    "summary_portuguese": "A função `project_file` verifica se o argumento `fetcher` é um objeto `NetFetcher`. Se for, retorna o caminho do arquivo baixado pelo `fetcher`. Caso contrário, emite um aviso e retorna `nil`.",
    "summary_arabic": "function project_file  \n\nThis function aims to retrieve the path to a downloaded file associated with a software project. It takes no arguments.\n\nThe function first checks if the provided fetcher object is an instance of NetFetcher. If it is, it logs a deprecation warning indicating that the function is intended for internal use and will be removed in a future release. It then returns the path to the downloaded file using the fetcher's downloaded_file method.\n\nIf the fetcher is not a NetFetcher, the function logs a warning message explaining that the project_file attribute is an internal representation and should be accessed using a source attribute with a :url key. It then returns nil.",
    "summary_hindi": "यह फ़ंक्शन `project_file` नाम से जाना जाता है और यह किसी सॉफ़्टवेयर के डाउनलोड किए गए फ़ाइल के पथ को वापस करता है। यह फ़ंक्शन एक `fetcher` नामक एक ऑब्जेक्ट को लेता है जो `NetFetcher` क्लास का एक उदाहरण होना चाहिए। यदि `fetcher` एक `NetFetcher` ऑब्जेक्ट है, तो यह फ़ंक्शन `fetcher.downloaded_file` को वापस करता है। अन्यथा, यह एक चेतावनी लॉग करता है और `nil` वापस करता है।"
  },
  {
    "id": "sample_71947",
    "language": "ruby",
    "length_bucket": "long",
    "code": "def scope(scope_name, scope_enum_keys)\n      target_enum = @record_class.defined_enums[@enum_name.to_s]\n      sub_enum_values = target_enum.values_at(*scope_enum_keys)\n\n      if @record_class.defined_enum_scopes.has_key?(scope_name)\n        fail ArgumentError,\n             \"Conflicting scope names. A scope named #{scope_name} has already been defined\"\n      elsif sub_enum_values.include?(nil)\n        unknown_key = scope_enum_keys[sub_enum_values.index(nil)]\n        fail ArgumentError, \"Unknown key - #{unknown_key} for enum #{@enum_name}\"\n      elsif @record_class.respond_to?(scope_name.to_s.pluralize)\n        fail ArgumentError,\n             \"Scope name - #{scope_name} conflicts with a class method of the same name\"\n      elsif @record_class.instance_methods.include?(\"#{scope_name}?\".to_sym)\n        fail ArgumentError,\n             \"Scope name - #{scope_name} conflicts with the instance method - #{scope_name}?\"\n      end\n\n      sub_enum_entries = target_enum.slice(*scope_enum_keys)\n      @record_class.defined_enum_scopes[scope_name] = sub_enum_entries\n\n      # 1. Instance method <scope_name>?\n      @record_class.send(:define_method, \"#{scope_name}?\") { sub_enum_entries.include? self.role }\n\n      # 2. The class scope with the scope name\n      @record_class.scope scope_name.to_s.pluralize,\n                          -> { @record_class.where(\"#{@enum_name}\" => sub_enum_entries.values) }\n\n      @scope_names << scope_name\n    end",
    "docstring": "Initialize a new ScopeCreator object\n @param [ActiveRecord]\n @param [String, Symbol]\n Add a scope of the enum to the class. It creates an instance method - <scope_name>? and a\n ActiveRecord class scope with the same name as the enum scope.\n @param [String, Symbol] The name of the enum scope\n @param [Array<String>, Array<Symbol>] The list of keys of the enum",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `scope` defines a scope for a record class based on a given enum and scope name. It takes `scope_name` (string) and `scope_enum_keys` (array of strings) as arguments. \n\nThe function first checks for potential conflicts with existing scopes, class methods, or instance methods. Then, it extracts the relevant enum values based on the provided keys. It stores the scope definition in the `@record_class.defined_enum_scopes` hash. Finally, it defines an instance method `scope_name?` to check if an instance belongs to the scope and a class scope using the defined enum values.",
    "summary_chinese": "该函数名为 `scope`，用于定义枚举的范围。它接受两个参数：`scope_name`（范围名称，字符串类型）和 `scope_enum_keys`（包含范围内枚举值的键列表，数组类型）。 \n\n函数首先检查是否已定义同名的范围，如果已定义则抛出异常。然后检查范围内的枚举值是否包含空值，如果包含则抛出异常。最后检查范围名称是否与类方法或实例方法冲突，如果冲突则抛出异常。\n\n如果以上检查通过，函数将范围内的枚举值存储到 `@record_class.defined_enum_scopes` 中。然后，函数定义一个名为 `#{scope_name}?` 的实例方法，用于检查实例是否属于该范围。最后，函数定义一个名为 `#{scope_name.to_s.pluralize}` 的类范围，用于查询属于该范围的记录。",
    "summary_french": "La fonction `scope` définit un nouveau scope pour un enum donné. Elle prend deux arguments : `scope_name` (une chaîne de caractères représentant le nom du scope) et `scope_enum_keys` (un tableau de chaînes de caractères représentant les clés des valeurs de l'enum à inclure dans le scope). La fonction vérifie d'abord s'il existe déjà un scope avec le même nom, s'il y a des clés inconnues dans `scope_enum_keys` et s'il y a des conflits avec des méthodes existantes dans la classe. Si aucune erreur n'est détectée, elle définit deux choses : une méthode d'instance `#{scope_name}?` qui vérifie si l'instance appartient au scope et un scope de classe `#{scope_name.pluralize}` qui filtre les instances en fonction des valeurs du scope.",
    "summary_spanish": "La función `scope` define un nuevo alcance para un enumerado en un modelo de clase. Recibe dos argumentos: `scope_name` (string) que es el nombre del alcance y `scope_enum_keys` (array de strings) que son las claves del enumerado que pertenecen al alcance. \n\nPrimero, verifica si hay conflictos con nombres de alcance existentes o con métodos de clase o instancia. Luego, extrae los valores del enumerado correspondientes a las claves especificadas y los almacena en `@record_class.defined_enum_scopes` con el nombre del alcance como clave. Finalmente, define dos cosas: un método de instancia `#{scope_name}?` que verifica si el rol actual pertenece al alcance y un alcance de clase `#{scope_name.pluralize}` que filtra los registros según los valores del alcance.",
    "summary_portuguese": "The function `scope` defines a scope for a record class based on a given enum and scope name. It takes two arguments: `scope_name` (String) and `scope_enum_keys` (Array of Symbols). \n\nThe function first retrieves the target enum and extracts the values corresponding to the provided `scope_enum_keys`. It then checks for potential conflicts with existing scopes, class methods, or instance methods. If no conflicts are found, it creates a new scope by slicing the target enum based on the provided keys and stores it in the `defined_enum_scopes` hash. \n\nFinally, it defines two things: an instance method `scope_name?` that checks if the current instance's role belongs to the defined scope, and a class scope with the name `scope_name.pluralize` that filters records based on the values in the defined scope.",
    "summary_arabic": "The function `scope` defines a new scope for an enum within a record class. It takes two arguments: `scope_name` (a string representing the scope name) and `scope_enum_keys` (an array of strings representing the enum keys to include in the scope). \n\nThe function first checks for potential conflicts with existing scopes, class methods, or instance methods. Then, it extracts the specified enum values and stores them in the `defined_enum_scopes` hash. \n\nFinally, it defines two things: an instance method `scope_name?` that checks if the current instance's role belongs to the scope, and a class scope with the name `scope_name.pluralize` that filters records based on the scope's enum values.",
    "summary_hindi": "'scope' फ़ंक्शन एक एनम में एक उप-एन्‍यम स्‍कोप परिभाषित करता है। यह 'scope_name' (स्‍कोप का नाम) और 'scope_enum_keys' (उप-एन्‍यम के लिए एनम मानों की एक सूची) नामक दो एर्ग्यूमेंट्स लेता है। यह पहले से परिभाषित स्‍कोप नामों, अज्ञात एनम मानों और संभावित रूप से संघर्ष वाले वर्ग विधियों के लिए जांच करता है। यदि कोई संघर्ष नहीं है, तो यह एक नया उप-एन्‍यम बनाता है, एक इंस्टेंस विधि जो स्‍कोप की जांच करती है और एक वर्ग स्‍कोप जो उप-एन्‍यम के मानों के साथ क्वेरी करता है।"
  },
  {
    "id": "sample_69944",
    "language": "ruby",
    "length_bucket": "long",
    "code": "def copy(source, destination, options = {})\n      command = \"copy `#{source}' to `#{destination}'\"\n      build_commands << BuildCommand.new(command) do\n        Dir.chdir(software.project_dir) do\n          files = FileSyncer.glob(source)\n          if files.empty?\n            log.warn(log_key) { \"no matched files for glob #{command}\" }\n          else\n            files.each do |file|\n              FileUtils.cp_r(file, destination, options)\n            end\n          end\n        end\n      end\n    end",
    "docstring": "Copy the given source to the destination. This method accepts a single\n file or a file pattern to match.\n\n @param [String] source\n   the path on disk to copy from\n @param [String] destination\n   the path on disk to copy to\n @param (see #mkdir)\n\n @return (see #command)",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function 'copy' copies files from a source to a destination. It takes three arguments: 'source' (a string), 'destination' (a string), and 'options' (a hash). The function constructs a command string using the source and destination paths and adds it to a list of build commands. It then changes the directory to the project directory and uses FileSyncer.glob to find matching files in the source path. If files are found, it iterates through them and copies each file to the destination using FileUtils.cp_r with the provided options. If no files are found, a warning is logged.",
    "summary_chinese": "copy 函数用于复制文件或目录。它接受三个参数：source（源路径）、destination（目标路径）和 options（可选参数）。 \n\n该函数首先构建一个复制命令字符串，然后将其添加到 build_commands 列表中。 \n\n在执行复制命令之前，函数会更改工作目录到软件项目目录，并使用 FileSyncer.glob 方法获取匹配源路径的文件列表。 \n\n如果匹配的文件为空，则会记录警告日志。 \n\n否则，函数会遍历匹配的文件列表，并使用 FileUtils.cp_r 方法将每个文件复制到目标路径。",
    "summary_french": "La fonction `copy` copie des fichiers d'un répertoire source vers un répertoire destination. Elle prend trois arguments : `source` (une chaîne de caractères représentant le chemin du répertoire source), `destination` (une chaîne de caractères représentant le chemin du répertoire destination) et `options` (un dictionnaire optionnel contenant des paramètres supplémentaires pour la copie). La fonction construit une commande `copy` à partir des chemins source et destination, puis exécute cette commande dans le répertoire du projet. Elle utilise la méthode `glob` pour trouver les fichiers correspondant au chemin source. Si aucun fichier n'est trouvé, un message d'avertissement est affiché. Sinon, chaque fichier trouvé est copié vers le répertoire destination en utilisant la méthode `cp_r` de la classe `FileUtils`.",
    "summary_spanish": "La función `copy` copia archivos de una ubicación de origen a una ubicación de destino. Recibe tres argumentos: `source` (cadena, ruta de origen), `destination` (cadena, ruta de destino) y `options` (diccionario, opciones de copia).  La función construye un comando `copy` utilizando las rutas de origen y destino y lo agrega a una lista de comandos de construcción. Luego, cambia el directorio actual al directorio del proyecto y utiliza `FileSyncer.glob` para obtener una lista de archivos que coinciden con la ruta de origen. Si no se encuentran archivos coincidentes, se registra una advertencia. De lo contrario, se copia cada archivo encontrado a la ruta de destino utilizando `FileUtils.cp_r` con las opciones proporcionadas.",
    "summary_portuguese": "A função `copy` copia arquivos de um diretório para outro. Ela recebe três argumentos: `source` (string), que é o caminho para os arquivos de origem; `destination` (string), que é o caminho para o diretório de destino; e `options` (hash), que contém opções adicionais para a cópia. A função constrói um comando `copy` usando os valores de `source` e `destination` e o adiciona a uma lista de comandos de construção. Em seguida, ela muda o diretório para o diretório do projeto e usa `FileSyncer.glob` para encontrar os arquivos correspondentes ao padrão de glob especificado em `source`. Se nenhum arquivo for encontrado, um aviso é registrado no log. Caso contrário, cada arquivo encontrado é copiado para o diretório de destino usando `FileUtils.cp_r`, com as opções especificadas em `options`.",
    "summary_arabic": "function copy  \n\nتُستخدم هذه الدالة لنسخ ملفات أو مجلدات من مصدر إلى وجهة. \n\narguments:\nsource: سلسلة نصية تمثل المسار المصدر.\ndestination: سلسلة نصية تمثل المسار الوجهة.\noptions: قاموس (اختياري) يحتوي على خيارات إضافية لنسخ الملفات.\n\nlogic:\n1. تقوم الدالة ببناء أمر نسخ باستخدام المسارين المصدر والوجهة.\n2. تقوم بتنفيذ الأمر في مجلد المشروع باستخدام `Dir.chdir`.\n3. تقوم بفحص المسار المصدر باستخدام `FileSyncer.glob` لمعرفة الملفات المنسخة.\n4. إذا تم العثور على ملفات، يتم نسخها إلى الوجهة باستخدام `FileUtils.cp_r`.\n5. إذا لم يتم العثور على ملفات، يتم إصدار تحذير.",
    "summary_hindi": "इस फ़ंक्शन का नाम `copy` है। यह फ़ंक्शन एक स्रोत निर्देशिका से एक गंतव्य निर्देशिका में फ़ाइलों की कॉपी करता है। यह `source` (स्ट्रिंग), `destination` (स्ट्रिंग) और `options` (डिक्शनरी) नामक तीन मान्यताओं को लेता है। \n\nयह फ़ंक्शन पहले `source` निर्देशिका में मौजूद सभी फ़ाइलों को `FileSyncer.glob` का उपयोग करके ढूंढता है। यदि कोई फ़ाइल नहीं मिलती है तो यह एक चेतावनी लॉग करता है। यदि फ़ाइलें मिलती हैं, तो यह `FileUtils.cp_r` का उपयोग करके प्रत्येक फ़ाइल को `destination` निर्देशिका में कॉपी करता है।"
  },
  {
    "id": "sample_70034",
    "language": "ruby",
    "length_bucket": "long",
    "code": "def create_rpm_file\n      command =  %{rpmbuild}\n      command << %{ --target #{safe_architecture}}\n      command << %{ -bb}\n      command << %{ --buildroot #{staging_dir}/BUILD}\n      command << %{ --define '_topdir #{staging_dir}'}\n\n      if signing_passphrase\n        log.info(log_key) { \"Signing enabled for .rpm file\" }\n\n        if File.exist?(\"#{ENV['HOME']}/.rpmmacros\")\n          log.info(log_key) { \"Detected .rpmmacros file at `#{ENV['HOME']}'\" }\n          home = ENV[\"HOME\"]\n        else\n          log.info(log_key) { \"Using default .rpmmacros file from Omnibus\" }\n\n          # Generate a temporary home directory\n          home = Dir.mktmpdir\n\n          render_template(resource_path(\"rpmmacros.erb\"),\n            destination: \"#{home}/.rpmmacros\",\n            variables: {\n              gpg_name: project.maintainer,\n              gpg_path: \"#{ENV['HOME']}/.gnupg\", # TODO: Make this configurable\n            }\n          )\n        end\n\n        command << \" --sign\"\n        command << \" #{spec_file}\"\n\n        with_rpm_signing do |signing_script|\n          log.info(log_key) { \"Creating .rpm file\" }\n          shellout!(\"#{signing_script} \\\"#{command}\\\"\", environment: { \"HOME\" => home })\n        end\n      else\n        log.info(log_key) { \"Creating .rpm file\" }\n        command << \" #{spec_file}\"\n        shellout!(\"#{command}\")\n      end\n\n      FileSyncer.glob(\"#{staging_dir}/RPMS/**/*.rpm\").each do |rpm|\n        copy_file(rpm, Config.package_dir)\n      end\n    end",
    "docstring": "Generate the RPM file using +rpmbuild+. Unlike debian,the +fakeroot+\n command is not required for the package to be owned by +root:root+. The\n rpmuser specified in the spec file dictates this.\n\n @return [void]",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `create_rpm_file` builds a RPM package from a spec file. It takes arguments like `spec_file`, `staging_dir`, and `signing_passphrase`. \n\nThe function constructs an RPM build command using `rpmbuild` and various options. If `signing_passphrase` is provided, it signs the RPM package using GPG. It either uses a user's existing `.rpmmacros` file or generates a temporary one with the necessary signing information. The RPM is built using the constructed command and copied to the specified `Config.package_dir`. If `signing_passphrase` is not provided, the RPM is built without signing.",
    "summary_chinese": "create_rpm_file 函数用于创建 RPM 包文件。\n\n参数：\n\n* signing_passphrase: 是否启用签名\n\n逻辑：\n\n1. 根据 signing_passphrase 的值，决定是否启用 RPM 文件签名。\n2. 如果启用签名，则根据是否存在 ~/.rpmmacros 文件，决定使用默认的 .rpmmacros 文件还是生成一个临时文件。\n3. 构建 RPM 命令，并根据签名状态添加相应的参数。\n4. 使用 shellout! 命令执行 RPM 构建命令。\n5. 将生成的 RPM 文件复制到 Config.package_dir 目录。",
    "summary_french": "La fonction `create_rpm_file` crée un fichier RPM. Elle prend en argument `spec_file` (le chemin vers le fichier de spécification RPM) et `signing_passphrase` (le mot de passe de signature). Si `signing_passphrase` est défini, la fonction signe le fichier RPM. Elle utilise le fichier `.rpmmacros` pour les informations de signature. Si aucun fichier `.rpmmacros` n'est trouvé dans le répertoire utilisateur, une copie temporaire est générée. La fonction utilise ensuite `rpmbuild` pour construire le fichier RPM et le copie dans le répertoire spécifié par `Config.package_dir`.",
    "summary_spanish": "La función `create_rpm_file` crea un archivo RPM. Toma como argumentos `spec_file` (el archivo de especificaciones del paquete RPM), `signing_passphrase` (la contraseña para firmar el paquete) y `staging_dir` (la ubicación temporal para construir el paquete). Si `signing_passphrase` está definido, la función busca un archivo `.rpmmacros` para configurar la firma del paquete. Si no se encuentra, genera uno temporal. Luego, utiliza el comando `rpmbuild` para construir el paquete RPM y firmarlo. Finalmente, copia el archivo RPM generado a la ubicación especificada en `Config.package_dir`. Si `signing_passphrase` no está definido, la función construye el paquete RPM sin firmar.",
    "summary_portuguese": "The function `create_rpm_file` builds a RPM package file. It takes arguments like `spec_file` (path to the spec file), `staging_dir` (directory for building), and `signing_passphrase` (for signing the RPM). \n\nIf `signing_passphrase` is provided, it sets up RPM signing using either a user's `.rpmmacros` file or a temporary one generated from a template. The RPM is then built and signed using the `rpmbuild` command. \n\nOtherwise, the RPM is built without signing. Finally, all generated RPM files from the `staging_dir` are copied to the `Config.package_dir`.",
    "summary_arabic": "The function `create_rpm_file` builds a RPM package file. It takes `spec_file` as an argument, which is the path to the spec file for the RPM package. The function constructs an RPM build command using `rpmbuild` and other options. If `signing_passphrase` is provided, it signs the RPM package using GPG. Otherwise, it builds the RPM package without signing. Finally, it copies the generated RPM file to the specified directory.",
    "summary_hindi": "create_rpm_file फ़ंक्शन RPM फ़ाइल बनाता है। यह  `spec_file` (प्रोजेक्ट के लिए RPM स्पेसिफिकेशन फ़ाइल), `staging_dir` (RPM निर्माण के लिए अस्थायी निर्देशिका), और `signing_passphrase` (RPM फ़ाइल को साइन करने के लिए पासफ़्रेज़)  आदि  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित  परिभाषित"
  },
  {
    "id": "sample_70315",
    "language": "ruby",
    "length_bucket": "long",
    "code": "def unstack(value, num: nil, axis: 0, name: \"unstack\")\n      res = _op(:unstack, value, num: num, axis: axis, name: name)\n\n      num_vars = if value.shape.known?\n        new_shape = value.shape.shape.dup\n        rank = new_shape.size - 1\n        axis = rank + axis if axis < 0\n        rotated_shape = Array.new(axis + 1) { new_shape.shift }\n        new_shape = rotated_shape.rotate!(-1) + new_shape\n        new_shape[0]\n      else\n        raise TensorStream::ValueError, \"num is unspecified and cannot be inferred.\" if num.nil?\n\n        num\n      end\n\n      return res[0] if num_vars == 1\n\n      Array.new(num_vars) do |i|\n        index(res, i, name: \"unstack/index:#{i}\")\n      end\n    end",
    "docstring": "Unpacks the given dimension of a rank-R tensor into rank-(R-1) tensors.",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `unstack` unpacks a tensor along a specified axis. It takes `value` (a tensor), `num` (the number of splits along the axis, optional), `axis` (the axis to split along, default 0), and `name` (a name for the operation, default \"unstack\") as arguments. \n\nIf `num` is specified, it determines the number of splits. If `num` is not specified and the shape of `value` is known, it infers the number of splits based on the shape. Otherwise, it raises an error if `num` is not provided.\n\nThe function then performs the unstack operation using `_op(:unstack, value, num: num, axis: axis, name: name)`. \n\nIf the result has one variable, it returns the first element of the result. Otherwise, it creates an array of `num_vars` elements, each representing a split tensor, by indexing into the result array.",
    "summary_chinese": "unstack 函数用于将张量沿着指定轴拆分成多个张量。它接受 value（输入张量）、num（拆分后的张量数量，可选）、axis（拆分轴，默认是0）和 name（操作名称，默认是“unstack”）四个参数。 \n\n如果 num 未指定且无法推断，则会抛出 TensorStream::ValueError 异常。\n\n函数首先使用 _op(:unstack, value, num: num, axis: axis, name: name) 调用 unstack 操作，然后根据输入张量的形状和 num 的值计算拆分后的张量数量 num_vars。\n\n如果 num_vars 等于 1，则返回拆分后的第一个张量；否则，会创建一个包含 num_vars 个元素的数组，每个元素都是使用 index 函数从拆分结果中提取的对应张量。",
    "summary_french": "La fonction `unstack` décompose un tensor le long d'un axe spécifié. Elle prend en argument `value` (le tensor à décomposer), `num` (le nombre de dimensions à créer), `axis` (l'axe de décomposition) et `name` (un nom pour l'opération). La fonction détermine le nombre de variables (`num_vars`) à partir de la forme du tensor. Si `num_vars` est égal à 1, elle retourne le premier élément du résultat. Sinon, elle crée un tableau contenant `num_vars` éléments, chaque élément étant le résultat de l'indexation du tensor sur l'axe spécifié.",
    "summary_spanish": "La función unstack toma un valor, un número, un eje y un nombre como argumentos. Su propósito es desapilar el valor a lo largo del eje especificado. El número de variables se calcula a partir de la forma del valor. Si el número de variables es 1, se devuelve el primer elemento del resultado. De lo contrario, se crea un array con el número de variables, donde cada elemento es el índice del resultado correspondiente.",
    "summary_portuguese": "A função `unstack` desestrutura um tensor ao longo de um eixo especificado. Ela recebe como argumentos `value` (o tensor a ser desestruturado), `num` (o número de dimensões a serem criadas), `axis` (o eixo ao longo do qual desestruturar) e `name` (um nome para a operação). A lógica da função primeiro obtém o número de variáveis a partir da forma do tensor. Se o número de variáveis for 1, retorna o primeiro elemento do resultado da operação `unstack`. Caso contrário, cria um array com o número de variáveis e, para cada variável, extrai o índice correspondente do resultado da operação `unstack`.",
    "summary_arabic": "The function unstack aims to split a tensor along a specified axis. It takes four arguments: value (the input tensor), num (the number of splits along the axis, optional), axis (the axis to split along, defaulting to 0), and name (a name for the operation, defaulting to \"unstack\"). \n\nIf the shape of the input tensor is known, the function calculates the new shape after splitting and returns the split tensors as an array. If the shape is unknown and num is not provided, it raises an error. Otherwise, it uses the provided num value.",
    "summary_hindi": "unstack नामक फ़ंक्शन एक Tensor को उसके दिए गए अक्ष के साथ विभाजित करता है। यह फ़ंक्शन value (Tensor), num (विभाजन की संख्या), axis (विभाजन करने वाला अक्ष), और name (परिणाम के नाम) नामक चार मानों को लेता है। \n\nयदि Tensor का आकार ज्ञात है, तो यह Tensor के आकार को बदलकर विभाजन करता है। अन्यथा, यह num मान का उपयोग विभाजन के लिए करता है। अंत में, यह विभाजित Tensor के सभी भागों को एक एरे में लौटाता है।"
  },
  {
    "id": "sample_71335",
    "language": "ruby",
    "length_bucket": "long",
    "code": "def jqgrid_properties\n      vals = {}\n      vals[:ajaxGridOptions] = ajax_grid_options if ajax_grid_options\n\n      # data and request options\n      vals[:url] = url if url\n      vals[:editurl] = url if editable\n      vals[:restful] = true if restful\n      vals[:inline_edit] = inline_edit if inline_edit.present?\n      vals[:postData] = {:grid => name, :datatype => data_type} #identify which grid making the request\n      vals[:colNames] = colNames if colNames.present?\n      vals[:colModel] = column_model if colModel.present?\n      vals[:datatype] = data_type if data_type\n      if data_format.present?\n        case data_type\n          when :xml\n            vals[:xmlReader] = data_format\n          when :json\n            vals[:jsonReader] = data_format\n        end\n      end\n\n      vals[:loadonce] = load_once if load_once\n\n      vals[:sortname] = sort_by if sort_by\n      vals[:sortorder] = sort_order if sort_order && sort_by\n      vals[:rowNum] = rows_per_page if rows_per_page\n      vals[:rowTotal] = total_rows if total_rows\n      vals[:page] = current_page if current_page\n\n      # grid options\n      vals[:height] = height if height\n      vals[:gridview] = grid_view # faster views, NOTE theres cases when this needs to be disabled\n\n      case width_fit\n        when :fitted\n          #vals[:autowidth]    = false #default\n          #vals[:shrinkToFit]  = true #default\n          vals[:forceFit] = true\n          vals[:width] = width if width\n\n        when :scroll\n          #vals[:autowidth]    = false #default\n          vals[:shrinkToFit] = false\n          #vals[:forceFit]     = #ignored by jqGrid\n          vals[:width] = width if width\n\n        else #when :fluid\n          vals[:autowidth] = true\n          #vals[:shrinkToFit]  = true #default\n          vals[:forceFit] = true\n          #vals[:width]        = is ignored\n          vals[:resizeStop] = 'javascript: gridify_fluid_recalc_width'\n      end\n\n      vals[:sortable] = true if arranger_type.include?(:sortable)\n\n      # header layer\n      vals[:caption] = title if title\n      vals[:hidegrid] = false unless collapsible\n      vals[:hiddengrid] = true if collapsed\n\n      # row formatting\n      vals[:altrows] = true if alt_rows\n      vals[:altclass] = alt_rows if alt_rows.is_a?(String)\n\n      vals[:rownumbers] = true if row_numbers\n      vals[:rownumWidth] = row_numbers if row_numbers.is_a?(Numeric)\n\n      if inline_edit\n        vals[:scrollrows] = true\n        vals[:multiselect] = true if multi_select\n        vals[:onSelectRow] = \"javascript: function(id, status) { if(id && id!==lastsel_#{dom_id}) { jQuery('##{dom_id}').jqGrid('restoreRow', lastsel_#{dom_id}); jQuery('##{dom_id}').jqGrid('editRow', id, true, #{inline_edit_handler}, #{error_handler}); lastsel_#{dom_id}=id}}\"\n      elsif select_rows #.present?\n        vals[:scrollrows] = true\n        vals[:onSelectRow] = select_rows\n        vals[:multiselect] = true if multi_select\n      else\n        vals[:hoverrows] = false\n        vals[:beforeSelectRow] = \"javascript: function(){ false; }\"\n      end\n\n      # pager layer\n      if pager\n        vals[:pager] = \"##{pager}\"\n        vals[:viewrecords] = true # display total records in the query (eg \"1 - 10 of 25\")\n        vals[:rowList] = paging_choices\n        if paging_controls.is_a?(Hash)\n          # allow override of jqGrid pager options\n          vals.merge!(paging_controls)\n        elsif !paging_controls\n          vals[:rowList] = []\n          vals[:pgbuttons] = false\n          vals[:pginput] = false\n          vals[:recordtext] = \"{2} records\"\n        end\n      end\n\n      if tree_grid\n        vals[:treeGrid] = tree_grid\n        vals[:gridview] = true\n        vals[:sortable] = false\n      end\n\n      #subgrid\n      if sub_grid\n        vals[:subGrid] = sub_grid\n        vals[:subGridUrl] = sub_grid_url\n        vals[:subGridModel] = sub_grid_model\n        vals[:gridview] = true\n      end\n\n      #events\n      #vals[:serializeGridData] = serialize_grid_data if serialize_grid_data\n\n      vals[:loadonce] = load_once if load_once\n\n      # allow override of native jqGrid options\n      vals.merge(jqgrid_options)\n\n\n    end",
    "docstring": "generate the jqGrid initial values in json\n   maps our attributes to jqGrid options; omit values when same as jqGrid defaults",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `jqgrid_properties` generates a hash of options for initializing a jqGrid widget. \n\nIt accepts arguments such as `url`, `editable`, `restful`, `inline_edit`, `colNames`, `colModel`, `data_type`, `data_format`, `load_once`, `sort_by`, `sort_order`, `rows_per_page`, `total_rows`, `current_page`, `height`, `grid_view`, `width_fit`, `width`, `arranger_type`, `title`, `collapsible`, `alt_rows`, `row_numbers`, `inline_edit`, `select_rows`, `multi_select`, `pager`, `paging_choices`, `paging_controls`, `tree_grid`, `sub_grid`, `sub_grid_url`, `sub_grid_model`, and `jqgrid_options`.\n\nThe function constructs the options hash by setting values based on the provided arguments. It handles different data formats, grid layouts, sorting, pagination, and other features. It also allows overriding default jqGrid options.",
    "summary_chinese": "jqgrid_properties 函数用于生成 jqGrid 的属性。\n\n参数：ajax_grid_options, url, editable, restful, inline_edit, name, data_type, data_format, load_once, sort_by, sort_order, rows_per_page, total_rows, current_page, height, grid_view, width_fit, width, arranger_type, title, collapsible, collapsed, alt_rows, row_numbers, inline_edit, select_rows, multi_select, pager, paging_choices, paging_controls, tree_grid, sub_grid, sub_grid_url, sub_grid_model, jqgrid_options\n\n逻辑：\n\n函数首先创建一个空字典 vals，然后根据传入的参数设置字典中的值。\n\n字典中包含了 jqGrid 的各种属性，例如数据源、排序、分页、列定义、行格式等。\n\n函数会根据不同的参数值设置不同的属性值。例如，如果 `inline_edit` 为真，则会设置 `scrollrows` 和 `multiselect` 属性。\n\n最后，函数会将 `vals` 字典返回，该字典包含了所有设置好的 jqGrid 属性。",
    "summary_french": "The function `jqgrid_properties` generates a hash of options for initializing a jqGrid. It takes various parameters like `url`, `editable`, `restful`, `inline_edit`, `colNames`, `colModel`, `data_type`, `data_format`, `load_once`, `sort_by`, `sort_order`, `rows_per_page`, `total_rows`, `current_page`, `height`, `grid_view`, `width_fit`, `width`, `arranger_type`, `title`, `collapsible`, `alt_rows`, `row_numbers`, `inline_edit`, `select_rows`, `multi_select`, `pager`, `paging_choices`, `paging_controls`, `tree_grid`, `sub_grid`, `sub_grid_url`, `sub_grid_model` and `jqgrid_options`. \n\nThe function sets default values for these options and merges them with any provided values. It also handles specific logic based on the values of certain parameters, such as setting `xmlReader` and `jsonReader` based on `data_type` and `data_format`. \n\n\nThe function returns a hash containing all the jqGrid options.",
    "summary_spanish": "The function `jqgrid_properties` generates a hash of options for initializing a jqGrid. It takes various parameters like `url`, `editable`, `restful`, `inline_edit`, `colNames`, `colModel`, `data_type`, `data_format`, `load_once`, `sort_by`, `sort_order`, `rows_per_page`, `total_rows`, `current_page`, `height`, `grid_view`, `width_fit`, `width`, `arranger_type`, `title`, `collapsible`, `alt_rows`, `row_numbers`, `inline_edit`, `select_rows`, `multi_select`, `pager`, `paging_choices`, `paging_controls`, `tree_grid`, `sub_grid`, `sub_grid_url`, `sub_grid_model`, and `jqgrid_options`. \n\nThe function sets default values for these options based on the provided parameters. It also handles specific logic for formatting data, configuring pagination, and enabling features like inline editing, tree grids, and subgrids. Finally, it merges any additional `jqgrid_options` provided as an argument into the generated hash.",
    "summary_portuguese": "The function `jqgrid_properties` generates a hash of options for initializing a jqGrid. It takes various parameters like `url`, `editable`, `restful`, `inline_edit`, `colNames`, `colModel`, `data_type`, `data_format`, `load_once`, `sort_by`, `sort_order`, `rows_per_page`, `total_rows`, `current_page`, `height`, `grid_view`, `width_fit`, `width`, `arranger_type`, `title`, `collapsible`, `alt_rows`, `row_numbers`, `inline_edit`, `select_rows`, `multi_select`, `pager`, `paging_choices`, `paging_controls`, `tree_grid`, `sub_grid`, `sub_grid_url`, `sub_grid_model`, and `jqgrid_options`. \n\nThe function constructs the `vals` hash by setting values for these parameters based on the provided arguments. It handles different data formats, grid layouts, sorting options, pagination settings, and other jqGrid features. \n\nFinally, it merges any additional `jqgrid_options` passed as an argument into the `vals` hash.",
    "summary_arabic": "The function `jqgrid_properties` generates a hash of options for initializing a jqGrid widget. \n\nIt accepts various arguments including `url`, `editable`, `restful`, `inline_edit`, `colNames`, `colModel`, `data_type`, `data_format`, `load_once`, `sort_by`, `sort_order`, `rows_per_page`, `total_rows`, `current_page`, `height`, `grid_view`, `width_fit`, `width`, `arranger_type`, `title`, `collapsible`, `alt_rows`, `row_numbers`, `inline_edit`, `select_rows`, `multi_select`, `pager`, `paging_choices`, `paging_controls`, `tree_grid`, `sub_grid`, `sub_grid_url`, `sub_grid_model`, and `jqgrid_options`.\n\nThe function constructs the options hash by setting values based on the provided arguments. It handles different data formats, grid layouts, pagination options, sorting, and other jqGrid features. It also allows overriding default options with user-provided values.",
    "summary_hindi": "jqgrid_properties फ़ंक्शन एक हैरिस जक्विड ग्रिड के लिए आवश्यक गुणों को एक हैश में संग्रहीत करता है। यह फ़ंक्शन कई आर्गुमेंट्स लेता है जैसे url, editable, restful, inline_edit, colNames, colModel, data_type, data_format, load_once, sort_by, sort_order, rows_per_page, total_rows, current_page, height, grid_view, width_fit, title, collapsible, alt_rows, row_numbers, inline_edit, select_rows, pager, tree_grid, sub_grid, और jqgrid_options। \n\nयह फ़ंक्शन इन आर्गुमेंट्स के आधार पर हैश में विभिन्न गुणों को सेट करता है, जैसे ग्रिड के URL, डेटा प्रकार, सॉर्टिंग, पेजिंग, विजुअल स्टाइल और अन्य। यह जक्विड ग्रिड के लिए आवश्यक सभी सेटिंग्स को एकत्रित करता है और उन्हें एक ही स्थान पर संग्रहीत करता है।"
  },
  {
    "id": "sample_71020",
    "language": "ruby",
    "length_bucket": "long",
    "code": "def upload_module_changes(parent_sha1, sha1s)\n    remote_path = fetch_module\n    # search for the first revision that is not \n    tmp_git_path = clone_or_fetch_repository(remote_path, module_tmp_git_path(@remote_path))\n    RIM::git_session(tmp_git_path) do |dest|\n      local_branch = nil\n      remote_branch = nil\n      infos = nil\n      if @module_info.subdir\n        dest_path = File.join([tmp_git_path] + @module_info.subdir.split(\"/\"))\n      else\n        dest_path = tmp_git_path\n      end\n      RIM::git_session(@ws_root) do |src|\n        infos = get_branches_and_revision_infos(src, dest, parent_sha1, sha1s)\n        if infos.branches.size == 1\n          remote_branch = infos.branches[0]\n          if dest.has_remote_branch?(remote_branch)\n            infos.rev_infos.each do |rev_info|\n              local_branch = create_update_branch(dest, infos.parent_sha1, rev_info.src_sha1) if !local_branch\n              copy_revision_files(\n                src,\n                rev_info.src_sha1,\n                dest_path,\n                rev_info.rim_info.ignores\n              )\n              commit_changes(dest, local_branch, rev_info.src_sha1, rev_info.message)\n            end\n          else\n            raise RimException.new(\"The target revision '#{@module_info.target_revision}' of module #{@module_info.local_path} is not a branch. No push can be performed.\")\n          end\n        elsif infos.branches.size > 1\n          raise RimException.new(\"There are commits for module #{@module_info.local_path} on multiple target revisions (#{infos.branches.join(\", \")}).\")\n        end\n      end\n      # Finally we're done. Push the changes\n      if local_branch && dest.rev_sha1(local_branch) != infos.parent_sha1  \n        push_branch = @review && @module_info.remote_branch_format && !@module_info.remote_branch_format.empty? \\\n            ? @module_info.remote_branch_format % remote_branch : remote_branch\n        dest.execute(\"git push #{@remote_url} #{local_branch}:#{push_branch}\")\n        dest.execute(\"git checkout --detach #{local_branch}\")\n        dest.execute(\"git branch -D #{local_branch}\")\n        @logger.info(\"Commited changes for module #{@module_info.local_path} to remote branch #{push_branch}.\")\n      else\n        @logger.info(\"No changes to module #{@module_info.local_path}.\")\n      end                              \n    end\n  end",
    "docstring": "upload the content of the module",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `upload_module_changes` uploads changes to a remote Git repository for a given module. It takes two arguments: `parent_sha1` (a string representing the parent SHA1 hash) and `sha1s` (a list of strings representing SHA1 hashes of changes). \n\nThe function first clones or fetches the remote repository and then iterates through the provided SHA1 hashes. For each SHA1, it retrieves the corresponding revision information from the local repository and compares it to the remote repository. If a matching branch exists, it creates a local branch, copies the revision files, commits the changes, and pushes the branch to the remote repository. If no matching branch exists or there are multiple matching branches, an exception is raised.",
    "summary_chinese": "upload_module_changes 函数用于将模块的更改上传到远程仓库。\n\n参数：\n\nparent_sha1: String, 父 SHA1 值\nsha1s: List[String], SHA1 值列表\n\n逻辑：\n\n1. 从远程仓库获取模块路径。\n2. 克隆或获取模块的本地仓库。\n3. 获取本地和远程分支信息以及相关提交信息。\n4. 如果找到唯一的远程分支，则创建本地分支，复制提交文件，提交更改并推送到远程分支。\n5. 如果找到多个远程分支，则抛出异常。\n6. 如果没有更改，则输出信息。",
    "summary_french": "La fonction `upload_module_changes` permet de mettre à jour les modifications d'un module sur un dépôt distant. Elle prend en argument `parent_sha1` (une chaîne de caractères représentant le hash de la dernière revision parent) et `sha1s` (une liste de chaînes de caractères représentant les hashes des revisions à mettre à jour). La fonction clone ou récupère le dépôt distant, identifie les branches et les revisions correspondantes, copie les fichiers des revisions locales vers le dépôt distant, crée un commit et enfin pousse les modifications vers la branche distante.",
    "summary_spanish": "La función `upload_module_changes` se encarga de subir los cambios realizados a un módulo a un repositorio remoto. \n\nRecibe dos argumentos: `parent_sha1` (string) que representa el hash de la revisión padre y `sha1s` (lista de strings) que contiene los hashes de las revisiones a subir.\n\nLa función primero clona o recupera el repositorio remoto del módulo. Luego, utiliza la información de las revisiones proporcionadas para determinar la rama remota correspondiente y crea una rama local para realizar los cambios. Copia los archivos de las revisiones locales a la rama local, realiza un commit con los cambios y finalmente, si hay cambios, los sube al repositorio remoto.",
    "summary_portuguese": "The function `upload_module_changes` is responsible for uploading changes to a module's repository. It takes two arguments: `parent_sha1` (a string representing the parent SHA1 hash) and `sha1s` (a list of strings representing SHA1 hashes). \n\nThe function first clones or fetches the module's repository. Then, it identifies the relevant branches and revisions based on the provided `parent_sha1` and `sha1s`. It copies the necessary files from the local repository to the remote repository, commits the changes, and finally pushes the changes to the remote branch.",
    "summary_arabic": "The function `upload_module_changes` is responsible for uploading changes to a module's repository. It takes two arguments: `parent_sha1` (a string representing the parent revision's SHA1 hash) and `sha1s` (a list of strings representing the SHA1 hashes of the changes to be uploaded). \n\nThe function first clones or fetches the module's repository. Then, it identifies the relevant branches and revisions based on the provided `parent_sha1` and `sha1s`. It copies the necessary files from the local repository to the remote repository, commits the changes, and finally pushes the changes to the remote branch.",
    "summary_hindi": "upload_module_changes फ़ंक्शन मॉड्यूल के बदलावों को रिमोट रिपॉजिटरी में अपलोड करता है। यह फ़ंक्शन `parent_sha1` और `sha1s` नामक दो मान्यताओं को लेता है।  \n\nयह फ़ंक्शन पहले मॉड्यूल के रिमोट रिपॉजिटरी को क्लोन या फ़ेच करता है। फिर, यह स्रोत और गंतव्य रिपॉजिटरी में शाखाओं और रिवीजन जानकारी प्राप्त करता है। यदि केवल एक शाखा मिलती है, तो यह बदलावों को कॉपी करता है, उन्हें कमिट करता है और शाखा को रिमोट रिपॉजिटरी में पुश करता है। यदि कई शाखाएं मिलती हैं या लक्ष्य रिवीजन एक शाखा नहीं है, तो यह एक त्रुटि उत्पन्न करता है।"
  },
  {
    "id": "sample_70681",
    "language": "ruby",
    "length_bucket": "long",
    "code": "def connect\n      start_time = Time.now\n      retries    = 0\n      close\n\n      # Number of times to try\n      begin\n        connect_to_server(servers, policy)\n        logger.info(message: \"Connected to #{address}\", duration: (Time.now - start_time) * 1000) if respond_to?(:logger)\n      rescue ConnectionFailure, ConnectionTimeout => exception\n        cause = exception.is_a?(ConnectionTimeout) ? exception : exception.cause\n        # Retry-able?\n        if self.class.reconnect_on_errors.include?(cause.class) && (retries < connect_retry_count.to_i)\n          retries += 1\n          logger.warn \"#connect Failed to connect to any of #{servers.join(',')}. Sleeping:#{connect_retry_interval}s. Retry: #{retries}\" if respond_to?(:logger)\n          sleep(connect_retry_interval)\n          retry\n        else\n          message = \"#connect Failed to connect to any of #{servers.join(',')} after #{retries} retries. #{exception.class}: #{exception.message}\"\n          logger.benchmark_error(message, exception: exception, duration: (Time.now - start_time)) if respond_to?(:logger)\n          raise ConnectionFailure.new(message, address.to_s, cause)\n        end\n      end\n    end",
    "docstring": "Create a new TCP Client connection\n\n Parameters:\n   :server [String]\n     URL of the server to connect to with port number\n     'localhost:2000'\n     '192.168.1.10:80'\n\n   :servers [Array of String]\n     Array of URL's of servers to connect to with port numbers\n     ['server1:2000', 'server2:2000']\n\n     The second server will only be attempted once the first server\n     cannot be connected to or has timed out on connect\n     A read failure or timeout will not result in switching to the second\n     server, only a connection failure or during an automatic reconnect\n\n   :connect_timeout [Float]\n     Time in seconds to timeout when trying to connect to the server\n     A value of -1 will cause the connect wait time to be infinite\n     Default: 10 seconds\n\n   :read_timeout [Float]\n     Time in seconds to timeout on read\n     Can be overridden by supplying a timeout in the read call\n     Default: 60\n\n   :write_timeout [Float]\n     Time in seconds to timeout on write\n     Can be overridden by supplying a timeout in the write call\n     Default: 60\n\n   :buffered [true|false]\n     Whether to use Nagle's Buffering algorithm (http://en.wikipedia.org/wiki/Nagle's_algorithm)\n     Recommend disabling for RPC style invocations where we don't want to wait for an\n     ACK from the server before sending the last partial segment\n     Buffering is recommended in a browser or file transfer style environment\n     where multiple sends are expected during a single response.\n     Also sets sync to true if buffered is false so that all data is sent immediately without\n     internal buffering.\n     Default: true\n\n   :keepalive [true|false]\n     Makes the OS check connections even when not in use, so that failed connections fail immediately\n     upon use instead of possibly taking considerable time to fail.\n     Default: true\n\n   :connect_retry_count [Fixnum]\n     Number of times to retry connecting when a connection fails\n     Default: 10\n\n   :connect_retry_interval [Float]\n     Number of seconds between connection retry attempts after the first failed attempt\n     Default: 0.5\n\n   :retry_count [Fixnum]\n     Number of times to retry when calling #retry_on_connection_failure\n     This is independent of :connect_retry_count which still applies with\n     connection failures. This retry controls upto how many times to retry the\n     supplied block should a connection failure occur during the block\n     Default: 3\n\n   :on_connect [Proc]\n     Directly after a connection is established and before it is made available\n     for use this Block is invoked.\n     Typical Use Cases:\n     - Initialize per connection session sequence numbers.\n     - Pass authentication information to the server.\n     - Perform a handshake with the server.\n\n   :policy [Symbol|Proc]\n     Specify the policy to use when connecting to servers.\n       :ordered\n         Select a server in the order supplied in the array, with the first\n         having the highest priority. The second server will only be connected\n         to if the first server is unreachable\n       :random\n         Randomly select a server from the list every time a connection\n         is established, including during automatic connection recovery.\n       :ping_time\n         FUTURE - Not implemented yet - Pull request anyone?\n         The server with the lowest ping time will be tried first\n       Proc:\n         When a Proc is supplied, it will be called passing in the list\n         of servers. The Proc must return one server name\n           Example:\n             :policy => Proc.new do |servers|\n               servers.last\n             end\n       Default: :ordered\n\n   :close_on_error [True|False]\n     To prevent the connection from going into an inconsistent state\n     automatically close the connection if an error occurs\n     This includes a Read Timeout\n     Default: true\n\n   :proxy_server [String]\n     The host name and port in the form of 'host_name:1234' to forward\n     socket connections though.\n     Default: nil ( none )\n\n   SSL Options\n   :ssl [true|false|Hash]\n      true:  SSL is enabled using the SSL context defaults.\n      false: SSL is not used.\n      Hash:\n        Keys from OpenSSL::SSL::SSLContext:\n          ca_file, ca_path, cert, cert_store, ciphers, key, ssl_timeout, ssl_version\n          verify_callback, verify_depth, verify_mode\n        handshake_timeout: [Float]\n          The number of seconds to timeout the SSL Handshake.\n          Default: connect_timeout\n      Default: false.\n        See OpenSSL::SSL::SSLContext::DEFAULT_PARAMS for the defaults.\n\n Example:\n   client = Net::TCPClient.new(\n     server:                 'server:3300',\n     connect_retry_interval: 0.1,\n     connect_retry_count:    5\n   )\n\n   client.retry_on_connection_failure do\n     client.write('Update the database')\n   end\n\n   # Read upto 20 characters from the server\n   response = client.read(20)\n\n   puts \"Received: #{response}\"\n   client.close\n\n SSL Example:\n   client = Net::TCPClient.new(\n     server:                 'server:3300',\n     connect_retry_interval: 0.1,\n     connect_retry_count:    5,\n     ssl:                    true\n   )\n\n SSL with options Example:\n   client = Net::TCPClient.new(\n     server:                 'server:3300',\n     connect_retry_interval: 0.1,\n     connect_retry_count:    5,\n     ssl:                    {\n       verify_mode: OpenSSL::SSL::VERIFY_NONE\n     }\n   )\n Connect to the TCP server\n\n Raises Net::TCPClient::ConnectionTimeout when the time taken to create a connection\n        exceeds the :connect_timeout\n Raises Net::TCPClient::ConnectionFailure whenever Socket raises an error such as Error::EACCESS etc, see Socket#connect for more information\n\n Error handling is implemented as follows:\n 1. TCP Socket Connect failure:\n    Cannot reach server\n    Server is being restarted, or is not running\n    Retry 50 times every 100ms before raising a Net::TCPClient::ConnectionFailure\n    - Means all calls to #connect will take at least 5 seconds before failing if the server is not running\n    - Allows hot restart of server process if it restarts within 5 seconds\n\n 2. TCP Socket Connect timeout:\n    Timed out after 5 seconds trying to connect to the server\n    Usually means server is busy or the remote server disappeared off the network recently\n    No retry, just raise a Net::TCPClient::ConnectionTimeout\n\n Note: When multiple servers are supplied it will only try to connect to\n       the subsequent servers once the retry count has been exceeded\n\n Note: Calling #connect on an open connection will close the current connection\n       and create a new connection",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `connect` attempts to establish a connection to a server. It takes `servers` (an array of server addresses) and `policy` (a connection policy) as arguments. The function repeatedly tries to connect to a server, with a configurable number of retries and a sleep interval between attempts. If a connection is successful, it logs the connection time. If a connection error occurs, it checks if the error is retryable. If retryable, it increases the retry count, logs a warning message, and sleeps before retrying. If the error is not retryable, it logs an error message and raises a `ConnectionFailure` exception.",
    "summary_chinese": "connect 函数旨在连接到服务器。它接受 servers（服务器列表）和 policy（连接策略）两个参数。 \n\n函数首先记录开始时间，并设置重试次数为 0。它尝试连接到服务器列表中的每个服务器，如果连接成功，则记录连接时间并返回。如果连接失败，函数会检查错误类型，如果属于可重试的错误类型并且重试次数小于最大重试次数，则会记录警告信息，等待一段时间后重新尝试连接。否则，函数会记录错误信息并抛出 ConnectionFailure 异常。",
    "summary_french": "La fonction `connect` tente de se connecter à un serveur. Elle prend en arguments `servers` (une liste d'adresses de serveurs) et `policy` (une politique de connexion). La fonction essaie de se connecter au serveur en utilisant `connect_to_server`. Si la connexion échoue, elle essaie de se reconnecter jusqu'à un certain nombre de tentatives (`connect_retry_count`). Si toutes les tentatives échouent, elle lève une exception `ConnectionFailure`.",
    "summary_spanish": "La función `connect` intenta conectar a un servidor. Recibe como argumentos `servers` (un arreglo de servidores) y `policy` (una política de conexión).  \n\nEl código intenta conectar al servidor, registrando el tiempo de conexión. Si ocurre un error de conexión o tiempo de espera, se intenta conectar de nuevo hasta un número máximo de intentos. Si todos los intentos fallan, se lanza una excepción `ConnectionFailure`.",
    "summary_portuguese": "A função `connect` tenta conectar a um servidor. Ela recebe como argumentos `servers` (uma lista de servidores) e `policy` (uma política de conexão). A função tenta conectar-se aos servidores até que seja bem-sucedido ou o número máximo de tentativas for atingido. Se a conexão falhar, a função registra um aviso e espera um intervalo de tempo antes de tentar novamente. Se todas as tentativas falharem, a função lança uma exceção `ConnectionFailure`.",
    "summary_arabic": "function connect aims to establish a connection to a server. It takes two arguments: servers (an array of server addresses) and policy (a connection policy). The function repeatedly attempts to connect to a server from the provided list. If a connection is successful, it logs the connection time. If a connection error occurs, the function checks if the error is retryable. If it is, the function retries the connection after a specified interval. If the error is not retryable or the maximum number of retries is reached, the function raises a ConnectionFailure exception.",
    "summary_hindi": "इस फ़ंक्शन का नाम `connect` है। यह सर्वर से कनेक्ट करने का प्रयास करता है। यह `servers` (एक सरणी) और `policy` (एक ऑब्जेक्ट) नामक दो मान्यताओं को लेता है। यह सर्वर से कनेक्ट होने के लिए कई बार प्रयास करता है। यदि कनेक्शन सफल होता है तो यह कनेक्शन समय को लॉग करता है। यदि कनेक्शन विफल होता है तो यह एक लॉग रिकॉर्ड करता है और फिर से प्रयास करता है। यदि सभी प्रयास विफल हो जाते हैं तो यह एक `ConnectionFailure` त्रुटि उठाता है।"
  },
  {
    "id": "sample_70119",
    "language": "ruby",
    "length_bucket": "long",
    "code": "def apply_orphan_strategy\n      if !ancestry_callbacks_disabled? && !new_record?\n        case self.ancestry_base_class.orphan_strategy\n        when :rootify # make all children root if orphan strategy is rootify\n          unscoped_descendants.each do |descendant|\n            descendant.without_ancestry_callbacks do\n              new_ancestry = if descendant.ancestry == child_ancestry\n                nil\n              else\n                # child_ancestry did not change so child_ancestry_was will work here\n                descendant.ancestry.gsub(/^#{child_ancestry}\\//, '')\n              end\n              descendant.update_attribute descendant.class.ancestry_column, new_ancestry\n            end\n          end\n        when :destroy # destroy all descendants if orphan strategy is destroy\n          unscoped_descendants.each do |descendant|\n            descendant.without_ancestry_callbacks do\n              descendant.destroy\n            end\n          end\n        when :adopt # make child elements of this node, child of its parent\n          descendants.each do |descendant|\n            descendant.without_ancestry_callbacks do\n              new_ancestry = descendant.ancestor_ids.delete_if { |x| x == self.id }.join(\"/\")\n              # check for empty string if it's then set to nil\n              new_ancestry = nil if new_ancestry.empty?\n              descendant.update_attribute descendant.class.ancestry_column, new_ancestry || nil\n            end\n          end\n        when :restrict # throw an exception if it has children\n          raise Ancestry::AncestryException.new('Cannot delete record because it has descendants.') unless is_childless?\n        end\n      end\n    end",
    "docstring": "Apply orphan strategy (before destroy - no changes)",
    "model_name": "gemma-2-9b-it",
    "summary_english": "The function `apply_orphan_strategy` handles descendant records when the parent record is deleted. It checks if ancestry callbacks are disabled and if the record is not new. Based on the `orphan_strategy` defined in the parent's ancestry base class, it performs different actions:\n\n- `:rootify`: Sets the ancestry of all descendants to nil.\n- `:destroy`: Deletes all descendants.\n- `:adopt`: Moves descendants to be children of the parent's parent.\n- `:restrict`: Raises an exception if the parent has descendants. \n\nThe function iterates through descendants, updates their ancestry attributes, or deletes them accordingly.",
    "summary_chinese": "apply_orphan_strategy 函数用于处理父节点被删除时子节点的行为。 \n\n参数: 无\n\n逻辑: \n\n如果 ancestry_callbacks_disabled? 为 false 且不是新记录，则根据 self.ancestry_base_class.orphan_strategy 的值执行不同的操作。\n\n* 如果是 :rootify，则将所有子节点设置为根节点。\n* 如果是 :destroy，则删除所有子节点。\n* 如果是 :adopt，则将子节点设置为其父节点的子节点。\n* 如果是 :restrict，则如果子节点存在，则抛出异常。",
    "summary_french": "La fonction `apply_orphan_strategy` gère le comportement des descendants d'un enregistrement supprimé en fonction de la stratégie définie pour l'ancêtre. Elle prend en compte les paramètres `ancestry_callbacks_disabled?` et `new_record?`. Selon la stratégie `orphan_strategy` de la classe ancestrale, elle peut : \n\n* **rootify**:  rendre tous les descendants racines.\n* **destroy**: supprimer tous les descendants.\n* **adopt**: faire des descendants enfants du parent.\n* **restrict**: lever une exception si l'enregistrement a des descendants. \n\n\nLa fonction utilise `unscoped_descendants` pour accéder aux descendants et `without_ancestry_callbacks` pour éviter les conflits de callbacks.",
    "summary_spanish": "La función `apply_orphan_strategy` se encarga de aplicar la estrategia de huérfano definida para un registro. Recibe como argumentos `self` (el registro actual) y `child_ancestry` (la ancestria del registro hijo). Si las llamadas a los callbacks de ancestria no están deshabilitadas y el registro no es nuevo, la función evalúa la estrategia de huérfano definida en la clase base del ancestria. Dependiendo de la estrategia, la función realiza acciones como convertir a todos los descendientes en raíz, destruirlos, adoptarlos como hijos del padre o lanzar una excepción si el registro tiene descendientes.",
    "summary_portuguese": "apply_orphan_strategy: Esta função define a estratégia a ser aplicada quando um registro ancestral é excluído, considerando seus descendentes. \n\nArgs: \n-  None\n\nLogic:\n- Verifica se as chamadas de retorno de ancestralidade estão desabilitadas e se o registro é novo.\n- Se as condições forem atendidas, determina a estratégia de órfão (rootify, destroy, adopt ou restrict) com base na classe ancestral.\n- Aplica a estratégia correspondente aos descendentes:\n    - rootify: torna todos os descendentes raiz.\n    - destroy: remove todos os descendentes.\n    - adopt: move os descendentes para o pai do registro ancestral.\n    - restrict: lança uma exceção se houver descendentes.",
    "summary_arabic": "apply_orphan_strategy function is responsible for handling the behavior of descendants when a parent record is deleted. It takes no arguments. \n\nThe function checks if ancestry callbacks are disabled and if the current record is not new. Based on the `orphan_strategy` defined for the parent's ancestry base class, it performs different actions:\n\n- **:rootify**: Makes all descendants root nodes by removing their parent ancestry.\n- **:destroy**: Deletes all descendants.\n- **:adopt**: Moves descendants to become children of their parent's parent.\n- **:restrict**: Raises an exception if the parent record has any descendants.",
    "summary_hindi": "`apply_orphan_strategy` फ़ंक्शन किसी रिकॉर्ड को डिलीट करने से पहले उसके वंशजों के साथ होने वाले कार्यों को संभालता है। यह फ़ंक्शन `ancestry_base_class.orphan_strategy` के मान के आधार पर अलग-अलग कार्रवाई करता है। \n\nयह फ़ंक्शन `ancestry_callbacks_disabled?` और `new_record?` के मानों पर निर्भर करता है। \n\n**आर्गुमेंट्स:**\n\n*  कोई आर्गुमेंट नहीं\n\n**लॉजिक:**\n\n*  `rootify` स्ट्रेटेजी में, सभी वंशजों को रूट बना दिया जाता है।\n*  `destroy` स्ट्रेटेजी में, सभी वंशजों को डिलीट कर दिया जाता है।\n*  `adopt` स्ट्रेटेजी में, वंशजों को उनके मूल माता-पिता के बच्चे बना दिया जाता है।\n*  `restrict` स्ट्रेटेजी में, यदि कोई वंशज है तो एक अपवाद उत्पन्न होता है।"
  }
]